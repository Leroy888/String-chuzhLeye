/* soapC.cpp
   Generated by gSOAP 2.8.63 for MESWebService.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#pragma execution_character_set("utf-8")
SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.63 2018-04-08 07:43:20 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns1__FIDailyWorkReturnEntity:
		return soap_in_ns1__FIDailyWorkReturnEntity(soap, NULL, NULL, "ns1:FIDailyWorkReturnEntity");
	case SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity:
		return soap_in_ns1__ArrayOfFIDailyWorkReturnEntity(soap, NULL, NULL, "ns1:ArrayOfFIDailyWorkReturnEntity");
	case SOAP_TYPE_ns1__MaterialBatchResultInfo:
		return soap_in_ns1__MaterialBatchResultInfo(soap, NULL, NULL, "ns1:MaterialBatchResultInfo");
	case SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo:
		return soap_in_ns1__ArrayOfMaterialBatchResultInfo(soap, NULL, NULL, "ns1:ArrayOfMaterialBatchResultInfo");
	case SOAP_TYPE_ns1__DefectResultInfo:
		return soap_in_ns1__DefectResultInfo(soap, NULL, NULL, "ns1:DefectResultInfo");
	case SOAP_TYPE_ns1__ArrayOfDefectResultInfo:
		return soap_in_ns1__ArrayOfDefectResultInfo(soap, NULL, NULL, "ns1:ArrayOfDefectResultInfo");
	case SOAP_TYPE_ns1__ArrayOfSubmitResult:
		return soap_in_ns1__ArrayOfSubmitResult(soap, NULL, NULL, "ns1:ArrayOfSubmitResult");
	case SOAP_TYPE_ns1__SubmitResult:
		return soap_in_ns1__SubmitResult(soap, NULL, NULL, "ns1:SubmitResult");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__Login:
		return soap_in_PointerTo_ns1__Login(soap, NULL, NULL, "ns1:Login");
	case SOAP_TYPE_PointerTo_ns1__CanLogin:
		return soap_in_PointerTo_ns1__CanLogin(soap, NULL, NULL, "ns1:CanLogin");
	case SOAP_TYPE_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs:
		return soap_in_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, NULL, NULL, "ns1:Upload_FIDWUL_DATAFLAGs");
	case SOAP_TYPE_PointerTo_ns1__SetMaterialBatchResultToMES:
		return soap_in_PointerTo_ns1__SetMaterialBatchResultToMES(soap, NULL, NULL, "ns1:SetMaterialBatchResultToMES");
	case SOAP_TYPE_PointerTo_ns1__SetDefectResultToMES:
		return soap_in_PointerTo_ns1__SetDefectResultToMES(soap, NULL, NULL, "ns1:SetDefectResultToMES");
	case SOAP_TYPE_PointerTo_ns1__GetDefectInfoToSAP:
		return soap_in_PointerTo_ns1__GetDefectInfoToSAP(soap, NULL, NULL, "ns1:GetDefectInfoToSAP");
	case SOAP_TYPE_PointerTo_ns1__GetFtpAddress:
		return soap_in_PointerTo_ns1__GetFtpAddress(soap, NULL, NULL, "ns1:GetFtpAddress");
	case SOAP_TYPE_PointerTo_ns1__Iscalibrationcontainer:
		return soap_in_PointerTo_ns1__Iscalibrationcontainer(soap, NULL, NULL, "ns1:Iscalibrationcontainer");
	case SOAP_TYPE_PointerTo_ns1__GetTensileTestRule:
		return soap_in_PointerTo_ns1__GetTensileTestRule(soap, NULL, NULL, "ns1:GetTensileTestRule");
	case SOAP_TYPE_PointerTo_ns1__GetContainerDataInfoMES:
		return soap_in_PointerTo_ns1__GetContainerDataInfoMES(soap, NULL, NULL, "ns1:GetContainerDataInfoMES");
	case SOAP_TYPE_PointerTo_ns1__UploadTensileInfoToMes:
		return soap_in_PointerTo_ns1__UploadTensileInfoToMes(soap, NULL, NULL, "ns1:UploadTensileInfoToMes");
	case SOAP_TYPE_PointerTo_ns1__SafetyInfoMoveStd:
		return soap_in_PointerTo_ns1__SafetyInfoMoveStd(soap, NULL, NULL, "ns1:SafetyInfoMoveStd");
	case SOAP_TYPE_PointerTo_ns1__ELInfoMoveStd:
		return soap_in_PointerTo_ns1__ELInfoMoveStd(soap, NULL, NULL, "ns1:ELInfoMoveStd");
	case SOAP_TYPE_PointerTo_ns1__ELPictureAddress:
		return soap_in_PointerTo_ns1__ELPictureAddress(soap, NULL, NULL, "ns1:ELPictureAddress");
	case SOAP_TYPE_PointerTo_ns1__jKoIVMoveStd_USCORESpire:
		return soap_in_PointerTo_ns1__jKoIVMoveStd_USCORESpire(soap, NULL, NULL, "ns1:jKoIVMoveStd_Spire");
	case SOAP_TYPE_PointerTo_ns1__jKoIVMoveStd_USCOREPasan:
		return soap_in_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(soap, NULL, NULL, "ns1:jKoIVMoveStd_Pasan");
	case SOAP_TYPE_PointerTo_ns1__IV_USCOREDataCollection:
		return soap_in_PointerTo_ns1__IV_USCOREDataCollection(soap, NULL, NULL, "ns1:IV_DataCollection");
	case SOAP_TYPE_PointerTo_ns1__GetCurrentSpecBySn:
		return soap_in_PointerTo_ns1__GetCurrentSpecBySn(soap, NULL, NULL, "ns1:GetCurrentSpecBySn");
	case SOAP_TYPE_PointerTo_ns1__GetWorkCenterID:
		return soap_in_PointerTo_ns1__GetWorkCenterID(soap, NULL, NULL, "ns1:GetWorkCenterID");
	case SOAP_TYPE_PointerTons1__ArrayOfFIDailyWorkReturnEntity:
		return soap_in_PointerTons1__ArrayOfFIDailyWorkReturnEntity(soap, NULL, NULL, "ns1:ArrayOfFIDailyWorkReturnEntity");
	case SOAP_TYPE_PointerTons1__ArrayOfMaterialBatchResultInfo:
		return soap_in_PointerTons1__ArrayOfMaterialBatchResultInfo(soap, NULL, NULL, "ns1:ArrayOfMaterialBatchResultInfo");
	case SOAP_TYPE_PointerTons1__ArrayOfDefectResultInfo:
		return soap_in_PointerTons1__ArrayOfDefectResultInfo(soap, NULL, NULL, "ns1:ArrayOfDefectResultInfo");
	case SOAP_TYPE_PointerTons1__ArrayOfSubmitResult:
		return soap_in_PointerTons1__ArrayOfSubmitResult(soap, NULL, NULL, "ns1:ArrayOfSubmitResult");
	case SOAP_TYPE_PointerTons1__FIDailyWorkReturnEntity:
		return soap_in_PointerTons1__FIDailyWorkReturnEntity(soap, NULL, NULL, "ns1:FIDailyWorkReturnEntity");
	case SOAP_TYPE_PointerTons1__MaterialBatchResultInfo:
		return soap_in_PointerTons1__MaterialBatchResultInfo(soap, NULL, NULL, "ns1:MaterialBatchResultInfo");
	case SOAP_TYPE_PointerTons1__DefectResultInfo:
		return soap_in_PointerTons1__DefectResultInfo(soap, NULL, NULL, "ns1:DefectResultInfo");
	case SOAP_TYPE_PointerTons1__SubmitResult:
		return soap_in_PointerTons1__SubmitResult(soap, NULL, NULL, "ns1:SubmitResult");
	case SOAP_TYPE_PointerTo_ns1__SubmitResult_ResultTable:
		return soap_in_PointerTo_ns1__SubmitResult_ResultTable(soap, NULL, NULL, "ns1:SubmitResult-ResultTable");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:FIDailyWorkReturnEntity"))
		{	*type = SOAP_TYPE_ns1__FIDailyWorkReturnEntity;
			return soap_in_ns1__FIDailyWorkReturnEntity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfFIDailyWorkReturnEntity"))
		{	*type = SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity;
			return soap_in_ns1__ArrayOfFIDailyWorkReturnEntity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MaterialBatchResultInfo"))
		{	*type = SOAP_TYPE_ns1__MaterialBatchResultInfo;
			return soap_in_ns1__MaterialBatchResultInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfMaterialBatchResultInfo"))
		{	*type = SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo;
			return soap_in_ns1__ArrayOfMaterialBatchResultInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DefectResultInfo"))
		{	*type = SOAP_TYPE_ns1__DefectResultInfo;
			return soap_in_ns1__DefectResultInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDefectResultInfo"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDefectResultInfo;
			return soap_in_ns1__ArrayOfDefectResultInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfSubmitResult"))
		{	*type = SOAP_TYPE_ns1__ArrayOfSubmitResult;
			return soap_in_ns1__ArrayOfSubmitResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubmitResult"))
		{	*type = SOAP_TYPE_ns1__SubmitResult;
			return soap_in_ns1__SubmitResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:SubmitResult-ResultTable"))
		{	*type = SOAP_TYPE__ns1__SubmitResult_ResultTable;
			return soap_in__ns1__SubmitResult_ResultTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LoginResponse"))
		{	*type = SOAP_TYPE__ns1__LoginResponse;
			return soap_in__ns1__LoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Login"))
		{	*type = SOAP_TYPE__ns1__Login;
			return soap_in__ns1__Login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CanLoginResponse"))
		{	*type = SOAP_TYPE__ns1__CanLoginResponse;
			return soap_in__ns1__CanLoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CanLogin"))
		{	*type = SOAP_TYPE__ns1__CanLogin;
			return soap_in__ns1__CanLogin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Upload_FIDWUL_DATAFLAGsResponse"))
		{	*type = SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse;
			return soap_in__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Upload_FIDWUL_DATAFLAGs"))
		{	*type = SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs;
			return soap_in__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetMaterialBatchResultToMESResponse"))
		{	*type = SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse;
			return soap_in__ns1__SetMaterialBatchResultToMESResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetMaterialBatchResultToMES"))
		{	*type = SOAP_TYPE__ns1__SetMaterialBatchResultToMES;
			return soap_in__ns1__SetMaterialBatchResultToMES(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetDefectResultToMESResponse"))
		{	*type = SOAP_TYPE__ns1__SetDefectResultToMESResponse;
			return soap_in__ns1__SetDefectResultToMESResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SetDefectResultToMES"))
		{	*type = SOAP_TYPE__ns1__SetDefectResultToMES;
			return soap_in__ns1__SetDefectResultToMES(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDefectInfoToSAPResponse"))
		{	*type = SOAP_TYPE__ns1__GetDefectInfoToSAPResponse;
			return soap_in__ns1__GetDefectInfoToSAPResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetDefectInfoToSAP"))
		{	*type = SOAP_TYPE__ns1__GetDefectInfoToSAP;
			return soap_in__ns1__GetDefectInfoToSAP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFtpAddressResponse"))
		{	*type = SOAP_TYPE__ns1__GetFtpAddressResponse;
			return soap_in__ns1__GetFtpAddressResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetFtpAddress"))
		{	*type = SOAP_TYPE__ns1__GetFtpAddress;
			return soap_in__ns1__GetFtpAddress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:IscalibrationcontainerResponse"))
		{	*type = SOAP_TYPE__ns1__IscalibrationcontainerResponse;
			return soap_in__ns1__IscalibrationcontainerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Iscalibrationcontainer"))
		{	*type = SOAP_TYPE__ns1__Iscalibrationcontainer;
			return soap_in__ns1__Iscalibrationcontainer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTensileTestRuleResponse"))
		{	*type = SOAP_TYPE__ns1__GetTensileTestRuleResponse;
			return soap_in__ns1__GetTensileTestRuleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetTensileTestRule"))
		{	*type = SOAP_TYPE__ns1__GetTensileTestRule;
			return soap_in__ns1__GetTensileTestRule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetContainerDataInfoMESResponse"))
		{	*type = SOAP_TYPE__ns1__GetContainerDataInfoMESResponse;
			return soap_in__ns1__GetContainerDataInfoMESResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetContainerDataInfoMES"))
		{	*type = SOAP_TYPE__ns1__GetContainerDataInfoMES;
			return soap_in__ns1__GetContainerDataInfoMES(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadTensileInfoToMesResponse"))
		{	*type = SOAP_TYPE__ns1__UploadTensileInfoToMesResponse;
			return soap_in__ns1__UploadTensileInfoToMesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadTensileInfoToMes"))
		{	*type = SOAP_TYPE__ns1__UploadTensileInfoToMes;
			return soap_in__ns1__UploadTensileInfoToMes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SafetyInfoMoveStdResponse"))
		{	*type = SOAP_TYPE__ns1__SafetyInfoMoveStdResponse;
			return soap_in__ns1__SafetyInfoMoveStdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SafetyInfoMoveStd"))
		{	*type = SOAP_TYPE__ns1__SafetyInfoMoveStd;
			return soap_in__ns1__SafetyInfoMoveStd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ELInfoMoveStdResponse"))
		{	*type = SOAP_TYPE__ns1__ELInfoMoveStdResponse;
			return soap_in__ns1__ELInfoMoveStdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ELInfoMoveStd"))
		{	*type = SOAP_TYPE__ns1__ELInfoMoveStd;
			return soap_in__ns1__ELInfoMoveStd(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ELPictureAddressResponse"))
		{	*type = SOAP_TYPE__ns1__ELPictureAddressResponse;
			return soap_in__ns1__ELPictureAddressResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ELPictureAddress"))
		{	*type = SOAP_TYPE__ns1__ELPictureAddress;
			return soap_in__ns1__ELPictureAddress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jKoIVMoveStd_SpireResponse"))
		{	*type = SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse;
			return soap_in__ns1__jKoIVMoveStd_USCORESpireResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jKoIVMoveStd_Spire"))
		{	*type = SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire;
			return soap_in__ns1__jKoIVMoveStd_USCORESpire(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jKoIVMoveStd_PasanResponse"))
		{	*type = SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse;
			return soap_in__ns1__jKoIVMoveStd_USCOREPasanResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jKoIVMoveStd_Pasan"))
		{	*type = SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan;
			return soap_in__ns1__jKoIVMoveStd_USCOREPasan(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:IV_DataCollectionResponse"))
		{	*type = SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse;
			return soap_in__ns1__IV_USCOREDataCollectionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:IV_DataCollection"))
		{	*type = SOAP_TYPE__ns1__IV_USCOREDataCollection;
			return soap_in__ns1__IV_USCOREDataCollection(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCurrentSpecBySnResponse"))
		{	*type = SOAP_TYPE__ns1__GetCurrentSpecBySnResponse;
			return soap_in__ns1__GetCurrentSpecBySnResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCurrentSpecBySn"))
		{	*type = SOAP_TYPE__ns1__GetCurrentSpecBySn;
			return soap_in__ns1__GetCurrentSpecBySn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetWorkCenterIDResponse"))
		{	*type = SOAP_TYPE__ns1__GetWorkCenterIDResponse;
			return soap_in__ns1__GetWorkCenterIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetWorkCenterID"))
		{	*type = SOAP_TYPE__ns1__GetWorkCenterID;
			return soap_in__ns1__GetWorkCenterID(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE__ns1__SubmitResult_ResultTable:
		return ((_ns1__SubmitResult_ResultTable *)ptr)->soap_out(soap, "ns1:SubmitResult-ResultTable", id, "");
	case SOAP_TYPE__ns1__LoginResponse:
		return ((_ns1__LoginResponse *)ptr)->soap_out(soap, "ns1:LoginResponse", id, "");
	case SOAP_TYPE__ns1__Login:
		return ((_ns1__Login *)ptr)->soap_out(soap, "ns1:Login", id, "");
	case SOAP_TYPE__ns1__CanLoginResponse:
		return ((_ns1__CanLoginResponse *)ptr)->soap_out(soap, "ns1:CanLoginResponse", id, "");
	case SOAP_TYPE__ns1__CanLogin:
		return ((_ns1__CanLogin *)ptr)->soap_out(soap, "ns1:CanLogin", id, "");
	case SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse:
		return ((_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse *)ptr)->soap_out(soap, "ns1:Upload_FIDWUL_DATAFLAGsResponse", id, "");
	case SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs:
		return ((_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *)ptr)->soap_out(soap, "ns1:Upload_FIDWUL_DATAFLAGs", id, "");
	case SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse:
		return ((_ns1__SetMaterialBatchResultToMESResponse *)ptr)->soap_out(soap, "ns1:SetMaterialBatchResultToMESResponse", id, "");
	case SOAP_TYPE__ns1__SetMaterialBatchResultToMES:
		return ((_ns1__SetMaterialBatchResultToMES *)ptr)->soap_out(soap, "ns1:SetMaterialBatchResultToMES", id, "");
	case SOAP_TYPE__ns1__SetDefectResultToMESResponse:
		return ((_ns1__SetDefectResultToMESResponse *)ptr)->soap_out(soap, "ns1:SetDefectResultToMESResponse", id, "");
	case SOAP_TYPE__ns1__SetDefectResultToMES:
		return ((_ns1__SetDefectResultToMES *)ptr)->soap_out(soap, "ns1:SetDefectResultToMES", id, "");
	case SOAP_TYPE__ns1__GetDefectInfoToSAPResponse:
		return ((_ns1__GetDefectInfoToSAPResponse *)ptr)->soap_out(soap, "ns1:GetDefectInfoToSAPResponse", id, "");
	case SOAP_TYPE__ns1__GetDefectInfoToSAP:
		return ((_ns1__GetDefectInfoToSAP *)ptr)->soap_out(soap, "ns1:GetDefectInfoToSAP", id, "");
	case SOAP_TYPE__ns1__GetFtpAddressResponse:
		return ((_ns1__GetFtpAddressResponse *)ptr)->soap_out(soap, "ns1:GetFtpAddressResponse", id, "");
	case SOAP_TYPE__ns1__GetFtpAddress:
		return ((_ns1__GetFtpAddress *)ptr)->soap_out(soap, "ns1:GetFtpAddress", id, "");
	case SOAP_TYPE__ns1__IscalibrationcontainerResponse:
		return ((_ns1__IscalibrationcontainerResponse *)ptr)->soap_out(soap, "ns1:IscalibrationcontainerResponse", id, "");
	case SOAP_TYPE__ns1__Iscalibrationcontainer:
		return ((_ns1__Iscalibrationcontainer *)ptr)->soap_out(soap, "ns1:Iscalibrationcontainer", id, "");
	case SOAP_TYPE__ns1__GetTensileTestRuleResponse:
		return ((_ns1__GetTensileTestRuleResponse *)ptr)->soap_out(soap, "ns1:GetTensileTestRuleResponse", id, "");
	case SOAP_TYPE__ns1__GetTensileTestRule:
		return ((_ns1__GetTensileTestRule *)ptr)->soap_out(soap, "ns1:GetTensileTestRule", id, "");
	case SOAP_TYPE__ns1__GetContainerDataInfoMESResponse:
		return ((_ns1__GetContainerDataInfoMESResponse *)ptr)->soap_out(soap, "ns1:GetContainerDataInfoMESResponse", id, "");
	case SOAP_TYPE__ns1__GetContainerDataInfoMES:
		return ((_ns1__GetContainerDataInfoMES *)ptr)->soap_out(soap, "ns1:GetContainerDataInfoMES", id, "");
	case SOAP_TYPE__ns1__UploadTensileInfoToMesResponse:
		return ((_ns1__UploadTensileInfoToMesResponse *)ptr)->soap_out(soap, "ns1:UploadTensileInfoToMesResponse", id, "");
	case SOAP_TYPE__ns1__UploadTensileInfoToMes:
		return ((_ns1__UploadTensileInfoToMes *)ptr)->soap_out(soap, "ns1:UploadTensileInfoToMes", id, "");
	case SOAP_TYPE__ns1__SafetyInfoMoveStdResponse:
		return ((_ns1__SafetyInfoMoveStdResponse *)ptr)->soap_out(soap, "ns1:SafetyInfoMoveStdResponse", id, "");
	case SOAP_TYPE__ns1__SafetyInfoMoveStd:
		return ((_ns1__SafetyInfoMoveStd *)ptr)->soap_out(soap, "ns1:SafetyInfoMoveStd", id, "");
	case SOAP_TYPE__ns1__ELInfoMoveStdResponse:
		return ((_ns1__ELInfoMoveStdResponse *)ptr)->soap_out(soap, "ns1:ELInfoMoveStdResponse", id, "");
	case SOAP_TYPE__ns1__ELInfoMoveStd:
		return ((_ns1__ELInfoMoveStd *)ptr)->soap_out(soap, "ns1:ELInfoMoveStd", id, "");
	case SOAP_TYPE__ns1__ELPictureAddressResponse:
		return ((_ns1__ELPictureAddressResponse *)ptr)->soap_out(soap, "ns1:ELPictureAddressResponse", id, "");
	case SOAP_TYPE__ns1__ELPictureAddress:
		return ((_ns1__ELPictureAddress *)ptr)->soap_out(soap, "ns1:ELPictureAddress", id, "");
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse:
		return ((_ns1__jKoIVMoveStd_USCORESpireResponse *)ptr)->soap_out(soap, "ns1:jKoIVMoveStd_SpireResponse", id, "");
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire:
		return ((_ns1__jKoIVMoveStd_USCORESpire *)ptr)->soap_out(soap, "ns1:jKoIVMoveStd_Spire", id, "");
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse:
		return ((_ns1__jKoIVMoveStd_USCOREPasanResponse *)ptr)->soap_out(soap, "ns1:jKoIVMoveStd_PasanResponse", id, "");
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan:
		return ((_ns1__jKoIVMoveStd_USCOREPasan *)ptr)->soap_out(soap, "ns1:jKoIVMoveStd_Pasan", id, "");
	case SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse:
		return ((_ns1__IV_USCOREDataCollectionResponse *)ptr)->soap_out(soap, "ns1:IV_DataCollectionResponse", id, "");
	case SOAP_TYPE__ns1__IV_USCOREDataCollection:
		return ((_ns1__IV_USCOREDataCollection *)ptr)->soap_out(soap, "ns1:IV_DataCollection", id, "");
	case SOAP_TYPE__ns1__GetCurrentSpecBySnResponse:
		return ((_ns1__GetCurrentSpecBySnResponse *)ptr)->soap_out(soap, "ns1:GetCurrentSpecBySnResponse", id, "");
	case SOAP_TYPE__ns1__GetCurrentSpecBySn:
		return ((_ns1__GetCurrentSpecBySn *)ptr)->soap_out(soap, "ns1:GetCurrentSpecBySn", id, "");
	case SOAP_TYPE__ns1__GetWorkCenterIDResponse:
		return ((_ns1__GetWorkCenterIDResponse *)ptr)->soap_out(soap, "ns1:GetWorkCenterIDResponse", id, "");
	case SOAP_TYPE__ns1__GetWorkCenterID:
		return ((_ns1__GetWorkCenterID *)ptr)->soap_out(soap, "ns1:GetWorkCenterID", id, "");
	case SOAP_TYPE_ns1__FIDailyWorkReturnEntity:
		return ((ns1__FIDailyWorkReturnEntity *)ptr)->soap_out(soap, tag, id, "ns1:FIDailyWorkReturnEntity");
	case SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity:
		return ((ns1__ArrayOfFIDailyWorkReturnEntity *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfFIDailyWorkReturnEntity");
	case SOAP_TYPE_ns1__MaterialBatchResultInfo:
		return ((ns1__MaterialBatchResultInfo *)ptr)->soap_out(soap, tag, id, "ns1:MaterialBatchResultInfo");
	case SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo:
		return ((ns1__ArrayOfMaterialBatchResultInfo *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfMaterialBatchResultInfo");
	case SOAP_TYPE_ns1__DefectResultInfo:
		return ((ns1__DefectResultInfo *)ptr)->soap_out(soap, tag, id, "ns1:DefectResultInfo");
	case SOAP_TYPE_ns1__ArrayOfDefectResultInfo:
		return ((ns1__ArrayOfDefectResultInfo *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfDefectResultInfo");
	case SOAP_TYPE_ns1__ArrayOfSubmitResult:
		return ((ns1__ArrayOfSubmitResult *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfSubmitResult");
	case SOAP_TYPE_ns1__SubmitResult:
		return ((ns1__SubmitResult *)ptr)->soap_out(soap, tag, id, "ns1:SubmitResult");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__Login:
		return soap_out_PointerTo_ns1__Login(soap, tag, id, (_ns1__Login *const*)ptr, "ns1:Login");
	case SOAP_TYPE_PointerTo_ns1__CanLogin:
		return soap_out_PointerTo_ns1__CanLogin(soap, tag, id, (_ns1__CanLogin *const*)ptr, "ns1:CanLogin");
	case SOAP_TYPE_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs:
		return soap_out_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, tag, id, (_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *const*)ptr, "ns1:Upload_FIDWUL_DATAFLAGs");
	case SOAP_TYPE_PointerTo_ns1__SetMaterialBatchResultToMES:
		return soap_out_PointerTo_ns1__SetMaterialBatchResultToMES(soap, tag, id, (_ns1__SetMaterialBatchResultToMES *const*)ptr, "ns1:SetMaterialBatchResultToMES");
	case SOAP_TYPE_PointerTo_ns1__SetDefectResultToMES:
		return soap_out_PointerTo_ns1__SetDefectResultToMES(soap, tag, id, (_ns1__SetDefectResultToMES *const*)ptr, "ns1:SetDefectResultToMES");
	case SOAP_TYPE_PointerTo_ns1__GetDefectInfoToSAP:
		return soap_out_PointerTo_ns1__GetDefectInfoToSAP(soap, tag, id, (_ns1__GetDefectInfoToSAP *const*)ptr, "ns1:GetDefectInfoToSAP");
	case SOAP_TYPE_PointerTo_ns1__GetFtpAddress:
		return soap_out_PointerTo_ns1__GetFtpAddress(soap, tag, id, (_ns1__GetFtpAddress *const*)ptr, "ns1:GetFtpAddress");
	case SOAP_TYPE_PointerTo_ns1__Iscalibrationcontainer:
		return soap_out_PointerTo_ns1__Iscalibrationcontainer(soap, tag, id, (_ns1__Iscalibrationcontainer *const*)ptr, "ns1:Iscalibrationcontainer");
	case SOAP_TYPE_PointerTo_ns1__GetTensileTestRule:
		return soap_out_PointerTo_ns1__GetTensileTestRule(soap, tag, id, (_ns1__GetTensileTestRule *const*)ptr, "ns1:GetTensileTestRule");
	case SOAP_TYPE_PointerTo_ns1__GetContainerDataInfoMES:
		return soap_out_PointerTo_ns1__GetContainerDataInfoMES(soap, tag, id, (_ns1__GetContainerDataInfoMES *const*)ptr, "ns1:GetContainerDataInfoMES");
	case SOAP_TYPE_PointerTo_ns1__UploadTensileInfoToMes:
		return soap_out_PointerTo_ns1__UploadTensileInfoToMes(soap, tag, id, (_ns1__UploadTensileInfoToMes *const*)ptr, "ns1:UploadTensileInfoToMes");
	case SOAP_TYPE_PointerTo_ns1__SafetyInfoMoveStd:
		return soap_out_PointerTo_ns1__SafetyInfoMoveStd(soap, tag, id, (_ns1__SafetyInfoMoveStd *const*)ptr, "ns1:SafetyInfoMoveStd");
	case SOAP_TYPE_PointerTo_ns1__ELInfoMoveStd:
		return soap_out_PointerTo_ns1__ELInfoMoveStd(soap, tag, id, (_ns1__ELInfoMoveStd *const*)ptr, "ns1:ELInfoMoveStd");
	case SOAP_TYPE_PointerTo_ns1__ELPictureAddress:
		return soap_out_PointerTo_ns1__ELPictureAddress(soap, tag, id, (_ns1__ELPictureAddress *const*)ptr, "ns1:ELPictureAddress");
	case SOAP_TYPE_PointerTo_ns1__jKoIVMoveStd_USCORESpire:
		return soap_out_PointerTo_ns1__jKoIVMoveStd_USCORESpire(soap, tag, id, (_ns1__jKoIVMoveStd_USCORESpire *const*)ptr, "ns1:jKoIVMoveStd_Spire");
	case SOAP_TYPE_PointerTo_ns1__jKoIVMoveStd_USCOREPasan:
		return soap_out_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(soap, tag, id, (_ns1__jKoIVMoveStd_USCOREPasan *const*)ptr, "ns1:jKoIVMoveStd_Pasan");
	case SOAP_TYPE_PointerTo_ns1__IV_USCOREDataCollection:
		return soap_out_PointerTo_ns1__IV_USCOREDataCollection(soap, tag, id, (_ns1__IV_USCOREDataCollection *const*)ptr, "ns1:IV_DataCollection");
	case SOAP_TYPE_PointerTo_ns1__GetCurrentSpecBySn:
		return soap_out_PointerTo_ns1__GetCurrentSpecBySn(soap, tag, id, (_ns1__GetCurrentSpecBySn *const*)ptr, "ns1:GetCurrentSpecBySn");
	case SOAP_TYPE_PointerTo_ns1__GetWorkCenterID:
		return soap_out_PointerTo_ns1__GetWorkCenterID(soap, tag, id, (_ns1__GetWorkCenterID *const*)ptr, "ns1:GetWorkCenterID");
	case SOAP_TYPE_PointerTons1__ArrayOfFIDailyWorkReturnEntity:
		return soap_out_PointerTons1__ArrayOfFIDailyWorkReturnEntity(soap, tag, id, (ns1__ArrayOfFIDailyWorkReturnEntity *const*)ptr, "ns1:ArrayOfFIDailyWorkReturnEntity");
	case SOAP_TYPE_PointerTons1__ArrayOfMaterialBatchResultInfo:
		return soap_out_PointerTons1__ArrayOfMaterialBatchResultInfo(soap, tag, id, (ns1__ArrayOfMaterialBatchResultInfo *const*)ptr, "ns1:ArrayOfMaterialBatchResultInfo");
	case SOAP_TYPE_PointerTons1__ArrayOfDefectResultInfo:
		return soap_out_PointerTons1__ArrayOfDefectResultInfo(soap, tag, id, (ns1__ArrayOfDefectResultInfo *const*)ptr, "ns1:ArrayOfDefectResultInfo");
	case SOAP_TYPE_PointerTons1__ArrayOfSubmitResult:
		return soap_out_PointerTons1__ArrayOfSubmitResult(soap, tag, id, (ns1__ArrayOfSubmitResult *const*)ptr, "ns1:ArrayOfSubmitResult");
	case SOAP_TYPE_PointerTons1__FIDailyWorkReturnEntity:
		return soap_out_PointerTons1__FIDailyWorkReturnEntity(soap, tag, id, (ns1__FIDailyWorkReturnEntity *const*)ptr, "ns1:FIDailyWorkReturnEntity");
	case SOAP_TYPE_PointerTons1__MaterialBatchResultInfo:
		return soap_out_PointerTons1__MaterialBatchResultInfo(soap, tag, id, (ns1__MaterialBatchResultInfo *const*)ptr, "ns1:MaterialBatchResultInfo");
	case SOAP_TYPE_PointerTons1__DefectResultInfo:
		return soap_out_PointerTons1__DefectResultInfo(soap, tag, id, (ns1__DefectResultInfo *const*)ptr, "ns1:DefectResultInfo");
	case SOAP_TYPE_PointerTons1__SubmitResult:
		return soap_out_PointerTons1__SubmitResult(soap, tag, id, (ns1__SubmitResult *const*)ptr, "ns1:SubmitResult");
	case SOAP_TYPE_PointerTo_ns1__SubmitResult_ResultTable:
		return soap_out_PointerTo_ns1__SubmitResult_ResultTable(soap, tag, id, (_ns1__SubmitResult_ResultTable *const*)ptr, "ns1:SubmitResult-ResultTable");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__SubmitResult_ResultTable:
		((_ns1__SubmitResult_ResultTable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LoginResponse:
		((_ns1__LoginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Login:
		((_ns1__Login *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CanLoginResponse:
		((_ns1__CanLoginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CanLogin:
		((_ns1__CanLogin *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse:
		((_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs:
		((_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse:
		((_ns1__SetMaterialBatchResultToMESResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetMaterialBatchResultToMES:
		((_ns1__SetMaterialBatchResultToMES *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetDefectResultToMESResponse:
		((_ns1__SetDefectResultToMESResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SetDefectResultToMES:
		((_ns1__SetDefectResultToMES *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDefectInfoToSAPResponse:
		((_ns1__GetDefectInfoToSAPResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetDefectInfoToSAP:
		((_ns1__GetDefectInfoToSAP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetFtpAddressResponse:
		((_ns1__GetFtpAddressResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetFtpAddress:
		((_ns1__GetFtpAddress *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__IscalibrationcontainerResponse:
		((_ns1__IscalibrationcontainerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Iscalibrationcontainer:
		((_ns1__Iscalibrationcontainer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTensileTestRuleResponse:
		((_ns1__GetTensileTestRuleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetTensileTestRule:
		((_ns1__GetTensileTestRule *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetContainerDataInfoMESResponse:
		((_ns1__GetContainerDataInfoMESResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetContainerDataInfoMES:
		((_ns1__GetContainerDataInfoMES *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UploadTensileInfoToMesResponse:
		((_ns1__UploadTensileInfoToMesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UploadTensileInfoToMes:
		((_ns1__UploadTensileInfoToMes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SafetyInfoMoveStdResponse:
		((_ns1__SafetyInfoMoveStdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SafetyInfoMoveStd:
		((_ns1__SafetyInfoMoveStd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ELInfoMoveStdResponse:
		((_ns1__ELInfoMoveStdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ELInfoMoveStd:
		((_ns1__ELInfoMoveStd *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ELPictureAddressResponse:
		((_ns1__ELPictureAddressResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ELPictureAddress:
		((_ns1__ELPictureAddress *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse:
		((_ns1__jKoIVMoveStd_USCORESpireResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire:
		((_ns1__jKoIVMoveStd_USCORESpire *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse:
		((_ns1__jKoIVMoveStd_USCOREPasanResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan:
		((_ns1__jKoIVMoveStd_USCOREPasan *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse:
		((_ns1__IV_USCOREDataCollectionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__IV_USCOREDataCollection:
		((_ns1__IV_USCOREDataCollection *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetCurrentSpecBySnResponse:
		((_ns1__GetCurrentSpecBySnResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetCurrentSpecBySn:
		((_ns1__GetCurrentSpecBySn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetWorkCenterIDResponse:
		((_ns1__GetWorkCenterIDResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetWorkCenterID:
		((_ns1__GetWorkCenterID *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__FIDailyWorkReturnEntity:
		((ns1__FIDailyWorkReturnEntity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity:
		((ns1__ArrayOfFIDailyWorkReturnEntity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MaterialBatchResultInfo:
		((ns1__MaterialBatchResultInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo:
		((ns1__ArrayOfMaterialBatchResultInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DefectResultInfo:
		((ns1__DefectResultInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfDefectResultInfo:
		((ns1__ArrayOfDefectResultInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfSubmitResult:
		((ns1__ArrayOfSubmitResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubmitResult:
		((ns1__SubmitResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns1__Login_:
		soap_serialize___ns1__Login_(soap, (const struct __ns1__Login_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CanLogin_:
		soap_serialize___ns1__CanLogin_(soap, (const struct __ns1__CanLogin_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_:
		soap_serialize___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(soap, (const struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SetMaterialBatchResultToMES_:
		soap_serialize___ns1__SetMaterialBatchResultToMES_(soap, (const struct __ns1__SetMaterialBatchResultToMES_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SetDefectResultToMES_:
		soap_serialize___ns1__SetDefectResultToMES_(soap, (const struct __ns1__SetDefectResultToMES_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDefectInfoToSAP_:
		soap_serialize___ns1__GetDefectInfoToSAP_(soap, (const struct __ns1__GetDefectInfoToSAP_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetFtpAddress_:
		soap_serialize___ns1__GetFtpAddress_(soap, (const struct __ns1__GetFtpAddress_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Iscalibrationcontainer_:
		soap_serialize___ns1__Iscalibrationcontainer_(soap, (const struct __ns1__Iscalibrationcontainer_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTensileTestRule_:
		soap_serialize___ns1__GetTensileTestRule_(soap, (const struct __ns1__GetTensileTestRule_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetContainerDataInfoMES_:
		soap_serialize___ns1__GetContainerDataInfoMES_(soap, (const struct __ns1__GetContainerDataInfoMES_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadTensileInfoToMes_:
		soap_serialize___ns1__UploadTensileInfoToMes_(soap, (const struct __ns1__UploadTensileInfoToMes_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SafetyInfoMoveStd_:
		soap_serialize___ns1__SafetyInfoMoveStd_(soap, (const struct __ns1__SafetyInfoMoveStd_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ELInfoMoveStd_:
		soap_serialize___ns1__ELInfoMoveStd_(soap, (const struct __ns1__ELInfoMoveStd_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ELPictureAddress_:
		soap_serialize___ns1__ELPictureAddress_(soap, (const struct __ns1__ELPictureAddress_ *)ptr);
		break;
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire_:
		soap_serialize___ns1__jKoIVMoveStd_USCORESpire_(soap, (const struct __ns1__jKoIVMoveStd_USCORESpire_ *)ptr);
		break;
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan_:
		soap_serialize___ns1__jKoIVMoveStd_USCOREPasan_(soap, (const struct __ns1__jKoIVMoveStd_USCOREPasan_ *)ptr);
		break;
	case SOAP_TYPE___ns1__IV_USCOREDataCollection_:
		soap_serialize___ns1__IV_USCOREDataCollection_(soap, (const struct __ns1__IV_USCOREDataCollection_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetCurrentSpecBySn_:
		soap_serialize___ns1__GetCurrentSpecBySn_(soap, (const struct __ns1__GetCurrentSpecBySn_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetWorkCenterID_:
		soap_serialize___ns1__GetWorkCenterID_(soap, (const struct __ns1__GetWorkCenterID_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Login:
		soap_serialize___ns1__Login(soap, (const struct __ns1__Login *)ptr);
		break;
	case SOAP_TYPE___ns1__CanLogin:
		soap_serialize___ns1__CanLogin(soap, (const struct __ns1__CanLogin *)ptr);
		break;
	case SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs:
		soap_serialize___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, (const struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *)ptr);
		break;
	case SOAP_TYPE___ns1__SetMaterialBatchResultToMES:
		soap_serialize___ns1__SetMaterialBatchResultToMES(soap, (const struct __ns1__SetMaterialBatchResultToMES *)ptr);
		break;
	case SOAP_TYPE___ns1__SetDefectResultToMES:
		soap_serialize___ns1__SetDefectResultToMES(soap, (const struct __ns1__SetDefectResultToMES *)ptr);
		break;
	case SOAP_TYPE___ns1__GetDefectInfoToSAP:
		soap_serialize___ns1__GetDefectInfoToSAP(soap, (const struct __ns1__GetDefectInfoToSAP *)ptr);
		break;
	case SOAP_TYPE___ns1__GetFtpAddress:
		soap_serialize___ns1__GetFtpAddress(soap, (const struct __ns1__GetFtpAddress *)ptr);
		break;
	case SOAP_TYPE___ns1__Iscalibrationcontainer:
		soap_serialize___ns1__Iscalibrationcontainer(soap, (const struct __ns1__Iscalibrationcontainer *)ptr);
		break;
	case SOAP_TYPE___ns1__GetTensileTestRule:
		soap_serialize___ns1__GetTensileTestRule(soap, (const struct __ns1__GetTensileTestRule *)ptr);
		break;
	case SOAP_TYPE___ns1__GetContainerDataInfoMES:
		soap_serialize___ns1__GetContainerDataInfoMES(soap, (const struct __ns1__GetContainerDataInfoMES *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadTensileInfoToMes:
		soap_serialize___ns1__UploadTensileInfoToMes(soap, (const struct __ns1__UploadTensileInfoToMes *)ptr);
		break;
	case SOAP_TYPE___ns1__SafetyInfoMoveStd:
		soap_serialize___ns1__SafetyInfoMoveStd(soap, (const struct __ns1__SafetyInfoMoveStd *)ptr);
		break;
	case SOAP_TYPE___ns1__ELInfoMoveStd:
		soap_serialize___ns1__ELInfoMoveStd(soap, (const struct __ns1__ELInfoMoveStd *)ptr);
		break;
	case SOAP_TYPE___ns1__ELPictureAddress:
		soap_serialize___ns1__ELPictureAddress(soap, (const struct __ns1__ELPictureAddress *)ptr);
		break;
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire:
		soap_serialize___ns1__jKoIVMoveStd_USCORESpire(soap, (const struct __ns1__jKoIVMoveStd_USCORESpire *)ptr);
		break;
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan:
		soap_serialize___ns1__jKoIVMoveStd_USCOREPasan(soap, (const struct __ns1__jKoIVMoveStd_USCOREPasan *)ptr);
		break;
	case SOAP_TYPE___ns1__IV_USCOREDataCollection:
		soap_serialize___ns1__IV_USCOREDataCollection(soap, (const struct __ns1__IV_USCOREDataCollection *)ptr);
		break;
	case SOAP_TYPE___ns1__GetCurrentSpecBySn:
		soap_serialize___ns1__GetCurrentSpecBySn(soap, (const struct __ns1__GetCurrentSpecBySn *)ptr);
		break;
	case SOAP_TYPE___ns1__GetWorkCenterID:
		soap_serialize___ns1__GetWorkCenterID(soap, (const struct __ns1__GetWorkCenterID *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Login:
		soap_serialize_PointerTo_ns1__Login(soap, (_ns1__Login *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CanLogin:
		soap_serialize_PointerTo_ns1__CanLogin(soap, (_ns1__CanLogin *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs:
		soap_serialize_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, (_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetMaterialBatchResultToMES:
		soap_serialize_PointerTo_ns1__SetMaterialBatchResultToMES(soap, (_ns1__SetMaterialBatchResultToMES *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SetDefectResultToMES:
		soap_serialize_PointerTo_ns1__SetDefectResultToMES(soap, (_ns1__SetDefectResultToMES *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetDefectInfoToSAP:
		soap_serialize_PointerTo_ns1__GetDefectInfoToSAP(soap, (_ns1__GetDefectInfoToSAP *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetFtpAddress:
		soap_serialize_PointerTo_ns1__GetFtpAddress(soap, (_ns1__GetFtpAddress *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Iscalibrationcontainer:
		soap_serialize_PointerTo_ns1__Iscalibrationcontainer(soap, (_ns1__Iscalibrationcontainer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetTensileTestRule:
		soap_serialize_PointerTo_ns1__GetTensileTestRule(soap, (_ns1__GetTensileTestRule *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetContainerDataInfoMES:
		soap_serialize_PointerTo_ns1__GetContainerDataInfoMES(soap, (_ns1__GetContainerDataInfoMES *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UploadTensileInfoToMes:
		soap_serialize_PointerTo_ns1__UploadTensileInfoToMes(soap, (_ns1__UploadTensileInfoToMes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SafetyInfoMoveStd:
		soap_serialize_PointerTo_ns1__SafetyInfoMoveStd(soap, (_ns1__SafetyInfoMoveStd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ELInfoMoveStd:
		soap_serialize_PointerTo_ns1__ELInfoMoveStd(soap, (_ns1__ELInfoMoveStd *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ELPictureAddress:
		soap_serialize_PointerTo_ns1__ELPictureAddress(soap, (_ns1__ELPictureAddress *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__jKoIVMoveStd_USCORESpire:
		soap_serialize_PointerTo_ns1__jKoIVMoveStd_USCORESpire(soap, (_ns1__jKoIVMoveStd_USCORESpire *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__jKoIVMoveStd_USCOREPasan:
		soap_serialize_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(soap, (_ns1__jKoIVMoveStd_USCOREPasan *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__IV_USCOREDataCollection:
		soap_serialize_PointerTo_ns1__IV_USCOREDataCollection(soap, (_ns1__IV_USCOREDataCollection *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetCurrentSpecBySn:
		soap_serialize_PointerTo_ns1__GetCurrentSpecBySn(soap, (_ns1__GetCurrentSpecBySn *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetWorkCenterID:
		soap_serialize_PointerTo_ns1__GetWorkCenterID(soap, (_ns1__GetWorkCenterID *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfFIDailyWorkReturnEntity:
		soap_serialize_PointerTons1__ArrayOfFIDailyWorkReturnEntity(soap, (ns1__ArrayOfFIDailyWorkReturnEntity *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfMaterialBatchResultInfo:
		soap_serialize_PointerTons1__ArrayOfMaterialBatchResultInfo(soap, (ns1__ArrayOfMaterialBatchResultInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfDefectResultInfo:
		soap_serialize_PointerTons1__ArrayOfDefectResultInfo(soap, (ns1__ArrayOfDefectResultInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfSubmitResult:
		soap_serialize_PointerTons1__ArrayOfSubmitResult(soap, (ns1__ArrayOfSubmitResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__FIDailyWorkReturnEntity:
		soap_serialize_PointerTons1__FIDailyWorkReturnEntity(soap, (ns1__FIDailyWorkReturnEntity *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MaterialBatchResultInfo:
		soap_serialize_PointerTons1__MaterialBatchResultInfo(soap, (ns1__MaterialBatchResultInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DefectResultInfo:
		soap_serialize_PointerTons1__DefectResultInfo(soap, (ns1__DefectResultInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubmitResult:
		soap_serialize_PointerTons1__SubmitResult(soap, (ns1__SubmitResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SubmitResult_ResultTable:
		soap_serialize_PointerTo_ns1__SubmitResult_ResultTable(soap, (_ns1__SubmitResult_ResultTable *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SubmitResult_ResultTable:
		return (void*)soap_instantiate__ns1__SubmitResult_ResultTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubmitResult:
		return (void*)soap_instantiate_ns1__SubmitResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfSubmitResult:
		return (void*)soap_instantiate_ns1__ArrayOfSubmitResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfDefectResultInfo:
		return (void*)soap_instantiate_ns1__ArrayOfDefectResultInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DefectResultInfo:
		return (void*)soap_instantiate_ns1__DefectResultInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo:
		return (void*)soap_instantiate_ns1__ArrayOfMaterialBatchResultInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MaterialBatchResultInfo:
		return (void*)soap_instantiate_ns1__MaterialBatchResultInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity:
		return (void*)soap_instantiate_ns1__ArrayOfFIDailyWorkReturnEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__FIDailyWorkReturnEntity:
		return (void*)soap_instantiate_ns1__FIDailyWorkReturnEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetWorkCenterID:
		return (void*)soap_instantiate__ns1__GetWorkCenterID(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetWorkCenterIDResponse:
		return (void*)soap_instantiate__ns1__GetWorkCenterIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetCurrentSpecBySn:
		return (void*)soap_instantiate__ns1__GetCurrentSpecBySn(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetCurrentSpecBySnResponse:
		return (void*)soap_instantiate__ns1__GetCurrentSpecBySnResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__IV_USCOREDataCollection:
		return (void*)soap_instantiate__ns1__IV_USCOREDataCollection(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse:
		return (void*)soap_instantiate__ns1__IV_USCOREDataCollectionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan:
		return (void*)soap_instantiate__ns1__jKoIVMoveStd_USCOREPasan(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse:
		return (void*)soap_instantiate__ns1__jKoIVMoveStd_USCOREPasanResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire:
		return (void*)soap_instantiate__ns1__jKoIVMoveStd_USCORESpire(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse:
		return (void*)soap_instantiate__ns1__jKoIVMoveStd_USCORESpireResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ELPictureAddress:
		return (void*)soap_instantiate__ns1__ELPictureAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ELPictureAddressResponse:
		return (void*)soap_instantiate__ns1__ELPictureAddressResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ELInfoMoveStd:
		return (void*)soap_instantiate__ns1__ELInfoMoveStd(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ELInfoMoveStdResponse:
		return (void*)soap_instantiate__ns1__ELInfoMoveStdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SafetyInfoMoveStd:
		return (void*)soap_instantiate__ns1__SafetyInfoMoveStd(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SafetyInfoMoveStdResponse:
		return (void*)soap_instantiate__ns1__SafetyInfoMoveStdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UploadTensileInfoToMes:
		return (void*)soap_instantiate__ns1__UploadTensileInfoToMes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UploadTensileInfoToMesResponse:
		return (void*)soap_instantiate__ns1__UploadTensileInfoToMesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetContainerDataInfoMES:
		return (void*)soap_instantiate__ns1__GetContainerDataInfoMES(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetContainerDataInfoMESResponse:
		return (void*)soap_instantiate__ns1__GetContainerDataInfoMESResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTensileTestRule:
		return (void*)soap_instantiate__ns1__GetTensileTestRule(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetTensileTestRuleResponse:
		return (void*)soap_instantiate__ns1__GetTensileTestRuleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Iscalibrationcontainer:
		return (void*)soap_instantiate__ns1__Iscalibrationcontainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__IscalibrationcontainerResponse:
		return (void*)soap_instantiate__ns1__IscalibrationcontainerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetFtpAddress:
		return (void*)soap_instantiate__ns1__GetFtpAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetFtpAddressResponse:
		return (void*)soap_instantiate__ns1__GetFtpAddressResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDefectInfoToSAP:
		return (void*)soap_instantiate__ns1__GetDefectInfoToSAP(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetDefectInfoToSAPResponse:
		return (void*)soap_instantiate__ns1__GetDefectInfoToSAPResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetDefectResultToMES:
		return (void*)soap_instantiate__ns1__SetDefectResultToMES(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetDefectResultToMESResponse:
		return (void*)soap_instantiate__ns1__SetDefectResultToMESResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetMaterialBatchResultToMES:
		return (void*)soap_instantiate__ns1__SetMaterialBatchResultToMES(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse:
		return (void*)soap_instantiate__ns1__SetMaterialBatchResultToMESResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs:
		return (void*)soap_instantiate__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse:
		return (void*)soap_instantiate__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CanLogin:
		return (void*)soap_instantiate__ns1__CanLogin(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CanLoginResponse:
		return (void*)soap_instantiate__ns1__CanLoginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Login:
		return (void*)soap_instantiate__ns1__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LoginResponse:
		return (void*)soap_instantiate__ns1__LoginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetWorkCenterID:
		return (void*)soap_instantiate___ns1__GetWorkCenterID(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetCurrentSpecBySn:
		return (void*)soap_instantiate___ns1__GetCurrentSpecBySn(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__IV_USCOREDataCollection:
		return (void*)soap_instantiate___ns1__IV_USCOREDataCollection(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan:
		return (void*)soap_instantiate___ns1__jKoIVMoveStd_USCOREPasan(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire:
		return (void*)soap_instantiate___ns1__jKoIVMoveStd_USCORESpire(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ELPictureAddress:
		return (void*)soap_instantiate___ns1__ELPictureAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ELInfoMoveStd:
		return (void*)soap_instantiate___ns1__ELInfoMoveStd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SafetyInfoMoveStd:
		return (void*)soap_instantiate___ns1__SafetyInfoMoveStd(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadTensileInfoToMes:
		return (void*)soap_instantiate___ns1__UploadTensileInfoToMes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetContainerDataInfoMES:
		return (void*)soap_instantiate___ns1__GetContainerDataInfoMES(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetTensileTestRule:
		return (void*)soap_instantiate___ns1__GetTensileTestRule(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Iscalibrationcontainer:
		return (void*)soap_instantiate___ns1__Iscalibrationcontainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetFtpAddress:
		return (void*)soap_instantiate___ns1__GetFtpAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDefectInfoToSAP:
		return (void*)soap_instantiate___ns1__GetDefectInfoToSAP(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetDefectResultToMES:
		return (void*)soap_instantiate___ns1__SetDefectResultToMES(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetMaterialBatchResultToMES:
		return (void*)soap_instantiate___ns1__SetMaterialBatchResultToMES(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs:
		return (void*)soap_instantiate___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CanLogin:
		return (void*)soap_instantiate___ns1__CanLogin(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Login:
		return (void*)soap_instantiate___ns1__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetWorkCenterID_:
		return (void*)soap_instantiate___ns1__GetWorkCenterID_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetCurrentSpecBySn_:
		return (void*)soap_instantiate___ns1__GetCurrentSpecBySn_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__IV_USCOREDataCollection_:
		return (void*)soap_instantiate___ns1__IV_USCOREDataCollection_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan_:
		return (void*)soap_instantiate___ns1__jKoIVMoveStd_USCOREPasan_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire_:
		return (void*)soap_instantiate___ns1__jKoIVMoveStd_USCORESpire_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ELPictureAddress_:
		return (void*)soap_instantiate___ns1__ELPictureAddress_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ELInfoMoveStd_:
		return (void*)soap_instantiate___ns1__ELInfoMoveStd_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SafetyInfoMoveStd_:
		return (void*)soap_instantiate___ns1__SafetyInfoMoveStd_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadTensileInfoToMes_:
		return (void*)soap_instantiate___ns1__UploadTensileInfoToMes_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetContainerDataInfoMES_:
		return (void*)soap_instantiate___ns1__GetContainerDataInfoMES_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetTensileTestRule_:
		return (void*)soap_instantiate___ns1__GetTensileTestRule_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Iscalibrationcontainer_:
		return (void*)soap_instantiate___ns1__Iscalibrationcontainer_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetFtpAddress_:
		return (void*)soap_instantiate___ns1__GetFtpAddress_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetDefectInfoToSAP_:
		return (void*)soap_instantiate___ns1__GetDefectInfoToSAP_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetDefectResultToMES_:
		return (void*)soap_instantiate___ns1__SetDefectResultToMES_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SetMaterialBatchResultToMES_:
		return (void*)soap_instantiate___ns1__SetMaterialBatchResultToMES_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_:
		return (void*)soap_instantiate___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CanLogin_:
		return (void*)soap_instantiate___ns1__CanLogin_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Login_:
		return (void*)soap_instantiate___ns1__Login_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DefectResultInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__DefectResultInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubmitResult:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SubmitResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE__ns1__SubmitResult_ResultTable:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SubmitResult_ResultTable*>(p->ptr), _ns1__SubmitResult_ResultTable);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SubmitResult_ResultTable*>(p->ptr), _ns1__SubmitResult_ResultTable);
		break;
	case SOAP_TYPE_ns1__SubmitResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__SubmitResult*>(p->ptr), ns1__SubmitResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__SubmitResult*>(p->ptr), ns1__SubmitResult);
		break;
	case SOAP_TYPE_ns1__ArrayOfSubmitResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfSubmitResult*>(p->ptr), ns1__ArrayOfSubmitResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfSubmitResult*>(p->ptr), ns1__ArrayOfSubmitResult);
		break;
	case SOAP_TYPE_ns1__ArrayOfDefectResultInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfDefectResultInfo*>(p->ptr), ns1__ArrayOfDefectResultInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfDefectResultInfo*>(p->ptr), ns1__ArrayOfDefectResultInfo);
		break;
	case SOAP_TYPE_ns1__DefectResultInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__DefectResultInfo*>(p->ptr), ns1__DefectResultInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__DefectResultInfo*>(p->ptr), ns1__DefectResultInfo);
		break;
	case SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfMaterialBatchResultInfo*>(p->ptr), ns1__ArrayOfMaterialBatchResultInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfMaterialBatchResultInfo*>(p->ptr), ns1__ArrayOfMaterialBatchResultInfo);
		break;
	case SOAP_TYPE_ns1__MaterialBatchResultInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__MaterialBatchResultInfo*>(p->ptr), ns1__MaterialBatchResultInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__MaterialBatchResultInfo*>(p->ptr), ns1__MaterialBatchResultInfo);
		break;
	case SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ArrayOfFIDailyWorkReturnEntity*>(p->ptr), ns1__ArrayOfFIDailyWorkReturnEntity);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ArrayOfFIDailyWorkReturnEntity*>(p->ptr), ns1__ArrayOfFIDailyWorkReturnEntity);
		break;
	case SOAP_TYPE_ns1__FIDailyWorkReturnEntity:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__FIDailyWorkReturnEntity*>(p->ptr), ns1__FIDailyWorkReturnEntity);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__FIDailyWorkReturnEntity*>(p->ptr), ns1__FIDailyWorkReturnEntity);
		break;
	case SOAP_TYPE__ns1__GetWorkCenterID:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetWorkCenterID*>(p->ptr), _ns1__GetWorkCenterID);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetWorkCenterID*>(p->ptr), _ns1__GetWorkCenterID);
		break;
	case SOAP_TYPE__ns1__GetWorkCenterIDResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetWorkCenterIDResponse*>(p->ptr), _ns1__GetWorkCenterIDResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetWorkCenterIDResponse*>(p->ptr), _ns1__GetWorkCenterIDResponse);
		break;
	case SOAP_TYPE__ns1__GetCurrentSpecBySn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetCurrentSpecBySn*>(p->ptr), _ns1__GetCurrentSpecBySn);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetCurrentSpecBySn*>(p->ptr), _ns1__GetCurrentSpecBySn);
		break;
	case SOAP_TYPE__ns1__GetCurrentSpecBySnResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetCurrentSpecBySnResponse*>(p->ptr), _ns1__GetCurrentSpecBySnResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetCurrentSpecBySnResponse*>(p->ptr), _ns1__GetCurrentSpecBySnResponse);
		break;
	case SOAP_TYPE__ns1__IV_USCOREDataCollection:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__IV_USCOREDataCollection*>(p->ptr), _ns1__IV_USCOREDataCollection);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__IV_USCOREDataCollection*>(p->ptr), _ns1__IV_USCOREDataCollection);
		break;
	case SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__IV_USCOREDataCollectionResponse*>(p->ptr), _ns1__IV_USCOREDataCollectionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__IV_USCOREDataCollectionResponse*>(p->ptr), _ns1__IV_USCOREDataCollectionResponse);
		break;
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__jKoIVMoveStd_USCOREPasan*>(p->ptr), _ns1__jKoIVMoveStd_USCOREPasan);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__jKoIVMoveStd_USCOREPasan*>(p->ptr), _ns1__jKoIVMoveStd_USCOREPasan);
		break;
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__jKoIVMoveStd_USCOREPasanResponse*>(p->ptr), _ns1__jKoIVMoveStd_USCOREPasanResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__jKoIVMoveStd_USCOREPasanResponse*>(p->ptr), _ns1__jKoIVMoveStd_USCOREPasanResponse);
		break;
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__jKoIVMoveStd_USCORESpire*>(p->ptr), _ns1__jKoIVMoveStd_USCORESpire);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__jKoIVMoveStd_USCORESpire*>(p->ptr), _ns1__jKoIVMoveStd_USCORESpire);
		break;
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__jKoIVMoveStd_USCORESpireResponse*>(p->ptr), _ns1__jKoIVMoveStd_USCORESpireResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__jKoIVMoveStd_USCORESpireResponse*>(p->ptr), _ns1__jKoIVMoveStd_USCORESpireResponse);
		break;
	case SOAP_TYPE__ns1__ELPictureAddress:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ELPictureAddress*>(p->ptr), _ns1__ELPictureAddress);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ELPictureAddress*>(p->ptr), _ns1__ELPictureAddress);
		break;
	case SOAP_TYPE__ns1__ELPictureAddressResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ELPictureAddressResponse*>(p->ptr), _ns1__ELPictureAddressResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ELPictureAddressResponse*>(p->ptr), _ns1__ELPictureAddressResponse);
		break;
	case SOAP_TYPE__ns1__ELInfoMoveStd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ELInfoMoveStd*>(p->ptr), _ns1__ELInfoMoveStd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ELInfoMoveStd*>(p->ptr), _ns1__ELInfoMoveStd);
		break;
	case SOAP_TYPE__ns1__ELInfoMoveStdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__ELInfoMoveStdResponse*>(p->ptr), _ns1__ELInfoMoveStdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__ELInfoMoveStdResponse*>(p->ptr), _ns1__ELInfoMoveStdResponse);
		break;
	case SOAP_TYPE__ns1__SafetyInfoMoveStd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SafetyInfoMoveStd*>(p->ptr), _ns1__SafetyInfoMoveStd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SafetyInfoMoveStd*>(p->ptr), _ns1__SafetyInfoMoveStd);
		break;
	case SOAP_TYPE__ns1__SafetyInfoMoveStdResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SafetyInfoMoveStdResponse*>(p->ptr), _ns1__SafetyInfoMoveStdResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SafetyInfoMoveStdResponse*>(p->ptr), _ns1__SafetyInfoMoveStdResponse);
		break;
	case SOAP_TYPE__ns1__UploadTensileInfoToMes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__UploadTensileInfoToMes*>(p->ptr), _ns1__UploadTensileInfoToMes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__UploadTensileInfoToMes*>(p->ptr), _ns1__UploadTensileInfoToMes);
		break;
	case SOAP_TYPE__ns1__UploadTensileInfoToMesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__UploadTensileInfoToMesResponse*>(p->ptr), _ns1__UploadTensileInfoToMesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__UploadTensileInfoToMesResponse*>(p->ptr), _ns1__UploadTensileInfoToMesResponse);
		break;
	case SOAP_TYPE__ns1__GetContainerDataInfoMES:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetContainerDataInfoMES*>(p->ptr), _ns1__GetContainerDataInfoMES);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetContainerDataInfoMES*>(p->ptr), _ns1__GetContainerDataInfoMES);
		break;
	case SOAP_TYPE__ns1__GetContainerDataInfoMESResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetContainerDataInfoMESResponse*>(p->ptr), _ns1__GetContainerDataInfoMESResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetContainerDataInfoMESResponse*>(p->ptr), _ns1__GetContainerDataInfoMESResponse);
		break;
	case SOAP_TYPE__ns1__GetTensileTestRule:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetTensileTestRule*>(p->ptr), _ns1__GetTensileTestRule);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetTensileTestRule*>(p->ptr), _ns1__GetTensileTestRule);
		break;
	case SOAP_TYPE__ns1__GetTensileTestRuleResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetTensileTestRuleResponse*>(p->ptr), _ns1__GetTensileTestRuleResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetTensileTestRuleResponse*>(p->ptr), _ns1__GetTensileTestRuleResponse);
		break;
	case SOAP_TYPE__ns1__Iscalibrationcontainer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Iscalibrationcontainer*>(p->ptr), _ns1__Iscalibrationcontainer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Iscalibrationcontainer*>(p->ptr), _ns1__Iscalibrationcontainer);
		break;
	case SOAP_TYPE__ns1__IscalibrationcontainerResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__IscalibrationcontainerResponse*>(p->ptr), _ns1__IscalibrationcontainerResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__IscalibrationcontainerResponse*>(p->ptr), _ns1__IscalibrationcontainerResponse);
		break;
	case SOAP_TYPE__ns1__GetFtpAddress:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetFtpAddress*>(p->ptr), _ns1__GetFtpAddress);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetFtpAddress*>(p->ptr), _ns1__GetFtpAddress);
		break;
	case SOAP_TYPE__ns1__GetFtpAddressResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetFtpAddressResponse*>(p->ptr), _ns1__GetFtpAddressResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetFtpAddressResponse*>(p->ptr), _ns1__GetFtpAddressResponse);
		break;
	case SOAP_TYPE__ns1__GetDefectInfoToSAP:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDefectInfoToSAP*>(p->ptr), _ns1__GetDefectInfoToSAP);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDefectInfoToSAP*>(p->ptr), _ns1__GetDefectInfoToSAP);
		break;
	case SOAP_TYPE__ns1__GetDefectInfoToSAPResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__GetDefectInfoToSAPResponse*>(p->ptr), _ns1__GetDefectInfoToSAPResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__GetDefectInfoToSAPResponse*>(p->ptr), _ns1__GetDefectInfoToSAPResponse);
		break;
	case SOAP_TYPE__ns1__SetDefectResultToMES:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SetDefectResultToMES*>(p->ptr), _ns1__SetDefectResultToMES);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SetDefectResultToMES*>(p->ptr), _ns1__SetDefectResultToMES);
		break;
	case SOAP_TYPE__ns1__SetDefectResultToMESResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SetDefectResultToMESResponse*>(p->ptr), _ns1__SetDefectResultToMESResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SetDefectResultToMESResponse*>(p->ptr), _ns1__SetDefectResultToMESResponse);
		break;
	case SOAP_TYPE__ns1__SetMaterialBatchResultToMES:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SetMaterialBatchResultToMES*>(p->ptr), _ns1__SetMaterialBatchResultToMES);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SetMaterialBatchResultToMES*>(p->ptr), _ns1__SetMaterialBatchResultToMES);
		break;
	case SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__SetMaterialBatchResultToMESResponse*>(p->ptr), _ns1__SetMaterialBatchResultToMESResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__SetMaterialBatchResultToMESResponse*>(p->ptr), _ns1__SetMaterialBatchResultToMESResponse);
		break;
	case SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs*>(p->ptr), _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs*>(p->ptr), _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs);
		break;
	case SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse*>(p->ptr), _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse*>(p->ptr), _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse);
		break;
	case SOAP_TYPE__ns1__CanLogin:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CanLogin*>(p->ptr), _ns1__CanLogin);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CanLogin*>(p->ptr), _ns1__CanLogin);
		break;
	case SOAP_TYPE__ns1__CanLoginResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__CanLoginResponse*>(p->ptr), _ns1__CanLoginResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__CanLoginResponse*>(p->ptr), _ns1__CanLoginResponse);
		break;
	case SOAP_TYPE__ns1__Login:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__Login*>(p->ptr), _ns1__Login);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__Login*>(p->ptr), _ns1__Login);
		break;
	case SOAP_TYPE__ns1__LoginResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_ns1__LoginResponse*>(p->ptr), _ns1__LoginResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_ns1__LoginResponse*>(p->ptr), _ns1__LoginResponse);
		break;
	case SOAP_TYPE___ns1__GetWorkCenterID:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetWorkCenterID*>(p->ptr), struct __ns1__GetWorkCenterID);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetWorkCenterID*>(p->ptr), struct __ns1__GetWorkCenterID);
		break;
	case SOAP_TYPE___ns1__GetCurrentSpecBySn:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetCurrentSpecBySn*>(p->ptr), struct __ns1__GetCurrentSpecBySn);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetCurrentSpecBySn*>(p->ptr), struct __ns1__GetCurrentSpecBySn);
		break;
	case SOAP_TYPE___ns1__IV_USCOREDataCollection:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__IV_USCOREDataCollection*>(p->ptr), struct __ns1__IV_USCOREDataCollection);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__IV_USCOREDataCollection*>(p->ptr), struct __ns1__IV_USCOREDataCollection);
		break;
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__jKoIVMoveStd_USCOREPasan*>(p->ptr), struct __ns1__jKoIVMoveStd_USCOREPasan);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__jKoIVMoveStd_USCOREPasan*>(p->ptr), struct __ns1__jKoIVMoveStd_USCOREPasan);
		break;
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__jKoIVMoveStd_USCORESpire*>(p->ptr), struct __ns1__jKoIVMoveStd_USCORESpire);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__jKoIVMoveStd_USCORESpire*>(p->ptr), struct __ns1__jKoIVMoveStd_USCORESpire);
		break;
	case SOAP_TYPE___ns1__ELPictureAddress:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ELPictureAddress*>(p->ptr), struct __ns1__ELPictureAddress);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ELPictureAddress*>(p->ptr), struct __ns1__ELPictureAddress);
		break;
	case SOAP_TYPE___ns1__ELInfoMoveStd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ELInfoMoveStd*>(p->ptr), struct __ns1__ELInfoMoveStd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ELInfoMoveStd*>(p->ptr), struct __ns1__ELInfoMoveStd);
		break;
	case SOAP_TYPE___ns1__SafetyInfoMoveStd:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SafetyInfoMoveStd*>(p->ptr), struct __ns1__SafetyInfoMoveStd);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SafetyInfoMoveStd*>(p->ptr), struct __ns1__SafetyInfoMoveStd);
		break;
	case SOAP_TYPE___ns1__UploadTensileInfoToMes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__UploadTensileInfoToMes*>(p->ptr), struct __ns1__UploadTensileInfoToMes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__UploadTensileInfoToMes*>(p->ptr), struct __ns1__UploadTensileInfoToMes);
		break;
	case SOAP_TYPE___ns1__GetContainerDataInfoMES:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetContainerDataInfoMES*>(p->ptr), struct __ns1__GetContainerDataInfoMES);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetContainerDataInfoMES*>(p->ptr), struct __ns1__GetContainerDataInfoMES);
		break;
	case SOAP_TYPE___ns1__GetTensileTestRule:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetTensileTestRule*>(p->ptr), struct __ns1__GetTensileTestRule);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetTensileTestRule*>(p->ptr), struct __ns1__GetTensileTestRule);
		break;
	case SOAP_TYPE___ns1__Iscalibrationcontainer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Iscalibrationcontainer*>(p->ptr), struct __ns1__Iscalibrationcontainer);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Iscalibrationcontainer*>(p->ptr), struct __ns1__Iscalibrationcontainer);
		break;
	case SOAP_TYPE___ns1__GetFtpAddress:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetFtpAddress*>(p->ptr), struct __ns1__GetFtpAddress);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetFtpAddress*>(p->ptr), struct __ns1__GetFtpAddress);
		break;
	case SOAP_TYPE___ns1__GetDefectInfoToSAP:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDefectInfoToSAP*>(p->ptr), struct __ns1__GetDefectInfoToSAP);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDefectInfoToSAP*>(p->ptr), struct __ns1__GetDefectInfoToSAP);
		break;
	case SOAP_TYPE___ns1__SetDefectResultToMES:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SetDefectResultToMES*>(p->ptr), struct __ns1__SetDefectResultToMES);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SetDefectResultToMES*>(p->ptr), struct __ns1__SetDefectResultToMES);
		break;
	case SOAP_TYPE___ns1__SetMaterialBatchResultToMES:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SetMaterialBatchResultToMES*>(p->ptr), struct __ns1__SetMaterialBatchResultToMES);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SetMaterialBatchResultToMES*>(p->ptr), struct __ns1__SetMaterialBatchResultToMES);
		break;
	case SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs*>(p->ptr), struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs*>(p->ptr), struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs);
		break;
	case SOAP_TYPE___ns1__CanLogin:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CanLogin*>(p->ptr), struct __ns1__CanLogin);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CanLogin*>(p->ptr), struct __ns1__CanLogin);
		break;
	case SOAP_TYPE___ns1__Login:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Login*>(p->ptr), struct __ns1__Login);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Login*>(p->ptr), struct __ns1__Login);
		break;
	case SOAP_TYPE___ns1__GetWorkCenterID_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetWorkCenterID_*>(p->ptr), struct __ns1__GetWorkCenterID_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetWorkCenterID_*>(p->ptr), struct __ns1__GetWorkCenterID_);
		break;
	case SOAP_TYPE___ns1__GetCurrentSpecBySn_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetCurrentSpecBySn_*>(p->ptr), struct __ns1__GetCurrentSpecBySn_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetCurrentSpecBySn_*>(p->ptr), struct __ns1__GetCurrentSpecBySn_);
		break;
	case SOAP_TYPE___ns1__IV_USCOREDataCollection_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__IV_USCOREDataCollection_*>(p->ptr), struct __ns1__IV_USCOREDataCollection_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__IV_USCOREDataCollection_*>(p->ptr), struct __ns1__IV_USCOREDataCollection_);
		break;
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__jKoIVMoveStd_USCOREPasan_*>(p->ptr), struct __ns1__jKoIVMoveStd_USCOREPasan_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__jKoIVMoveStd_USCOREPasan_*>(p->ptr), struct __ns1__jKoIVMoveStd_USCOREPasan_);
		break;
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__jKoIVMoveStd_USCORESpire_*>(p->ptr), struct __ns1__jKoIVMoveStd_USCORESpire_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__jKoIVMoveStd_USCORESpire_*>(p->ptr), struct __ns1__jKoIVMoveStd_USCORESpire_);
		break;
	case SOAP_TYPE___ns1__ELPictureAddress_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ELPictureAddress_*>(p->ptr), struct __ns1__ELPictureAddress_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ELPictureAddress_*>(p->ptr), struct __ns1__ELPictureAddress_);
		break;
	case SOAP_TYPE___ns1__ELInfoMoveStd_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__ELInfoMoveStd_*>(p->ptr), struct __ns1__ELInfoMoveStd_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__ELInfoMoveStd_*>(p->ptr), struct __ns1__ELInfoMoveStd_);
		break;
	case SOAP_TYPE___ns1__SafetyInfoMoveStd_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SafetyInfoMoveStd_*>(p->ptr), struct __ns1__SafetyInfoMoveStd_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SafetyInfoMoveStd_*>(p->ptr), struct __ns1__SafetyInfoMoveStd_);
		break;
	case SOAP_TYPE___ns1__UploadTensileInfoToMes_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__UploadTensileInfoToMes_*>(p->ptr), struct __ns1__UploadTensileInfoToMes_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__UploadTensileInfoToMes_*>(p->ptr), struct __ns1__UploadTensileInfoToMes_);
		break;
	case SOAP_TYPE___ns1__GetContainerDataInfoMES_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetContainerDataInfoMES_*>(p->ptr), struct __ns1__GetContainerDataInfoMES_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetContainerDataInfoMES_*>(p->ptr), struct __ns1__GetContainerDataInfoMES_);
		break;
	case SOAP_TYPE___ns1__GetTensileTestRule_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetTensileTestRule_*>(p->ptr), struct __ns1__GetTensileTestRule_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetTensileTestRule_*>(p->ptr), struct __ns1__GetTensileTestRule_);
		break;
	case SOAP_TYPE___ns1__Iscalibrationcontainer_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Iscalibrationcontainer_*>(p->ptr), struct __ns1__Iscalibrationcontainer_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Iscalibrationcontainer_*>(p->ptr), struct __ns1__Iscalibrationcontainer_);
		break;
	case SOAP_TYPE___ns1__GetFtpAddress_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetFtpAddress_*>(p->ptr), struct __ns1__GetFtpAddress_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetFtpAddress_*>(p->ptr), struct __ns1__GetFtpAddress_);
		break;
	case SOAP_TYPE___ns1__GetDefectInfoToSAP_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__GetDefectInfoToSAP_*>(p->ptr), struct __ns1__GetDefectInfoToSAP_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__GetDefectInfoToSAP_*>(p->ptr), struct __ns1__GetDefectInfoToSAP_);
		break;
	case SOAP_TYPE___ns1__SetDefectResultToMES_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SetDefectResultToMES_*>(p->ptr), struct __ns1__SetDefectResultToMES_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SetDefectResultToMES_*>(p->ptr), struct __ns1__SetDefectResultToMES_);
		break;
	case SOAP_TYPE___ns1__SetMaterialBatchResultToMES_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__SetMaterialBatchResultToMES_*>(p->ptr), struct __ns1__SetMaterialBatchResultToMES_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__SetMaterialBatchResultToMES_*>(p->ptr), struct __ns1__SetMaterialBatchResultToMES_);
		break;
	case SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_*>(p->ptr), struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_*>(p->ptr), struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_);
		break;
	case SOAP_TYPE___ns1__CanLogin_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__CanLogin_*>(p->ptr), struct __ns1__CanLogin_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__CanLogin_*>(p->ptr), struct __ns1__CanLogin_);
		break;
	case SOAP_TYPE___ns1__Login_:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __ns1__Login_*>(p->ptr), struct __ns1__Login_);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __ns1__Login_*>(p->ptr), struct __ns1__Login_);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__FIDailyWorkReturnEntity *> *>(p->ptr), std::vector<ns1__FIDailyWorkReturnEntity *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__FIDailyWorkReturnEntity *> *>(p->ptr), std::vector<ns1__FIDailyWorkReturnEntity *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__MaterialBatchResultInfo *> *>(p->ptr), std::vector<ns1__MaterialBatchResultInfo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__MaterialBatchResultInfo *> *>(p->ptr), std::vector<ns1__MaterialBatchResultInfo *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DefectResultInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__DefectResultInfo *> *>(p->ptr), std::vector<ns1__DefectResultInfo *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__DefectResultInfo *> *>(p->ptr), std::vector<ns1__DefectResultInfo *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubmitResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<ns1__SubmitResult *> *>(p->ptr), std::vector<ns1__SubmitResult *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<ns1__SubmitResult *> *>(p->ptr), std::vector<ns1__SubmitResult *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<char *> *>(p->ptr), std::vector<char *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<char *> *>(p->ptr), std::vector<char *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity:
		if (t == SOAP_TYPE_ns1__FIDailyWorkReturnEntity || soap_fbase(t, SOAP_TYPE_ns1__FIDailyWorkReturnEntity))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__FIDailyWorkReturnEntity *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__FIDailyWorkReturnEntity *> *)p)[index] = *(ns1__FIDailyWorkReturnEntity **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo:
		if (t == SOAP_TYPE_ns1__MaterialBatchResultInfo || soap_fbase(t, SOAP_TYPE_ns1__MaterialBatchResultInfo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__MaterialBatchResultInfo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__MaterialBatchResultInfo *> *)p)[index] = *(ns1__MaterialBatchResultInfo **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DefectResultInfo:
		if (t == SOAP_TYPE_ns1__DefectResultInfo || soap_fbase(t, SOAP_TYPE_ns1__DefectResultInfo))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__DefectResultInfo *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__DefectResultInfo *> *)p)[index] = *(ns1__DefectResultInfo **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubmitResult:
		if (t == SOAP_TYPE_ns1__SubmitResult || soap_fbase(t, SOAP_TYPE_ns1__SubmitResult))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__SubmitResult *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__SubmitResult *> *)p)[index] = *(ns1__SubmitResult **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (t == SOAP_TYPE__XML)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<char *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<char *> *)p)[index] = *(char **)q;
		}
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__ns1__SubmitResult_ResultTable:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SubmitResult_ResultTable type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SubmitResult_ResultTable*)p = *(_ns1__SubmitResult_ResultTable*)q;
		break;
	case SOAP_TYPE_ns1__SubmitResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__SubmitResult type=%d location=%p object=%p\n", t, p, q));
		*(ns1__SubmitResult*)p = *(ns1__SubmitResult*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfSubmitResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfSubmitResult type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfSubmitResult*)p = *(ns1__ArrayOfSubmitResult*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfDefectResultInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfDefectResultInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfDefectResultInfo*)p = *(ns1__ArrayOfDefectResultInfo*)q;
		break;
	case SOAP_TYPE_ns1__DefectResultInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__DefectResultInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__DefectResultInfo*)p = *(ns1__DefectResultInfo*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfMaterialBatchResultInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfMaterialBatchResultInfo*)p = *(ns1__ArrayOfMaterialBatchResultInfo*)q;
		break;
	case SOAP_TYPE_ns1__MaterialBatchResultInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__MaterialBatchResultInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__MaterialBatchResultInfo*)p = *(ns1__MaterialBatchResultInfo*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfFIDailyWorkReturnEntity type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfFIDailyWorkReturnEntity*)p = *(ns1__ArrayOfFIDailyWorkReturnEntity*)q;
		break;
	case SOAP_TYPE_ns1__FIDailyWorkReturnEntity:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__FIDailyWorkReturnEntity type=%d location=%p object=%p\n", t, p, q));
		*(ns1__FIDailyWorkReturnEntity*)p = *(ns1__FIDailyWorkReturnEntity*)q;
		break;
	case SOAP_TYPE__ns1__GetWorkCenterID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetWorkCenterID type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetWorkCenterID*)p = *(_ns1__GetWorkCenterID*)q;
		break;
	case SOAP_TYPE__ns1__GetWorkCenterIDResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetWorkCenterIDResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetWorkCenterIDResponse*)p = *(_ns1__GetWorkCenterIDResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetCurrentSpecBySn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetCurrentSpecBySn type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetCurrentSpecBySn*)p = *(_ns1__GetCurrentSpecBySn*)q;
		break;
	case SOAP_TYPE__ns1__GetCurrentSpecBySnResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetCurrentSpecBySnResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetCurrentSpecBySnResponse*)p = *(_ns1__GetCurrentSpecBySnResponse*)q;
		break;
	case SOAP_TYPE__ns1__IV_USCOREDataCollection:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__IV_USCOREDataCollection type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__IV_USCOREDataCollection*)p = *(_ns1__IV_USCOREDataCollection*)q;
		break;
	case SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__IV_USCOREDataCollectionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__IV_USCOREDataCollectionResponse*)p = *(_ns1__IV_USCOREDataCollectionResponse*)q;
		break;
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__jKoIVMoveStd_USCOREPasan type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__jKoIVMoveStd_USCOREPasan*)p = *(_ns1__jKoIVMoveStd_USCOREPasan*)q;
		break;
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__jKoIVMoveStd_USCOREPasanResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__jKoIVMoveStd_USCOREPasanResponse*)p = *(_ns1__jKoIVMoveStd_USCOREPasanResponse*)q;
		break;
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__jKoIVMoveStd_USCORESpire type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__jKoIVMoveStd_USCORESpire*)p = *(_ns1__jKoIVMoveStd_USCORESpire*)q;
		break;
	case SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__jKoIVMoveStd_USCORESpireResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__jKoIVMoveStd_USCORESpireResponse*)p = *(_ns1__jKoIVMoveStd_USCORESpireResponse*)q;
		break;
	case SOAP_TYPE__ns1__ELPictureAddress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ELPictureAddress type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ELPictureAddress*)p = *(_ns1__ELPictureAddress*)q;
		break;
	case SOAP_TYPE__ns1__ELPictureAddressResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ELPictureAddressResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ELPictureAddressResponse*)p = *(_ns1__ELPictureAddressResponse*)q;
		break;
	case SOAP_TYPE__ns1__ELInfoMoveStd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ELInfoMoveStd type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ELInfoMoveStd*)p = *(_ns1__ELInfoMoveStd*)q;
		break;
	case SOAP_TYPE__ns1__ELInfoMoveStdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ELInfoMoveStdResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ELInfoMoveStdResponse*)p = *(_ns1__ELInfoMoveStdResponse*)q;
		break;
	case SOAP_TYPE__ns1__SafetyInfoMoveStd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SafetyInfoMoveStd type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SafetyInfoMoveStd*)p = *(_ns1__SafetyInfoMoveStd*)q;
		break;
	case SOAP_TYPE__ns1__SafetyInfoMoveStdResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SafetyInfoMoveStdResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SafetyInfoMoveStdResponse*)p = *(_ns1__SafetyInfoMoveStdResponse*)q;
		break;
	case SOAP_TYPE__ns1__UploadTensileInfoToMes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UploadTensileInfoToMes type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UploadTensileInfoToMes*)p = *(_ns1__UploadTensileInfoToMes*)q;
		break;
	case SOAP_TYPE__ns1__UploadTensileInfoToMesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__UploadTensileInfoToMesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__UploadTensileInfoToMesResponse*)p = *(_ns1__UploadTensileInfoToMesResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetContainerDataInfoMES:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetContainerDataInfoMES type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetContainerDataInfoMES*)p = *(_ns1__GetContainerDataInfoMES*)q;
		break;
	case SOAP_TYPE__ns1__GetContainerDataInfoMESResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetContainerDataInfoMESResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetContainerDataInfoMESResponse*)p = *(_ns1__GetContainerDataInfoMESResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetTensileTestRule:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetTensileTestRule type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetTensileTestRule*)p = *(_ns1__GetTensileTestRule*)q;
		break;
	case SOAP_TYPE__ns1__GetTensileTestRuleResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetTensileTestRuleResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetTensileTestRuleResponse*)p = *(_ns1__GetTensileTestRuleResponse*)q;
		break;
	case SOAP_TYPE__ns1__Iscalibrationcontainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Iscalibrationcontainer type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Iscalibrationcontainer*)p = *(_ns1__Iscalibrationcontainer*)q;
		break;
	case SOAP_TYPE__ns1__IscalibrationcontainerResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__IscalibrationcontainerResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__IscalibrationcontainerResponse*)p = *(_ns1__IscalibrationcontainerResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetFtpAddress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetFtpAddress type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetFtpAddress*)p = *(_ns1__GetFtpAddress*)q;
		break;
	case SOAP_TYPE__ns1__GetFtpAddressResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetFtpAddressResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetFtpAddressResponse*)p = *(_ns1__GetFtpAddressResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetDefectInfoToSAP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDefectInfoToSAP type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDefectInfoToSAP*)p = *(_ns1__GetDefectInfoToSAP*)q;
		break;
	case SOAP_TYPE__ns1__GetDefectInfoToSAPResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetDefectInfoToSAPResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetDefectInfoToSAPResponse*)p = *(_ns1__GetDefectInfoToSAPResponse*)q;
		break;
	case SOAP_TYPE__ns1__SetDefectResultToMES:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetDefectResultToMES type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetDefectResultToMES*)p = *(_ns1__SetDefectResultToMES*)q;
		break;
	case SOAP_TYPE__ns1__SetDefectResultToMESResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetDefectResultToMESResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetDefectResultToMESResponse*)p = *(_ns1__SetDefectResultToMESResponse*)q;
		break;
	case SOAP_TYPE__ns1__SetMaterialBatchResultToMES:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetMaterialBatchResultToMES type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetMaterialBatchResultToMES*)p = *(_ns1__SetMaterialBatchResultToMES*)q;
		break;
	case SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__SetMaterialBatchResultToMESResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__SetMaterialBatchResultToMESResponse*)p = *(_ns1__SetMaterialBatchResultToMESResponse*)q;
		break;
	case SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs*)p = *(_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs*)q;
		break;
	case SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse*)p = *(_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse*)q;
		break;
	case SOAP_TYPE__ns1__CanLogin:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CanLogin type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CanLogin*)p = *(_ns1__CanLogin*)q;
		break;
	case SOAP_TYPE__ns1__CanLoginResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CanLoginResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CanLoginResponse*)p = *(_ns1__CanLoginResponse*)q;
		break;
	case SOAP_TYPE__ns1__Login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Login type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Login*)p = *(_ns1__Login*)q;
		break;
	case SOAP_TYPE__ns1__LoginResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__LoginResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__LoginResponse*)p = *(_ns1__LoginResponse*)q;
		break;
	case SOAP_TYPE___ns1__GetWorkCenterID:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetWorkCenterID type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetWorkCenterID*)p = *(struct __ns1__GetWorkCenterID*)q;
		break;
	case SOAP_TYPE___ns1__GetCurrentSpecBySn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetCurrentSpecBySn type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetCurrentSpecBySn*)p = *(struct __ns1__GetCurrentSpecBySn*)q;
		break;
	case SOAP_TYPE___ns1__IV_USCOREDataCollection:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__IV_USCOREDataCollection type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__IV_USCOREDataCollection*)p = *(struct __ns1__IV_USCOREDataCollection*)q;
		break;
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__jKoIVMoveStd_USCOREPasan type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__jKoIVMoveStd_USCOREPasan*)p = *(struct __ns1__jKoIVMoveStd_USCOREPasan*)q;
		break;
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__jKoIVMoveStd_USCORESpire type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__jKoIVMoveStd_USCORESpire*)p = *(struct __ns1__jKoIVMoveStd_USCORESpire*)q;
		break;
	case SOAP_TYPE___ns1__ELPictureAddress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ELPictureAddress type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ELPictureAddress*)p = *(struct __ns1__ELPictureAddress*)q;
		break;
	case SOAP_TYPE___ns1__ELInfoMoveStd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ELInfoMoveStd type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ELInfoMoveStd*)p = *(struct __ns1__ELInfoMoveStd*)q;
		break;
	case SOAP_TYPE___ns1__SafetyInfoMoveStd:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SafetyInfoMoveStd type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SafetyInfoMoveStd*)p = *(struct __ns1__SafetyInfoMoveStd*)q;
		break;
	case SOAP_TYPE___ns1__UploadTensileInfoToMes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UploadTensileInfoToMes type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UploadTensileInfoToMes*)p = *(struct __ns1__UploadTensileInfoToMes*)q;
		break;
	case SOAP_TYPE___ns1__GetContainerDataInfoMES:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetContainerDataInfoMES type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetContainerDataInfoMES*)p = *(struct __ns1__GetContainerDataInfoMES*)q;
		break;
	case SOAP_TYPE___ns1__GetTensileTestRule:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetTensileTestRule type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetTensileTestRule*)p = *(struct __ns1__GetTensileTestRule*)q;
		break;
	case SOAP_TYPE___ns1__Iscalibrationcontainer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Iscalibrationcontainer type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Iscalibrationcontainer*)p = *(struct __ns1__Iscalibrationcontainer*)q;
		break;
	case SOAP_TYPE___ns1__GetFtpAddress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetFtpAddress type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetFtpAddress*)p = *(struct __ns1__GetFtpAddress*)q;
		break;
	case SOAP_TYPE___ns1__GetDefectInfoToSAP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDefectInfoToSAP type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDefectInfoToSAP*)p = *(struct __ns1__GetDefectInfoToSAP*)q;
		break;
	case SOAP_TYPE___ns1__SetDefectResultToMES:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SetDefectResultToMES type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SetDefectResultToMES*)p = *(struct __ns1__SetDefectResultToMES*)q;
		break;
	case SOAP_TYPE___ns1__SetMaterialBatchResultToMES:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SetMaterialBatchResultToMES type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SetMaterialBatchResultToMES*)p = *(struct __ns1__SetMaterialBatchResultToMES*)q;
		break;
	case SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs*)p = *(struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs*)q;
		break;
	case SOAP_TYPE___ns1__CanLogin:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CanLogin type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CanLogin*)p = *(struct __ns1__CanLogin*)q;
		break;
	case SOAP_TYPE___ns1__Login:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Login type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Login*)p = *(struct __ns1__Login*)q;
		break;
	case SOAP_TYPE___ns1__GetWorkCenterID_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetWorkCenterID_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetWorkCenterID_*)p = *(struct __ns1__GetWorkCenterID_*)q;
		break;
	case SOAP_TYPE___ns1__GetCurrentSpecBySn_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetCurrentSpecBySn_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetCurrentSpecBySn_*)p = *(struct __ns1__GetCurrentSpecBySn_*)q;
		break;
	case SOAP_TYPE___ns1__IV_USCOREDataCollection_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__IV_USCOREDataCollection_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__IV_USCOREDataCollection_*)p = *(struct __ns1__IV_USCOREDataCollection_*)q;
		break;
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__jKoIVMoveStd_USCOREPasan_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__jKoIVMoveStd_USCOREPasan_*)p = *(struct __ns1__jKoIVMoveStd_USCOREPasan_*)q;
		break;
	case SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__jKoIVMoveStd_USCORESpire_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__jKoIVMoveStd_USCORESpire_*)p = *(struct __ns1__jKoIVMoveStd_USCORESpire_*)q;
		break;
	case SOAP_TYPE___ns1__ELPictureAddress_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ELPictureAddress_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ELPictureAddress_*)p = *(struct __ns1__ELPictureAddress_*)q;
		break;
	case SOAP_TYPE___ns1__ELInfoMoveStd_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ELInfoMoveStd_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ELInfoMoveStd_*)p = *(struct __ns1__ELInfoMoveStd_*)q;
		break;
	case SOAP_TYPE___ns1__SafetyInfoMoveStd_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SafetyInfoMoveStd_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SafetyInfoMoveStd_*)p = *(struct __ns1__SafetyInfoMoveStd_*)q;
		break;
	case SOAP_TYPE___ns1__UploadTensileInfoToMes_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__UploadTensileInfoToMes_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__UploadTensileInfoToMes_*)p = *(struct __ns1__UploadTensileInfoToMes_*)q;
		break;
	case SOAP_TYPE___ns1__GetContainerDataInfoMES_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetContainerDataInfoMES_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetContainerDataInfoMES_*)p = *(struct __ns1__GetContainerDataInfoMES_*)q;
		break;
	case SOAP_TYPE___ns1__GetTensileTestRule_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetTensileTestRule_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetTensileTestRule_*)p = *(struct __ns1__GetTensileTestRule_*)q;
		break;
	case SOAP_TYPE___ns1__Iscalibrationcontainer_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Iscalibrationcontainer_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Iscalibrationcontainer_*)p = *(struct __ns1__Iscalibrationcontainer_*)q;
		break;
	case SOAP_TYPE___ns1__GetFtpAddress_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetFtpAddress_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetFtpAddress_*)p = *(struct __ns1__GetFtpAddress_*)q;
		break;
	case SOAP_TYPE___ns1__GetDefectInfoToSAP_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetDefectInfoToSAP_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetDefectInfoToSAP_*)p = *(struct __ns1__GetDefectInfoToSAP_*)q;
		break;
	case SOAP_TYPE___ns1__SetDefectResultToMES_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SetDefectResultToMES_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SetDefectResultToMES_*)p = *(struct __ns1__SetDefectResultToMES_*)q;
		break;
	case SOAP_TYPE___ns1__SetMaterialBatchResultToMES_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__SetMaterialBatchResultToMES_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__SetMaterialBatchResultToMES_*)p = *(struct __ns1__SetMaterialBatchResultToMES_*)q;
		break;
	case SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_*)p = *(struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_*)q;
		break;
	case SOAP_TYPE___ns1__CanLogin_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CanLogin_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CanLogin_*)p = *(struct __ns1__CanLogin_*)q;
		break;
	case SOAP_TYPE___ns1__Login_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Login_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Login_*)p = *(struct __ns1__Login_*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__decimal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SubmitResult_ResultTable::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOf_XML(soap, &this->_ns1__SubmitResult_ResultTable::__any);
	this->_ns1__SubmitResult_ResultTable::__any_ = NULL;
}

void _ns1__SubmitResult_ResultTable::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->_ns1__SubmitResult_ResultTable::__any);
#endif
}

int _ns1__SubmitResult_ResultTable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SubmitResult_ResultTable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SubmitResult_ResultTable(struct soap *soap, const char *tag, int id, const _ns1__SubmitResult_ResultTable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SubmitResult_ResultTable), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->_ns1__SubmitResult_ResultTable::__any, ""))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->_ns1__SubmitResult_ResultTable::__any_, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SubmitResult_ResultTable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SubmitResult_ResultTable(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SubmitResult_ResultTable * SOAP_FMAC4 soap_in__ns1__SubmitResult_ResultTable(struct soap *soap, const char *tag, _ns1__SubmitResult_ResultTable *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SubmitResult_ResultTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SubmitResult_ResultTable, sizeof(_ns1__SubmitResult_ResultTable), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SubmitResult_ResultTable)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SubmitResult_ResultTable *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___any_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->_ns1__SubmitResult_ResultTable::__any, ""))
					continue;
			}
			if (soap_flag___any_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->_ns1__SubmitResult_ResultTable::__any_))
				{	soap_flag___any_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SubmitResult_ResultTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SubmitResult_ResultTable, SOAP_TYPE__ns1__SubmitResult_ResultTable, sizeof(_ns1__SubmitResult_ResultTable), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SubmitResult_ResultTable * SOAP_FMAC2 soap_instantiate__ns1__SubmitResult_ResultTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SubmitResult_ResultTable(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SubmitResult_ResultTable *p;
	size_t k = sizeof(_ns1__SubmitResult_ResultTable);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SubmitResult_ResultTable, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SubmitResult_ResultTable);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SubmitResult_ResultTable, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SubmitResult_ResultTable location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SubmitResult_ResultTable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SubmitResult_ResultTable(soap, tag ? tag : "ns1:SubmitResult-ResultTable", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SubmitResult_ResultTable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SubmitResult_ResultTable(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SubmitResult_ResultTable * SOAP_FMAC4 soap_get__ns1__SubmitResult_ResultTable(struct soap *soap, _ns1__SubmitResult_ResultTable *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SubmitResult_ResultTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__LoginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__LoginResponse::LoginResult = NULL;
	/* transient soap skipped */
}

void _ns1__LoginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitResult(soap, &this->_ns1__LoginResponse::LoginResult);
#endif
}

int _ns1__LoginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LoginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LoginResponse(struct soap *soap, const char *tag, int id, const _ns1__LoginResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LoginResponse), type))
		return soap->error;
	if (a->LoginResult)
		soap_element_result(soap, "ns1:LoginResult");
	if (soap_out_PointerTons1__SubmitResult(soap, "ns1:LoginResult", -1, &a->_ns1__LoginResponse::LoginResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__LoginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LoginResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LoginResponse * SOAP_FMAC4 soap_in__ns1__LoginResponse(struct soap *soap, const char *tag, _ns1__LoginResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LoginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LoginResponse, sizeof(_ns1__LoginResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__LoginResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__LoginResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LoginResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LoginResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitResult(soap, "ns1:LoginResult", &a->_ns1__LoginResponse::LoginResult, "ns1:SubmitResult"))
				{	soap_flag_LoginResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:LoginResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LoginResponse, SOAP_TYPE__ns1__LoginResponse, sizeof(_ns1__LoginResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__LoginResponse * SOAP_FMAC2 soap_instantiate__ns1__LoginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LoginResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__LoginResponse *p;
	size_t k = sizeof(_ns1__LoginResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__LoginResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__LoginResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__LoginResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__LoginResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__LoginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__LoginResponse(soap, tag ? tag : "ns1:LoginResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LoginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LoginResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LoginResponse * SOAP_FMAC4 soap_get__ns1__LoginResponse(struct soap *soap, _ns1__LoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Login::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Login::UserName = NULL;
	/* transient soap skipped */
}

void _ns1__Login::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Login::UserName);
#endif
}

int _ns1__Login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Login(struct soap *soap, const char *tag, int id, const _ns1__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Login), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:UserName", -1, &a->_ns1__Login::UserName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Login::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Login(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Login * SOAP_FMAC4 soap_in__ns1__Login(struct soap *soap, const char *tag, _ns1__Login *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Login *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Login, sizeof(_ns1__Login), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__Login)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Login *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UserName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:UserName", &a->_ns1__Login::UserName, "xsd:string"))
				{	soap_flag_UserName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Login, SOAP_TYPE__ns1__Login, sizeof(_ns1__Login), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Login * SOAP_FMAC2 soap_instantiate__ns1__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Login(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Login *p;
	size_t k = sizeof(_ns1__Login);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__Login, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Login);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Login, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Login location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Login::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Login(soap, tag ? tag : "ns1:Login", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Login::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Login(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Login * SOAP_FMAC4 soap_get__ns1__Login(struct soap *soap, _ns1__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CanLoginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CanLoginResponse::CanLoginResult = NULL;
	/* transient soap skipped */
}

void _ns1__CanLoginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitResult(soap, &this->_ns1__CanLoginResponse::CanLoginResult);
#endif
}

int _ns1__CanLoginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CanLoginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CanLoginResponse(struct soap *soap, const char *tag, int id, const _ns1__CanLoginResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CanLoginResponse), type))
		return soap->error;
	if (a->CanLoginResult)
		soap_element_result(soap, "ns1:CanLoginResult");
	if (soap_out_PointerTons1__SubmitResult(soap, "ns1:CanLoginResult", -1, &a->_ns1__CanLoginResponse::CanLoginResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CanLoginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CanLoginResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CanLoginResponse * SOAP_FMAC4 soap_in__ns1__CanLoginResponse(struct soap *soap, const char *tag, _ns1__CanLoginResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CanLoginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CanLoginResponse, sizeof(_ns1__CanLoginResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CanLoginResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CanLoginResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CanLoginResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanLoginResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitResult(soap, "ns1:CanLoginResult", &a->_ns1__CanLoginResponse::CanLoginResult, "ns1:SubmitResult"))
				{	soap_flag_CanLoginResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:CanLoginResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CanLoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CanLoginResponse, SOAP_TYPE__ns1__CanLoginResponse, sizeof(_ns1__CanLoginResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CanLoginResponse * SOAP_FMAC2 soap_instantiate__ns1__CanLoginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CanLoginResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CanLoginResponse *p;
	size_t k = sizeof(_ns1__CanLoginResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CanLoginResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CanLoginResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CanLoginResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CanLoginResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CanLoginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CanLoginResponse(soap, tag ? tag : "ns1:CanLoginResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CanLoginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CanLoginResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CanLoginResponse * SOAP_FMAC4 soap_get__ns1__CanLoginResponse(struct soap *soap, _ns1__CanLoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CanLoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CanLogin::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__CanLogin::strUsername = NULL;
	this->_ns1__CanLogin::strPassword = NULL;
	/* transient soap skipped */
}

void _ns1__CanLogin::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CanLogin::strUsername);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__CanLogin::strPassword);
#endif
}

int _ns1__CanLogin::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CanLogin(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CanLogin(struct soap *soap, const char *tag, int id, const _ns1__CanLogin *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CanLogin), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strUsername", -1, &a->_ns1__CanLogin::strUsername, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:strPassword", -1, &a->_ns1__CanLogin::strPassword, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CanLogin::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CanLogin(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CanLogin * SOAP_FMAC4 soap_in__ns1__CanLogin(struct soap *soap, const char *tag, _ns1__CanLogin *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CanLogin *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CanLogin, sizeof(_ns1__CanLogin), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CanLogin)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CanLogin *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_strUsername1 = 1;
	size_t soap_flag_strPassword1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strUsername1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strUsername", &a->_ns1__CanLogin::strUsername, "xsd:string"))
				{	soap_flag_strUsername1--;
					continue;
				}
			}
			if (soap_flag_strPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:strPassword", &a->_ns1__CanLogin::strPassword, "xsd:string"))
				{	soap_flag_strPassword1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CanLogin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CanLogin, SOAP_TYPE__ns1__CanLogin, sizeof(_ns1__CanLogin), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CanLogin * SOAP_FMAC2 soap_instantiate__ns1__CanLogin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CanLogin(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CanLogin *p;
	size_t k = sizeof(_ns1__CanLogin);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__CanLogin, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__CanLogin);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__CanLogin, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CanLogin location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__CanLogin::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CanLogin(soap, tag ? tag : "ns1:CanLogin", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CanLogin::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CanLogin(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CanLogin * SOAP_FMAC4 soap_get__ns1__CanLogin(struct soap *soap, _ns1__CanLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CanLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse::Upload_USCOREFIDWUL_USCOREDATAFLAGsResult = NULL;
	/* transient soap skipped */
}

void _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse::Upload_USCOREFIDWUL_USCOREDATAFLAGsResult);
#endif
}

int _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse(struct soap *soap, const char *tag, int id, const _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse), type))
		return soap->error;
	if (a->Upload_USCOREFIDWUL_USCOREDATAFLAGsResult)
		soap_element_result(soap, "ns1:Upload_FIDWUL_DATAFLAGsResult");
	if (soap_out_PointerTostd__string(soap, "ns1:Upload_FIDWUL_DATAFLAGsResult", -1, &a->_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse::Upload_USCOREFIDWUL_USCOREDATAFLAGsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse * SOAP_FMAC4 soap_in__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse(struct soap *soap, const char *tag, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse, sizeof(_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Upload_USCOREFIDWUL_USCOREDATAFLAGsResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Upload_USCOREFIDWUL_USCOREDATAFLAGsResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Upload_FIDWUL_DATAFLAGsResult", &a->_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse::Upload_USCOREFIDWUL_USCOREDATAFLAGsResult, "xsd:string"))
				{	soap_flag_Upload_USCOREFIDWUL_USCOREDATAFLAGsResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:Upload_FIDWUL_DATAFLAGsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse, SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse, sizeof(_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse * SOAP_FMAC2 soap_instantiate__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse *p;
	size_t k = sizeof(_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse(soap, tag ? tag : "ns1:Upload_FIDWUL_DATAFLAGsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse * SOAP_FMAC4 soap_get__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse(struct soap *soap, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs::list = NULL;
	/* transient soap skipped */
}

void _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfFIDailyWorkReturnEntity(soap, &this->_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs::list);
#endif
}

int _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, const char *tag, int id, const _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs), type))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfFIDailyWorkReturnEntity(soap, "ns1:list", -1, &a->_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs::list, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs * SOAP_FMAC4 soap_in__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, const char *tag, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, sizeof(_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_list1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_list1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfFIDailyWorkReturnEntity(soap, "ns1:list", &a->_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs::list, "ns1:ArrayOfFIDailyWorkReturnEntity"))
				{	soap_flag_list1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, sizeof(_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs * SOAP_FMAC2 soap_instantiate__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *p;
	size_t k = sizeof(_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, tag ? tag : "ns1:Upload_FIDWUL_DATAFLAGs", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs * SOAP_FMAC4 soap_get__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetMaterialBatchResultToMESResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetMaterialBatchResultToMESResponse::SetMaterialBatchResultToMESResult = NULL;
	/* transient soap skipped */
}

void _ns1__SetMaterialBatchResultToMESResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfSubmitResult(soap, &this->_ns1__SetMaterialBatchResultToMESResponse::SetMaterialBatchResultToMESResult);
#endif
}

int _ns1__SetMaterialBatchResultToMESResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetMaterialBatchResultToMESResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetMaterialBatchResultToMESResponse(struct soap *soap, const char *tag, int id, const _ns1__SetMaterialBatchResultToMESResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse), type))
		return soap->error;
	if (a->SetMaterialBatchResultToMESResult)
		soap_element_result(soap, "ns1:SetMaterialBatchResultToMESResult");
	if (soap_out_PointerTons1__ArrayOfSubmitResult(soap, "ns1:SetMaterialBatchResultToMESResult", -1, &a->_ns1__SetMaterialBatchResultToMESResponse::SetMaterialBatchResultToMESResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetMaterialBatchResultToMESResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetMaterialBatchResultToMESResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetMaterialBatchResultToMESResponse * SOAP_FMAC4 soap_in__ns1__SetMaterialBatchResultToMESResponse(struct soap *soap, const char *tag, _ns1__SetMaterialBatchResultToMESResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetMaterialBatchResultToMESResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse, sizeof(_ns1__SetMaterialBatchResultToMESResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SetMaterialBatchResultToMESResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SetMaterialBatchResultToMESResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetMaterialBatchResultToMESResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfSubmitResult(soap, "ns1:SetMaterialBatchResultToMESResult", &a->_ns1__SetMaterialBatchResultToMESResponse::SetMaterialBatchResultToMESResult, "ns1:ArrayOfSubmitResult"))
				{	soap_flag_SetMaterialBatchResultToMESResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SetMaterialBatchResultToMESResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetMaterialBatchResultToMESResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse, SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse, sizeof(_ns1__SetMaterialBatchResultToMESResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetMaterialBatchResultToMESResponse * SOAP_FMAC2 soap_instantiate__ns1__SetMaterialBatchResultToMESResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetMaterialBatchResultToMESResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetMaterialBatchResultToMESResponse *p;
	size_t k = sizeof(_ns1__SetMaterialBatchResultToMESResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SetMaterialBatchResultToMESResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SetMaterialBatchResultToMESResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetMaterialBatchResultToMESResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SetMaterialBatchResultToMESResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SetMaterialBatchResultToMESResponse(soap, tag ? tag : "ns1:SetMaterialBatchResultToMESResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetMaterialBatchResultToMESResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetMaterialBatchResultToMESResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetMaterialBatchResultToMESResponse * SOAP_FMAC4 soap_get__ns1__SetMaterialBatchResultToMESResponse(struct soap *soap, _ns1__SetMaterialBatchResultToMESResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetMaterialBatchResultToMESResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetMaterialBatchResultToMES::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetMaterialBatchResultToMES::UserName = NULL;
	this->_ns1__SetMaterialBatchResultToMES::Password = NULL;
	this->_ns1__SetMaterialBatchResultToMES::lstMaterialBatchResultInfo = NULL;
	/* transient soap skipped */
}

void _ns1__SetMaterialBatchResultToMES::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetMaterialBatchResultToMES::UserName);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetMaterialBatchResultToMES::Password);
	soap_serialize_PointerTons1__ArrayOfMaterialBatchResultInfo(soap, &this->_ns1__SetMaterialBatchResultToMES::lstMaterialBatchResultInfo);
#endif
}

int _ns1__SetMaterialBatchResultToMES::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetMaterialBatchResultToMES(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetMaterialBatchResultToMES(struct soap *soap, const char *tag, int id, const _ns1__SetMaterialBatchResultToMES *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetMaterialBatchResultToMES), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:UserName", -1, &a->_ns1__SetMaterialBatchResultToMES::UserName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Password", -1, &a->_ns1__SetMaterialBatchResultToMES::Password, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfMaterialBatchResultInfo(soap, "ns1:lstMaterialBatchResultInfo", -1, &a->_ns1__SetMaterialBatchResultToMES::lstMaterialBatchResultInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetMaterialBatchResultToMES::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetMaterialBatchResultToMES(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetMaterialBatchResultToMES * SOAP_FMAC4 soap_in__ns1__SetMaterialBatchResultToMES(struct soap *soap, const char *tag, _ns1__SetMaterialBatchResultToMES *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetMaterialBatchResultToMES *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetMaterialBatchResultToMES, sizeof(_ns1__SetMaterialBatchResultToMES), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SetMaterialBatchResultToMES)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SetMaterialBatchResultToMES *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UserName1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_lstMaterialBatchResultInfo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:UserName", &a->_ns1__SetMaterialBatchResultToMES::UserName, "xsd:string"))
				{	soap_flag_UserName1--;
					continue;
				}
			}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Password", &a->_ns1__SetMaterialBatchResultToMES::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			}
			if (soap_flag_lstMaterialBatchResultInfo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfMaterialBatchResultInfo(soap, "ns1:lstMaterialBatchResultInfo", &a->_ns1__SetMaterialBatchResultToMES::lstMaterialBatchResultInfo, "ns1:ArrayOfMaterialBatchResultInfo"))
				{	soap_flag_lstMaterialBatchResultInfo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetMaterialBatchResultToMES *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetMaterialBatchResultToMES, SOAP_TYPE__ns1__SetMaterialBatchResultToMES, sizeof(_ns1__SetMaterialBatchResultToMES), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetMaterialBatchResultToMES * SOAP_FMAC2 soap_instantiate__ns1__SetMaterialBatchResultToMES(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetMaterialBatchResultToMES(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetMaterialBatchResultToMES *p;
	size_t k = sizeof(_ns1__SetMaterialBatchResultToMES);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SetMaterialBatchResultToMES, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SetMaterialBatchResultToMES);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SetMaterialBatchResultToMES, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetMaterialBatchResultToMES location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SetMaterialBatchResultToMES::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SetMaterialBatchResultToMES(soap, tag ? tag : "ns1:SetMaterialBatchResultToMES", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetMaterialBatchResultToMES::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetMaterialBatchResultToMES(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetMaterialBatchResultToMES * SOAP_FMAC4 soap_get__ns1__SetMaterialBatchResultToMES(struct soap *soap, _ns1__SetMaterialBatchResultToMES *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetMaterialBatchResultToMES(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetDefectResultToMESResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetDefectResultToMESResponse::SetDefectResultToMESResult = NULL;
	/* transient soap skipped */
}

void _ns1__SetDefectResultToMESResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfSubmitResult(soap, &this->_ns1__SetDefectResultToMESResponse::SetDefectResultToMESResult);
#endif
}

int _ns1__SetDefectResultToMESResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetDefectResultToMESResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetDefectResultToMESResponse(struct soap *soap, const char *tag, int id, const _ns1__SetDefectResultToMESResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetDefectResultToMESResponse), type))
		return soap->error;
	if (a->SetDefectResultToMESResult)
		soap_element_result(soap, "ns1:SetDefectResultToMESResult");
	if (soap_out_PointerTons1__ArrayOfSubmitResult(soap, "ns1:SetDefectResultToMESResult", -1, &a->_ns1__SetDefectResultToMESResponse::SetDefectResultToMESResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetDefectResultToMESResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetDefectResultToMESResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetDefectResultToMESResponse * SOAP_FMAC4 soap_in__ns1__SetDefectResultToMESResponse(struct soap *soap, const char *tag, _ns1__SetDefectResultToMESResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetDefectResultToMESResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetDefectResultToMESResponse, sizeof(_ns1__SetDefectResultToMESResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SetDefectResultToMESResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SetDefectResultToMESResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SetDefectResultToMESResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SetDefectResultToMESResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfSubmitResult(soap, "ns1:SetDefectResultToMESResult", &a->_ns1__SetDefectResultToMESResponse::SetDefectResultToMESResult, "ns1:ArrayOfSubmitResult"))
				{	soap_flag_SetDefectResultToMESResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SetDefectResultToMESResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetDefectResultToMESResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetDefectResultToMESResponse, SOAP_TYPE__ns1__SetDefectResultToMESResponse, sizeof(_ns1__SetDefectResultToMESResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetDefectResultToMESResponse * SOAP_FMAC2 soap_instantiate__ns1__SetDefectResultToMESResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetDefectResultToMESResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetDefectResultToMESResponse *p;
	size_t k = sizeof(_ns1__SetDefectResultToMESResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SetDefectResultToMESResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SetDefectResultToMESResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SetDefectResultToMESResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetDefectResultToMESResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SetDefectResultToMESResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SetDefectResultToMESResponse(soap, tag ? tag : "ns1:SetDefectResultToMESResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetDefectResultToMESResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetDefectResultToMESResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetDefectResultToMESResponse * SOAP_FMAC4 soap_get__ns1__SetDefectResultToMESResponse(struct soap *soap, _ns1__SetDefectResultToMESResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetDefectResultToMESResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SetDefectResultToMES::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SetDefectResultToMES::UserName = NULL;
	this->_ns1__SetDefectResultToMES::Password = NULL;
	this->_ns1__SetDefectResultToMES::lstDefectResultInfo = NULL;
	/* transient soap skipped */
}

void _ns1__SetDefectResultToMES::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetDefectResultToMES::UserName);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SetDefectResultToMES::Password);
	soap_serialize_PointerTons1__ArrayOfDefectResultInfo(soap, &this->_ns1__SetDefectResultToMES::lstDefectResultInfo);
#endif
}

int _ns1__SetDefectResultToMES::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SetDefectResultToMES(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SetDefectResultToMES(struct soap *soap, const char *tag, int id, const _ns1__SetDefectResultToMES *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SetDefectResultToMES), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:UserName", -1, &a->_ns1__SetDefectResultToMES::UserName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Password", -1, &a->_ns1__SetDefectResultToMES::Password, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfDefectResultInfo(soap, "ns1:lstDefectResultInfo", -1, &a->_ns1__SetDefectResultToMES::lstDefectResultInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SetDefectResultToMES::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SetDefectResultToMES(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SetDefectResultToMES * SOAP_FMAC4 soap_in__ns1__SetDefectResultToMES(struct soap *soap, const char *tag, _ns1__SetDefectResultToMES *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SetDefectResultToMES *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SetDefectResultToMES, sizeof(_ns1__SetDefectResultToMES), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SetDefectResultToMES)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SetDefectResultToMES *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UserName1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_lstDefectResultInfo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:UserName", &a->_ns1__SetDefectResultToMES::UserName, "xsd:string"))
				{	soap_flag_UserName1--;
					continue;
				}
			}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Password", &a->_ns1__SetDefectResultToMES::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			}
			if (soap_flag_lstDefectResultInfo1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfDefectResultInfo(soap, "ns1:lstDefectResultInfo", &a->_ns1__SetDefectResultToMES::lstDefectResultInfo, "ns1:ArrayOfDefectResultInfo"))
				{	soap_flag_lstDefectResultInfo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SetDefectResultToMES *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SetDefectResultToMES, SOAP_TYPE__ns1__SetDefectResultToMES, sizeof(_ns1__SetDefectResultToMES), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SetDefectResultToMES * SOAP_FMAC2 soap_instantiate__ns1__SetDefectResultToMES(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SetDefectResultToMES(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SetDefectResultToMES *p;
	size_t k = sizeof(_ns1__SetDefectResultToMES);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SetDefectResultToMES, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SetDefectResultToMES);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SetDefectResultToMES, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SetDefectResultToMES location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SetDefectResultToMES::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SetDefectResultToMES(soap, tag ? tag : "ns1:SetDefectResultToMES", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SetDefectResultToMES::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SetDefectResultToMES(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SetDefectResultToMES * SOAP_FMAC4 soap_get__ns1__SetDefectResultToMES(struct soap *soap, _ns1__SetDefectResultToMES *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SetDefectResultToMES(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDefectInfoToSAPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetDefectInfoToSAPResponse::GetDefectInfoToSAPResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetDefectInfoToSAPResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitResult(soap, &this->_ns1__GetDefectInfoToSAPResponse::GetDefectInfoToSAPResult);
#endif
}

int _ns1__GetDefectInfoToSAPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDefectInfoToSAPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDefectInfoToSAPResponse(struct soap *soap, const char *tag, int id, const _ns1__GetDefectInfoToSAPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDefectInfoToSAPResponse), type))
		return soap->error;
	if (a->GetDefectInfoToSAPResult)
		soap_element_result(soap, "ns1:GetDefectInfoToSAPResult");
	if (soap_out_PointerTons1__SubmitResult(soap, "ns1:GetDefectInfoToSAPResult", -1, &a->_ns1__GetDefectInfoToSAPResponse::GetDefectInfoToSAPResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDefectInfoToSAPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDefectInfoToSAPResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDefectInfoToSAPResponse * SOAP_FMAC4 soap_in__ns1__GetDefectInfoToSAPResponse(struct soap *soap, const char *tag, _ns1__GetDefectInfoToSAPResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDefectInfoToSAPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDefectInfoToSAPResponse, sizeof(_ns1__GetDefectInfoToSAPResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDefectInfoToSAPResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDefectInfoToSAPResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetDefectInfoToSAPResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetDefectInfoToSAPResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitResult(soap, "ns1:GetDefectInfoToSAPResult", &a->_ns1__GetDefectInfoToSAPResponse::GetDefectInfoToSAPResult, "ns1:SubmitResult"))
				{	soap_flag_GetDefectInfoToSAPResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetDefectInfoToSAPResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDefectInfoToSAPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDefectInfoToSAPResponse, SOAP_TYPE__ns1__GetDefectInfoToSAPResponse, sizeof(_ns1__GetDefectInfoToSAPResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDefectInfoToSAPResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDefectInfoToSAPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDefectInfoToSAPResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDefectInfoToSAPResponse *p;
	size_t k = sizeof(_ns1__GetDefectInfoToSAPResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDefectInfoToSAPResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDefectInfoToSAPResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDefectInfoToSAPResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDefectInfoToSAPResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDefectInfoToSAPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDefectInfoToSAPResponse(soap, tag ? tag : "ns1:GetDefectInfoToSAPResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDefectInfoToSAPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDefectInfoToSAPResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDefectInfoToSAPResponse * SOAP_FMAC4 soap_get__ns1__GetDefectInfoToSAPResponse(struct soap *soap, _ns1__GetDefectInfoToSAPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDefectInfoToSAPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetDefectInfoToSAP::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetDefectInfoToSAP::UserName = NULL;
	this->_ns1__GetDefectInfoToSAP::Password = NULL;
	/* transient soap skipped */
}

void _ns1__GetDefectInfoToSAP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetDefectInfoToSAP::UserName);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetDefectInfoToSAP::Password);
#endif
}

int _ns1__GetDefectInfoToSAP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetDefectInfoToSAP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetDefectInfoToSAP(struct soap *soap, const char *tag, int id, const _ns1__GetDefectInfoToSAP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetDefectInfoToSAP), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:UserName", -1, &a->_ns1__GetDefectInfoToSAP::UserName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Password", -1, &a->_ns1__GetDefectInfoToSAP::Password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetDefectInfoToSAP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetDefectInfoToSAP(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetDefectInfoToSAP * SOAP_FMAC4 soap_in__ns1__GetDefectInfoToSAP(struct soap *soap, const char *tag, _ns1__GetDefectInfoToSAP *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetDefectInfoToSAP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetDefectInfoToSAP, sizeof(_ns1__GetDefectInfoToSAP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetDefectInfoToSAP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetDefectInfoToSAP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UserName1 = 1;
	size_t soap_flag_Password1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:UserName", &a->_ns1__GetDefectInfoToSAP::UserName, "xsd:string"))
				{	soap_flag_UserName1--;
					continue;
				}
			}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Password", &a->_ns1__GetDefectInfoToSAP::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetDefectInfoToSAP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetDefectInfoToSAP, SOAP_TYPE__ns1__GetDefectInfoToSAP, sizeof(_ns1__GetDefectInfoToSAP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetDefectInfoToSAP * SOAP_FMAC2 soap_instantiate__ns1__GetDefectInfoToSAP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetDefectInfoToSAP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetDefectInfoToSAP *p;
	size_t k = sizeof(_ns1__GetDefectInfoToSAP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetDefectInfoToSAP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetDefectInfoToSAP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetDefectInfoToSAP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetDefectInfoToSAP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetDefectInfoToSAP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetDefectInfoToSAP(soap, tag ? tag : "ns1:GetDefectInfoToSAP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetDefectInfoToSAP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetDefectInfoToSAP(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetDefectInfoToSAP * SOAP_FMAC4 soap_get__ns1__GetDefectInfoToSAP(struct soap *soap, _ns1__GetDefectInfoToSAP *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetDefectInfoToSAP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetFtpAddressResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetFtpAddressResponse::GetFtpAddressResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetFtpAddressResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitResult(soap, &this->_ns1__GetFtpAddressResponse::GetFtpAddressResult);
#endif
}

int _ns1__GetFtpAddressResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetFtpAddressResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetFtpAddressResponse(struct soap *soap, const char *tag, int id, const _ns1__GetFtpAddressResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetFtpAddressResponse), type))
		return soap->error;
	if (a->GetFtpAddressResult)
		soap_element_result(soap, "ns1:GetFtpAddressResult");
	if (soap_out_PointerTons1__SubmitResult(soap, "ns1:GetFtpAddressResult", -1, &a->_ns1__GetFtpAddressResponse::GetFtpAddressResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetFtpAddressResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetFtpAddressResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetFtpAddressResponse * SOAP_FMAC4 soap_in__ns1__GetFtpAddressResponse(struct soap *soap, const char *tag, _ns1__GetFtpAddressResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetFtpAddressResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetFtpAddressResponse, sizeof(_ns1__GetFtpAddressResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetFtpAddressResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetFtpAddressResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetFtpAddressResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetFtpAddressResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitResult(soap, "ns1:GetFtpAddressResult", &a->_ns1__GetFtpAddressResponse::GetFtpAddressResult, "ns1:SubmitResult"))
				{	soap_flag_GetFtpAddressResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetFtpAddressResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetFtpAddressResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetFtpAddressResponse, SOAP_TYPE__ns1__GetFtpAddressResponse, sizeof(_ns1__GetFtpAddressResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetFtpAddressResponse * SOAP_FMAC2 soap_instantiate__ns1__GetFtpAddressResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetFtpAddressResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetFtpAddressResponse *p;
	size_t k = sizeof(_ns1__GetFtpAddressResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetFtpAddressResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetFtpAddressResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetFtpAddressResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetFtpAddressResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetFtpAddressResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetFtpAddressResponse(soap, tag ? tag : "ns1:GetFtpAddressResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetFtpAddressResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetFtpAddressResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetFtpAddressResponse * SOAP_FMAC4 soap_get__ns1__GetFtpAddressResponse(struct soap *soap, _ns1__GetFtpAddressResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetFtpAddressResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetFtpAddress::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetFtpAddress::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetFtpAddress::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetFtpAddress(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetFtpAddress(struct soap *soap, const char *tag, int id, const _ns1__GetFtpAddress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetFtpAddress), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetFtpAddress::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetFtpAddress(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetFtpAddress * SOAP_FMAC4 soap_in__ns1__GetFtpAddress(struct soap *soap, const char *tag, _ns1__GetFtpAddress *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetFtpAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetFtpAddress, sizeof(_ns1__GetFtpAddress), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetFtpAddress)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetFtpAddress *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetFtpAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetFtpAddress, SOAP_TYPE__ns1__GetFtpAddress, sizeof(_ns1__GetFtpAddress), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetFtpAddress * SOAP_FMAC2 soap_instantiate__ns1__GetFtpAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetFtpAddress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetFtpAddress *p;
	size_t k = sizeof(_ns1__GetFtpAddress);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetFtpAddress, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetFtpAddress);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetFtpAddress, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetFtpAddress location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetFtpAddress::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetFtpAddress(soap, tag ? tag : "ns1:GetFtpAddress", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetFtpAddress::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetFtpAddress(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetFtpAddress * SOAP_FMAC4 soap_get__ns1__GetFtpAddress(struct soap *soap, _ns1__GetFtpAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetFtpAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__IscalibrationcontainerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__IscalibrationcontainerResponse::IscalibrationcontainerResult = NULL;
	/* transient soap skipped */
}

void _ns1__IscalibrationcontainerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitResult(soap, &this->_ns1__IscalibrationcontainerResponse::IscalibrationcontainerResult);
#endif
}

int _ns1__IscalibrationcontainerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__IscalibrationcontainerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__IscalibrationcontainerResponse(struct soap *soap, const char *tag, int id, const _ns1__IscalibrationcontainerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__IscalibrationcontainerResponse), type))
		return soap->error;
	if (a->IscalibrationcontainerResult)
		soap_element_result(soap, "ns1:IscalibrationcontainerResult");
	if (soap_out_PointerTons1__SubmitResult(soap, "ns1:IscalibrationcontainerResult", -1, &a->_ns1__IscalibrationcontainerResponse::IscalibrationcontainerResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__IscalibrationcontainerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__IscalibrationcontainerResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__IscalibrationcontainerResponse * SOAP_FMAC4 soap_in__ns1__IscalibrationcontainerResponse(struct soap *soap, const char *tag, _ns1__IscalibrationcontainerResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__IscalibrationcontainerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__IscalibrationcontainerResponse, sizeof(_ns1__IscalibrationcontainerResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__IscalibrationcontainerResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__IscalibrationcontainerResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IscalibrationcontainerResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IscalibrationcontainerResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitResult(soap, "ns1:IscalibrationcontainerResult", &a->_ns1__IscalibrationcontainerResponse::IscalibrationcontainerResult, "ns1:SubmitResult"))
				{	soap_flag_IscalibrationcontainerResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:IscalibrationcontainerResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__IscalibrationcontainerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__IscalibrationcontainerResponse, SOAP_TYPE__ns1__IscalibrationcontainerResponse, sizeof(_ns1__IscalibrationcontainerResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__IscalibrationcontainerResponse * SOAP_FMAC2 soap_instantiate__ns1__IscalibrationcontainerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__IscalibrationcontainerResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__IscalibrationcontainerResponse *p;
	size_t k = sizeof(_ns1__IscalibrationcontainerResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__IscalibrationcontainerResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__IscalibrationcontainerResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__IscalibrationcontainerResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__IscalibrationcontainerResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__IscalibrationcontainerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__IscalibrationcontainerResponse(soap, tag ? tag : "ns1:IscalibrationcontainerResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__IscalibrationcontainerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__IscalibrationcontainerResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__IscalibrationcontainerResponse * SOAP_FMAC4 soap_get__ns1__IscalibrationcontainerResponse(struct soap *soap, _ns1__IscalibrationcontainerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__IscalibrationcontainerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Iscalibrationcontainer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__Iscalibrationcontainer::ContainerName = NULL;
	/* transient soap skipped */
}

void _ns1__Iscalibrationcontainer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Iscalibrationcontainer::ContainerName);
#endif
}

int _ns1__Iscalibrationcontainer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Iscalibrationcontainer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Iscalibrationcontainer(struct soap *soap, const char *tag, int id, const _ns1__Iscalibrationcontainer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Iscalibrationcontainer), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ContainerName", -1, &a->_ns1__Iscalibrationcontainer::ContainerName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Iscalibrationcontainer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Iscalibrationcontainer(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Iscalibrationcontainer * SOAP_FMAC4 soap_in__ns1__Iscalibrationcontainer(struct soap *soap, const char *tag, _ns1__Iscalibrationcontainer *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Iscalibrationcontainer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Iscalibrationcontainer, sizeof(_ns1__Iscalibrationcontainer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__Iscalibrationcontainer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Iscalibrationcontainer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ContainerName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ContainerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ContainerName", &a->_ns1__Iscalibrationcontainer::ContainerName, "xsd:string"))
				{	soap_flag_ContainerName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Iscalibrationcontainer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Iscalibrationcontainer, SOAP_TYPE__ns1__Iscalibrationcontainer, sizeof(_ns1__Iscalibrationcontainer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Iscalibrationcontainer * SOAP_FMAC2 soap_instantiate__ns1__Iscalibrationcontainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Iscalibrationcontainer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Iscalibrationcontainer *p;
	size_t k = sizeof(_ns1__Iscalibrationcontainer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__Iscalibrationcontainer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__Iscalibrationcontainer);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__Iscalibrationcontainer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Iscalibrationcontainer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__Iscalibrationcontainer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Iscalibrationcontainer(soap, tag ? tag : "ns1:Iscalibrationcontainer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Iscalibrationcontainer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Iscalibrationcontainer(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Iscalibrationcontainer * SOAP_FMAC4 soap_get__ns1__Iscalibrationcontainer(struct soap *soap, _ns1__Iscalibrationcontainer *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Iscalibrationcontainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetTensileTestRuleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetTensileTestRuleResponse::GetTensileTestRuleResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetTensileTestRuleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitResult(soap, &this->_ns1__GetTensileTestRuleResponse::GetTensileTestRuleResult);
#endif
}

int _ns1__GetTensileTestRuleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTensileTestRuleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTensileTestRuleResponse(struct soap *soap, const char *tag, int id, const _ns1__GetTensileTestRuleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTensileTestRuleResponse), type))
		return soap->error;
	if (a->GetTensileTestRuleResult)
		soap_element_result(soap, "ns1:GetTensileTestRuleResult");
	if (soap_out_PointerTons1__SubmitResult(soap, "ns1:GetTensileTestRuleResult", -1, &a->_ns1__GetTensileTestRuleResponse::GetTensileTestRuleResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTensileTestRuleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTensileTestRuleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTensileTestRuleResponse * SOAP_FMAC4 soap_in__ns1__GetTensileTestRuleResponse(struct soap *soap, const char *tag, _ns1__GetTensileTestRuleResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTensileTestRuleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTensileTestRuleResponse, sizeof(_ns1__GetTensileTestRuleResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetTensileTestRuleResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetTensileTestRuleResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetTensileTestRuleResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetTensileTestRuleResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitResult(soap, "ns1:GetTensileTestRuleResult", &a->_ns1__GetTensileTestRuleResponse::GetTensileTestRuleResult, "ns1:SubmitResult"))
				{	soap_flag_GetTensileTestRuleResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetTensileTestRuleResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTensileTestRuleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTensileTestRuleResponse, SOAP_TYPE__ns1__GetTensileTestRuleResponse, sizeof(_ns1__GetTensileTestRuleResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetTensileTestRuleResponse * SOAP_FMAC2 soap_instantiate__ns1__GetTensileTestRuleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTensileTestRuleResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetTensileTestRuleResponse *p;
	size_t k = sizeof(_ns1__GetTensileTestRuleResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetTensileTestRuleResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetTensileTestRuleResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetTensileTestRuleResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetTensileTestRuleResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetTensileTestRuleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetTensileTestRuleResponse(soap, tag ? tag : "ns1:GetTensileTestRuleResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTensileTestRuleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTensileTestRuleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTensileTestRuleResponse * SOAP_FMAC4 soap_get__ns1__GetTensileTestRuleResponse(struct soap *soap, _ns1__GetTensileTestRuleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTensileTestRuleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetTensileTestRule::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetTensileTestRule::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetTensileTestRule::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetTensileTestRule(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetTensileTestRule(struct soap *soap, const char *tag, int id, const _ns1__GetTensileTestRule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetTensileTestRule), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetTensileTestRule::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetTensileTestRule(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetTensileTestRule * SOAP_FMAC4 soap_in__ns1__GetTensileTestRule(struct soap *soap, const char *tag, _ns1__GetTensileTestRule *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetTensileTestRule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetTensileTestRule, sizeof(_ns1__GetTensileTestRule), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetTensileTestRule)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetTensileTestRule *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetTensileTestRule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetTensileTestRule, SOAP_TYPE__ns1__GetTensileTestRule, sizeof(_ns1__GetTensileTestRule), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetTensileTestRule * SOAP_FMAC2 soap_instantiate__ns1__GetTensileTestRule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetTensileTestRule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetTensileTestRule *p;
	size_t k = sizeof(_ns1__GetTensileTestRule);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetTensileTestRule, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetTensileTestRule);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetTensileTestRule, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetTensileTestRule location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetTensileTestRule::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetTensileTestRule(soap, tag ? tag : "ns1:GetTensileTestRule", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetTensileTestRule::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetTensileTestRule(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetTensileTestRule * SOAP_FMAC4 soap_get__ns1__GetTensileTestRule(struct soap *soap, _ns1__GetTensileTestRule *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetTensileTestRule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetContainerDataInfoMESResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetContainerDataInfoMESResponse::GetContainerDataInfoMESResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetContainerDataInfoMESResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfSubmitResult(soap, &this->_ns1__GetContainerDataInfoMESResponse::GetContainerDataInfoMESResult);
#endif
}

int _ns1__GetContainerDataInfoMESResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetContainerDataInfoMESResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetContainerDataInfoMESResponse(struct soap *soap, const char *tag, int id, const _ns1__GetContainerDataInfoMESResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetContainerDataInfoMESResponse), type))
		return soap->error;
	if (a->GetContainerDataInfoMESResult)
		soap_element_result(soap, "ns1:GetContainerDataInfoMESResult");
	if (soap_out_PointerTons1__ArrayOfSubmitResult(soap, "ns1:GetContainerDataInfoMESResult", -1, &a->_ns1__GetContainerDataInfoMESResponse::GetContainerDataInfoMESResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetContainerDataInfoMESResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetContainerDataInfoMESResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetContainerDataInfoMESResponse * SOAP_FMAC4 soap_in__ns1__GetContainerDataInfoMESResponse(struct soap *soap, const char *tag, _ns1__GetContainerDataInfoMESResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetContainerDataInfoMESResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetContainerDataInfoMESResponse, sizeof(_ns1__GetContainerDataInfoMESResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetContainerDataInfoMESResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetContainerDataInfoMESResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetContainerDataInfoMESResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetContainerDataInfoMESResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ArrayOfSubmitResult(soap, "ns1:GetContainerDataInfoMESResult", &a->_ns1__GetContainerDataInfoMESResponse::GetContainerDataInfoMESResult, "ns1:ArrayOfSubmitResult"))
				{	soap_flag_GetContainerDataInfoMESResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetContainerDataInfoMESResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetContainerDataInfoMESResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetContainerDataInfoMESResponse, SOAP_TYPE__ns1__GetContainerDataInfoMESResponse, sizeof(_ns1__GetContainerDataInfoMESResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetContainerDataInfoMESResponse * SOAP_FMAC2 soap_instantiate__ns1__GetContainerDataInfoMESResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetContainerDataInfoMESResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetContainerDataInfoMESResponse *p;
	size_t k = sizeof(_ns1__GetContainerDataInfoMESResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetContainerDataInfoMESResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetContainerDataInfoMESResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetContainerDataInfoMESResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetContainerDataInfoMESResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetContainerDataInfoMESResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetContainerDataInfoMESResponse(soap, tag ? tag : "ns1:GetContainerDataInfoMESResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetContainerDataInfoMESResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetContainerDataInfoMESResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetContainerDataInfoMESResponse * SOAP_FMAC4 soap_get__ns1__GetContainerDataInfoMESResponse(struct soap *soap, _ns1__GetContainerDataInfoMESResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetContainerDataInfoMESResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetContainerDataInfoMES::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetContainerDataInfoMES::ContainerName = NULL;
	/* transient soap skipped */
}

void _ns1__GetContainerDataInfoMES::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetContainerDataInfoMES::ContainerName);
#endif
}

int _ns1__GetContainerDataInfoMES::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetContainerDataInfoMES(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetContainerDataInfoMES(struct soap *soap, const char *tag, int id, const _ns1__GetContainerDataInfoMES *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetContainerDataInfoMES), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ContainerName", -1, &a->_ns1__GetContainerDataInfoMES::ContainerName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetContainerDataInfoMES::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetContainerDataInfoMES(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetContainerDataInfoMES * SOAP_FMAC4 soap_in__ns1__GetContainerDataInfoMES(struct soap *soap, const char *tag, _ns1__GetContainerDataInfoMES *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetContainerDataInfoMES *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetContainerDataInfoMES, sizeof(_ns1__GetContainerDataInfoMES), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetContainerDataInfoMES)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetContainerDataInfoMES *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ContainerName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ContainerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ContainerName", &a->_ns1__GetContainerDataInfoMES::ContainerName, "xsd:string"))
				{	soap_flag_ContainerName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetContainerDataInfoMES *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetContainerDataInfoMES, SOAP_TYPE__ns1__GetContainerDataInfoMES, sizeof(_ns1__GetContainerDataInfoMES), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetContainerDataInfoMES * SOAP_FMAC2 soap_instantiate__ns1__GetContainerDataInfoMES(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetContainerDataInfoMES(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetContainerDataInfoMES *p;
	size_t k = sizeof(_ns1__GetContainerDataInfoMES);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetContainerDataInfoMES, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetContainerDataInfoMES);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetContainerDataInfoMES, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetContainerDataInfoMES location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetContainerDataInfoMES::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetContainerDataInfoMES(soap, tag ? tag : "ns1:GetContainerDataInfoMES", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetContainerDataInfoMES::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetContainerDataInfoMES(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetContainerDataInfoMES * SOAP_FMAC4 soap_get__ns1__GetContainerDataInfoMES(struct soap *soap, _ns1__GetContainerDataInfoMES *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetContainerDataInfoMES(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UploadTensileInfoToMesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UploadTensileInfoToMesResponse::UploadTensileInfoToMesResult = NULL;
	/* transient soap skipped */
}

void _ns1__UploadTensileInfoToMesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitResult(soap, &this->_ns1__UploadTensileInfoToMesResponse::UploadTensileInfoToMesResult);
#endif
}

int _ns1__UploadTensileInfoToMesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UploadTensileInfoToMesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadTensileInfoToMesResponse(struct soap *soap, const char *tag, int id, const _ns1__UploadTensileInfoToMesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadTensileInfoToMesResponse), type))
		return soap->error;
	if (a->UploadTensileInfoToMesResult)
		soap_element_result(soap, "ns1:UploadTensileInfoToMesResult");
	if (soap_out_PointerTons1__SubmitResult(soap, "ns1:UploadTensileInfoToMesResult", -1, &a->_ns1__UploadTensileInfoToMesResponse::UploadTensileInfoToMesResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UploadTensileInfoToMesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UploadTensileInfoToMesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadTensileInfoToMesResponse * SOAP_FMAC4 soap_in__ns1__UploadTensileInfoToMesResponse(struct soap *soap, const char *tag, _ns1__UploadTensileInfoToMesResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UploadTensileInfoToMesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadTensileInfoToMesResponse, sizeof(_ns1__UploadTensileInfoToMesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UploadTensileInfoToMesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UploadTensileInfoToMesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UploadTensileInfoToMesResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadTensileInfoToMesResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitResult(soap, "ns1:UploadTensileInfoToMesResult", &a->_ns1__UploadTensileInfoToMesResponse::UploadTensileInfoToMesResult, "ns1:SubmitResult"))
				{	soap_flag_UploadTensileInfoToMesResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:UploadTensileInfoToMesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UploadTensileInfoToMesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadTensileInfoToMesResponse, SOAP_TYPE__ns1__UploadTensileInfoToMesResponse, sizeof(_ns1__UploadTensileInfoToMesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UploadTensileInfoToMesResponse * SOAP_FMAC2 soap_instantiate__ns1__UploadTensileInfoToMesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadTensileInfoToMesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UploadTensileInfoToMesResponse *p;
	size_t k = sizeof(_ns1__UploadTensileInfoToMesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__UploadTensileInfoToMesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__UploadTensileInfoToMesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__UploadTensileInfoToMesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UploadTensileInfoToMesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__UploadTensileInfoToMesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UploadTensileInfoToMesResponse(soap, tag ? tag : "ns1:UploadTensileInfoToMesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UploadTensileInfoToMesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UploadTensileInfoToMesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadTensileInfoToMesResponse * SOAP_FMAC4 soap_get__ns1__UploadTensileInfoToMesResponse(struct soap *soap, _ns1__UploadTensileInfoToMesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadTensileInfoToMesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__UploadTensileInfoToMes::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__UploadTensileInfoToMes::LotSn = NULL;
	this->_ns1__UploadTensileInfoToMes::TestData = NULL;
	/* transient soap skipped */
}

void _ns1__UploadTensileInfoToMes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UploadTensileInfoToMes::LotSn);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__UploadTensileInfoToMes::TestData);
#endif
}

int _ns1__UploadTensileInfoToMes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UploadTensileInfoToMes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadTensileInfoToMes(struct soap *soap, const char *tag, int id, const _ns1__UploadTensileInfoToMes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadTensileInfoToMes), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LotSn", -1, &a->_ns1__UploadTensileInfoToMes::LotSn, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestData", -1, &a->_ns1__UploadTensileInfoToMes::TestData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__UploadTensileInfoToMes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UploadTensileInfoToMes(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadTensileInfoToMes * SOAP_FMAC4 soap_in__ns1__UploadTensileInfoToMes(struct soap *soap, const char *tag, _ns1__UploadTensileInfoToMes *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UploadTensileInfoToMes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadTensileInfoToMes, sizeof(_ns1__UploadTensileInfoToMes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__UploadTensileInfoToMes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__UploadTensileInfoToMes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LotSn1 = 1;
	size_t soap_flag_TestData1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LotSn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LotSn", &a->_ns1__UploadTensileInfoToMes::LotSn, "xsd:string"))
				{	soap_flag_LotSn1--;
					continue;
				}
			}
			if (soap_flag_TestData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestData", &a->_ns1__UploadTensileInfoToMes::TestData, "xsd:string"))
				{	soap_flag_TestData1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UploadTensileInfoToMes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadTensileInfoToMes, SOAP_TYPE__ns1__UploadTensileInfoToMes, sizeof(_ns1__UploadTensileInfoToMes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__UploadTensileInfoToMes * SOAP_FMAC2 soap_instantiate__ns1__UploadTensileInfoToMes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadTensileInfoToMes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__UploadTensileInfoToMes *p;
	size_t k = sizeof(_ns1__UploadTensileInfoToMes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__UploadTensileInfoToMes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__UploadTensileInfoToMes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__UploadTensileInfoToMes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__UploadTensileInfoToMes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__UploadTensileInfoToMes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__UploadTensileInfoToMes(soap, tag ? tag : "ns1:UploadTensileInfoToMes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UploadTensileInfoToMes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UploadTensileInfoToMes(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadTensileInfoToMes * SOAP_FMAC4 soap_get__ns1__UploadTensileInfoToMes(struct soap *soap, _ns1__UploadTensileInfoToMes *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadTensileInfoToMes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SafetyInfoMoveStdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__SafetyInfoMoveStdResponse::SafetyInfoMoveStdResult = NULL;
	/* transient soap skipped */
}

void _ns1__SafetyInfoMoveStdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitResult(soap, &this->_ns1__SafetyInfoMoveStdResponse::SafetyInfoMoveStdResult);
#endif
}

int _ns1__SafetyInfoMoveStdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SafetyInfoMoveStdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SafetyInfoMoveStdResponse(struct soap *soap, const char *tag, int id, const _ns1__SafetyInfoMoveStdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SafetyInfoMoveStdResponse), type))
		return soap->error;
	if (a->SafetyInfoMoveStdResult)
		soap_element_result(soap, "ns1:SafetyInfoMoveStdResult");
	if (soap_out_PointerTons1__SubmitResult(soap, "ns1:SafetyInfoMoveStdResult", -1, &a->_ns1__SafetyInfoMoveStdResponse::SafetyInfoMoveStdResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SafetyInfoMoveStdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SafetyInfoMoveStdResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SafetyInfoMoveStdResponse * SOAP_FMAC4 soap_in__ns1__SafetyInfoMoveStdResponse(struct soap *soap, const char *tag, _ns1__SafetyInfoMoveStdResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SafetyInfoMoveStdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SafetyInfoMoveStdResponse, sizeof(_ns1__SafetyInfoMoveStdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SafetyInfoMoveStdResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SafetyInfoMoveStdResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SafetyInfoMoveStdResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SafetyInfoMoveStdResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitResult(soap, "ns1:SafetyInfoMoveStdResult", &a->_ns1__SafetyInfoMoveStdResponse::SafetyInfoMoveStdResult, "ns1:SubmitResult"))
				{	soap_flag_SafetyInfoMoveStdResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:SafetyInfoMoveStdResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SafetyInfoMoveStdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SafetyInfoMoveStdResponse, SOAP_TYPE__ns1__SafetyInfoMoveStdResponse, sizeof(_ns1__SafetyInfoMoveStdResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SafetyInfoMoveStdResponse * SOAP_FMAC2 soap_instantiate__ns1__SafetyInfoMoveStdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SafetyInfoMoveStdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SafetyInfoMoveStdResponse *p;
	size_t k = sizeof(_ns1__SafetyInfoMoveStdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SafetyInfoMoveStdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SafetyInfoMoveStdResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SafetyInfoMoveStdResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SafetyInfoMoveStdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SafetyInfoMoveStdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SafetyInfoMoveStdResponse(soap, tag ? tag : "ns1:SafetyInfoMoveStdResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SafetyInfoMoveStdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SafetyInfoMoveStdResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SafetyInfoMoveStdResponse * SOAP_FMAC4 soap_get__ns1__SafetyInfoMoveStdResponse(struct soap *soap, _ns1__SafetyInfoMoveStdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SafetyInfoMoveStdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__SafetyInfoMoveStd::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dateTime(soap, &this->_ns1__SafetyInfoMoveStd::TestDate);
	this->_ns1__SafetyInfoMoveStd::LotSN = NULL;
	this->_ns1__SafetyInfoMoveStd::Current = NULL;
	this->_ns1__SafetyInfoMoveStd::InsulationResistance = NULL;
	this->_ns1__SafetyInfoMoveStd::GroundResistance = NULL;
	this->_ns1__SafetyInfoMoveStd::TestResult = NULL;
	this->_ns1__SafetyInfoMoveStd::IPAddress = NULL;
	/* transient soap skipped */
}

void _ns1__SafetyInfoMoveStd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SafetyInfoMoveStd::LotSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SafetyInfoMoveStd::Current);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SafetyInfoMoveStd::InsulationResistance);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SafetyInfoMoveStd::GroundResistance);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SafetyInfoMoveStd::TestResult);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__SafetyInfoMoveStd::IPAddress);
#endif
}

int _ns1__SafetyInfoMoveStd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SafetyInfoMoveStd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SafetyInfoMoveStd(struct soap *soap, const char *tag, int id, const _ns1__SafetyInfoMoveStd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SafetyInfoMoveStd), type))
		return soap->error;
	if (soap_out_dateTime(soap, "ns1:TestDate", -1, &a->_ns1__SafetyInfoMoveStd::TestDate, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LotSN", -1, &a->_ns1__SafetyInfoMoveStd::LotSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:Current", -1, &a->_ns1__SafetyInfoMoveStd::Current, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:InsulationResistance", -1, &a->_ns1__SafetyInfoMoveStd::InsulationResistance, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:GroundResistance", -1, &a->_ns1__SafetyInfoMoveStd::GroundResistance, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestResult", -1, &a->_ns1__SafetyInfoMoveStd::TestResult, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:IPAddress", -1, &a->_ns1__SafetyInfoMoveStd::IPAddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__SafetyInfoMoveStd::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SafetyInfoMoveStd(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SafetyInfoMoveStd * SOAP_FMAC4 soap_in__ns1__SafetyInfoMoveStd(struct soap *soap, const char *tag, _ns1__SafetyInfoMoveStd *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SafetyInfoMoveStd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SafetyInfoMoveStd, sizeof(_ns1__SafetyInfoMoveStd), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__SafetyInfoMoveStd)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__SafetyInfoMoveStd *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TestDate1 = 1;
	size_t soap_flag_LotSN1 = 1;
	size_t soap_flag_Current1 = 1;
	size_t soap_flag_InsulationResistance1 = 1;
	size_t soap_flag_GroundResistance1 = 1;
	size_t soap_flag_TestResult1 = 1;
	size_t soap_flag_IPAddress1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TestDate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "ns1:TestDate", &a->_ns1__SafetyInfoMoveStd::TestDate, "xsd:dateTime"))
				{	soap_flag_TestDate1--;
					continue;
				}
			}
			if (soap_flag_LotSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LotSN", &a->_ns1__SafetyInfoMoveStd::LotSN, "xsd:string"))
				{	soap_flag_LotSN1--;
					continue;
				}
			}
			if (soap_flag_Current1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:Current", &a->_ns1__SafetyInfoMoveStd::Current, "xsd:string"))
				{	soap_flag_Current1--;
					continue;
				}
			}
			if (soap_flag_InsulationResistance1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:InsulationResistance", &a->_ns1__SafetyInfoMoveStd::InsulationResistance, "xsd:string"))
				{	soap_flag_InsulationResistance1--;
					continue;
				}
			}
			if (soap_flag_GroundResistance1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:GroundResistance", &a->_ns1__SafetyInfoMoveStd::GroundResistance, "xsd:string"))
				{	soap_flag_GroundResistance1--;
					continue;
				}
			}
			if (soap_flag_TestResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestResult", &a->_ns1__SafetyInfoMoveStd::TestResult, "xsd:string"))
				{	soap_flag_TestResult1--;
					continue;
				}
			}
			if (soap_flag_IPAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:IPAddress", &a->_ns1__SafetyInfoMoveStd::IPAddress, "xsd:string"))
				{	soap_flag_IPAddress1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TestDate1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__SafetyInfoMoveStd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SafetyInfoMoveStd, SOAP_TYPE__ns1__SafetyInfoMoveStd, sizeof(_ns1__SafetyInfoMoveStd), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__SafetyInfoMoveStd * SOAP_FMAC2 soap_instantiate__ns1__SafetyInfoMoveStd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SafetyInfoMoveStd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__SafetyInfoMoveStd *p;
	size_t k = sizeof(_ns1__SafetyInfoMoveStd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__SafetyInfoMoveStd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__SafetyInfoMoveStd);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__SafetyInfoMoveStd, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__SafetyInfoMoveStd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__SafetyInfoMoveStd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__SafetyInfoMoveStd(soap, tag ? tag : "ns1:SafetyInfoMoveStd", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SafetyInfoMoveStd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SafetyInfoMoveStd(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SafetyInfoMoveStd * SOAP_FMAC4 soap_get__ns1__SafetyInfoMoveStd(struct soap *soap, _ns1__SafetyInfoMoveStd *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SafetyInfoMoveStd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ELInfoMoveStdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ELInfoMoveStdResponse::ELInfoMoveStdResult = NULL;
	/* transient soap skipped */
}

void _ns1__ELInfoMoveStdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitResult(soap, &this->_ns1__ELInfoMoveStdResponse::ELInfoMoveStdResult);
#endif
}

int _ns1__ELInfoMoveStdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ELInfoMoveStdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ELInfoMoveStdResponse(struct soap *soap, const char *tag, int id, const _ns1__ELInfoMoveStdResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ELInfoMoveStdResponse), type))
		return soap->error;
	if (a->ELInfoMoveStdResult)
		soap_element_result(soap, "ns1:ELInfoMoveStdResult");
	if (soap_out_PointerTons1__SubmitResult(soap, "ns1:ELInfoMoveStdResult", -1, &a->_ns1__ELInfoMoveStdResponse::ELInfoMoveStdResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ELInfoMoveStdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ELInfoMoveStdResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ELInfoMoveStdResponse * SOAP_FMAC4 soap_in__ns1__ELInfoMoveStdResponse(struct soap *soap, const char *tag, _ns1__ELInfoMoveStdResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ELInfoMoveStdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ELInfoMoveStdResponse, sizeof(_ns1__ELInfoMoveStdResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ELInfoMoveStdResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ELInfoMoveStdResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ELInfoMoveStdResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ELInfoMoveStdResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitResult(soap, "ns1:ELInfoMoveStdResult", &a->_ns1__ELInfoMoveStdResponse::ELInfoMoveStdResult, "ns1:SubmitResult"))
				{	soap_flag_ELInfoMoveStdResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ELInfoMoveStdResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ELInfoMoveStdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ELInfoMoveStdResponse, SOAP_TYPE__ns1__ELInfoMoveStdResponse, sizeof(_ns1__ELInfoMoveStdResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ELInfoMoveStdResponse * SOAP_FMAC2 soap_instantiate__ns1__ELInfoMoveStdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ELInfoMoveStdResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ELInfoMoveStdResponse *p;
	size_t k = sizeof(_ns1__ELInfoMoveStdResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ELInfoMoveStdResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ELInfoMoveStdResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ELInfoMoveStdResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ELInfoMoveStdResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ELInfoMoveStdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ELInfoMoveStdResponse(soap, tag ? tag : "ns1:ELInfoMoveStdResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ELInfoMoveStdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ELInfoMoveStdResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ELInfoMoveStdResponse * SOAP_FMAC4 soap_get__ns1__ELInfoMoveStdResponse(struct soap *soap, _ns1__ELInfoMoveStdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ELInfoMoveStdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ELInfoMoveStd::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ELInfoMoveStd::LotSN = NULL;
	this->_ns1__ELInfoMoveStd::TestData = NULL;
	this->_ns1__ELInfoMoveStd::lstDefectInfo = NULL;
	/* transient soap skipped */
}

void _ns1__ELInfoMoveStd::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ELInfoMoveStd::LotSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ELInfoMoveStd::TestData);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ELInfoMoveStd::lstDefectInfo);
#endif
}

int _ns1__ELInfoMoveStd::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ELInfoMoveStd(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ELInfoMoveStd(struct soap *soap, const char *tag, int id, const _ns1__ELInfoMoveStd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ELInfoMoveStd), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LotSN", -1, &a->_ns1__ELInfoMoveStd::LotSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestData", -1, &a->_ns1__ELInfoMoveStd::TestData, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:lstDefectInfo", -1, &a->_ns1__ELInfoMoveStd::lstDefectInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ELInfoMoveStd::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ELInfoMoveStd(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ELInfoMoveStd * SOAP_FMAC4 soap_in__ns1__ELInfoMoveStd(struct soap *soap, const char *tag, _ns1__ELInfoMoveStd *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ELInfoMoveStd *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ELInfoMoveStd, sizeof(_ns1__ELInfoMoveStd), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ELInfoMoveStd)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ELInfoMoveStd *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LotSN1 = 1;
	size_t soap_flag_TestData1 = 1;
	size_t soap_flag_lstDefectInfo1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LotSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LotSN", &a->_ns1__ELInfoMoveStd::LotSN, "xsd:string"))
				{	soap_flag_LotSN1--;
					continue;
				}
			}
			if (soap_flag_TestData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestData", &a->_ns1__ELInfoMoveStd::TestData, "xsd:string"))
				{	soap_flag_TestData1--;
					continue;
				}
			}
			if (soap_flag_lstDefectInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:lstDefectInfo", &a->_ns1__ELInfoMoveStd::lstDefectInfo, "xsd:string"))
				{	soap_flag_lstDefectInfo1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ELInfoMoveStd *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ELInfoMoveStd, SOAP_TYPE__ns1__ELInfoMoveStd, sizeof(_ns1__ELInfoMoveStd), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ELInfoMoveStd * SOAP_FMAC2 soap_instantiate__ns1__ELInfoMoveStd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ELInfoMoveStd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ELInfoMoveStd *p;
	size_t k = sizeof(_ns1__ELInfoMoveStd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ELInfoMoveStd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ELInfoMoveStd);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ELInfoMoveStd, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ELInfoMoveStd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ELInfoMoveStd::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ELInfoMoveStd(soap, tag ? tag : "ns1:ELInfoMoveStd", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ELInfoMoveStd::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ELInfoMoveStd(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ELInfoMoveStd * SOAP_FMAC4 soap_get__ns1__ELInfoMoveStd(struct soap *soap, _ns1__ELInfoMoveStd *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ELInfoMoveStd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ELPictureAddressResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ELPictureAddressResponse::ELPictureAddressResult = NULL;
	/* transient soap skipped */
}

void _ns1__ELPictureAddressResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ELPictureAddressResponse::ELPictureAddressResult);
#endif
}

int _ns1__ELPictureAddressResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ELPictureAddressResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ELPictureAddressResponse(struct soap *soap, const char *tag, int id, const _ns1__ELPictureAddressResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ELPictureAddressResponse), type))
		return soap->error;
	if (a->ELPictureAddressResult)
		soap_element_result(soap, "ns1:ELPictureAddressResult");
	if (soap_out_PointerTostd__string(soap, "ns1:ELPictureAddressResult", -1, &a->_ns1__ELPictureAddressResponse::ELPictureAddressResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ELPictureAddressResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ELPictureAddressResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ELPictureAddressResponse * SOAP_FMAC4 soap_in__ns1__ELPictureAddressResponse(struct soap *soap, const char *tag, _ns1__ELPictureAddressResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ELPictureAddressResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ELPictureAddressResponse, sizeof(_ns1__ELPictureAddressResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ELPictureAddressResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ELPictureAddressResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ELPictureAddressResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ELPictureAddressResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ELPictureAddressResult", &a->_ns1__ELPictureAddressResponse::ELPictureAddressResult, "xsd:string"))
				{	soap_flag_ELPictureAddressResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:ELPictureAddressResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ELPictureAddressResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ELPictureAddressResponse, SOAP_TYPE__ns1__ELPictureAddressResponse, sizeof(_ns1__ELPictureAddressResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ELPictureAddressResponse * SOAP_FMAC2 soap_instantiate__ns1__ELPictureAddressResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ELPictureAddressResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ELPictureAddressResponse *p;
	size_t k = sizeof(_ns1__ELPictureAddressResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ELPictureAddressResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ELPictureAddressResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ELPictureAddressResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ELPictureAddressResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ELPictureAddressResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ELPictureAddressResponse(soap, tag ? tag : "ns1:ELPictureAddressResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ELPictureAddressResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ELPictureAddressResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ELPictureAddressResponse * SOAP_FMAC4 soap_get__ns1__ELPictureAddressResponse(struct soap *soap, _ns1__ELPictureAddressResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ELPictureAddressResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ELPictureAddress::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ELPictureAddress::LotSn = NULL;
	/* transient soap skipped */
}

void _ns1__ELPictureAddress::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__ELPictureAddress::LotSn);
#endif
}

int _ns1__ELPictureAddress::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ELPictureAddress(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ELPictureAddress(struct soap *soap, const char *tag, int id, const _ns1__ELPictureAddress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ELPictureAddress), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LotSn", -1, &a->_ns1__ELPictureAddress::LotSn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ELPictureAddress::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ELPictureAddress(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ELPictureAddress * SOAP_FMAC4 soap_in__ns1__ELPictureAddress(struct soap *soap, const char *tag, _ns1__ELPictureAddress *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ELPictureAddress *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ELPictureAddress, sizeof(_ns1__ELPictureAddress), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ELPictureAddress)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ELPictureAddress *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LotSn1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LotSn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LotSn", &a->_ns1__ELPictureAddress::LotSn, "xsd:string"))
				{	soap_flag_LotSn1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ELPictureAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ELPictureAddress, SOAP_TYPE__ns1__ELPictureAddress, sizeof(_ns1__ELPictureAddress), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ELPictureAddress * SOAP_FMAC2 soap_instantiate__ns1__ELPictureAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ELPictureAddress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ELPictureAddress *p;
	size_t k = sizeof(_ns1__ELPictureAddress);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__ELPictureAddress, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__ELPictureAddress);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__ELPictureAddress, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ELPictureAddress location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__ELPictureAddress::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ELPictureAddress(soap, tag ? tag : "ns1:ELPictureAddress", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ELPictureAddress::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ELPictureAddress(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ELPictureAddress * SOAP_FMAC4 soap_get__ns1__ELPictureAddress(struct soap *soap, _ns1__ELPictureAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ELPictureAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__jKoIVMoveStd_USCORESpireResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__jKoIVMoveStd_USCORESpireResponse::jKoIVMoveStd_USCORESpireResult = NULL;
	/* transient soap skipped */
}

void _ns1__jKoIVMoveStd_USCORESpireResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitResult(soap, &this->_ns1__jKoIVMoveStd_USCORESpireResponse::jKoIVMoveStd_USCORESpireResult);
#endif
}

int _ns1__jKoIVMoveStd_USCORESpireResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__jKoIVMoveStd_USCORESpireResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__jKoIVMoveStd_USCORESpireResponse(struct soap *soap, const char *tag, int id, const _ns1__jKoIVMoveStd_USCORESpireResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse), type))
		return soap->error;
	if (a->jKoIVMoveStd_USCORESpireResult)
		soap_element_result(soap, "ns1:jKoIVMoveStd_SpireResult");
	if (soap_out_PointerTons1__SubmitResult(soap, "ns1:jKoIVMoveStd_SpireResult", -1, &a->_ns1__jKoIVMoveStd_USCORESpireResponse::jKoIVMoveStd_USCORESpireResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__jKoIVMoveStd_USCORESpireResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__jKoIVMoveStd_USCORESpireResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__jKoIVMoveStd_USCORESpireResponse * SOAP_FMAC4 soap_in__ns1__jKoIVMoveStd_USCORESpireResponse(struct soap *soap, const char *tag, _ns1__jKoIVMoveStd_USCORESpireResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__jKoIVMoveStd_USCORESpireResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse, sizeof(_ns1__jKoIVMoveStd_USCORESpireResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__jKoIVMoveStd_USCORESpireResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_jKoIVMoveStd_USCORESpireResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jKoIVMoveStd_USCORESpireResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitResult(soap, "ns1:jKoIVMoveStd_SpireResult", &a->_ns1__jKoIVMoveStd_USCORESpireResponse::jKoIVMoveStd_USCORESpireResult, "ns1:SubmitResult"))
				{	soap_flag_jKoIVMoveStd_USCORESpireResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:jKoIVMoveStd_SpireResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__jKoIVMoveStd_USCORESpireResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse, SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse, sizeof(_ns1__jKoIVMoveStd_USCORESpireResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__jKoIVMoveStd_USCORESpireResponse * SOAP_FMAC2 soap_instantiate__ns1__jKoIVMoveStd_USCORESpireResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__jKoIVMoveStd_USCORESpireResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__jKoIVMoveStd_USCORESpireResponse *p;
	size_t k = sizeof(_ns1__jKoIVMoveStd_USCORESpireResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__jKoIVMoveStd_USCORESpireResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__jKoIVMoveStd_USCORESpireResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__jKoIVMoveStd_USCORESpireResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__jKoIVMoveStd_USCORESpireResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__jKoIVMoveStd_USCORESpireResponse(soap, tag ? tag : "ns1:jKoIVMoveStd_SpireResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__jKoIVMoveStd_USCORESpireResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__jKoIVMoveStd_USCORESpireResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__jKoIVMoveStd_USCORESpireResponse * SOAP_FMAC4 soap_get__ns1__jKoIVMoveStd_USCORESpireResponse(struct soap *soap, _ns1__jKoIVMoveStd_USCORESpireResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__jKoIVMoveStd_USCORESpireResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__jKoIVMoveStd_USCORESpire::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__jKoIVMoveStd_USCORESpire::LotSN = NULL;
	this->_ns1__jKoIVMoveStd_USCORESpire::IVDataCollect = NULL;
	/* transient soap skipped */
}

void _ns1__jKoIVMoveStd_USCORESpire::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__jKoIVMoveStd_USCORESpire::LotSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__jKoIVMoveStd_USCORESpire::IVDataCollect);
#endif
}

int _ns1__jKoIVMoveStd_USCORESpire::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__jKoIVMoveStd_USCORESpire(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, const char *tag, int id, const _ns1__jKoIVMoveStd_USCORESpire *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LotSN", -1, &a->_ns1__jKoIVMoveStd_USCORESpire::LotSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:IVDataCollect", -1, &a->_ns1__jKoIVMoveStd_USCORESpire::IVDataCollect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__jKoIVMoveStd_USCORESpire::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__jKoIVMoveStd_USCORESpire(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__jKoIVMoveStd_USCORESpire * SOAP_FMAC4 soap_in__ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, const char *tag, _ns1__jKoIVMoveStd_USCORESpire *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__jKoIVMoveStd_USCORESpire *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire, sizeof(_ns1__jKoIVMoveStd_USCORESpire), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__jKoIVMoveStd_USCORESpire *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LotSN1 = 1;
	size_t soap_flag_IVDataCollect1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LotSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LotSN", &a->_ns1__jKoIVMoveStd_USCORESpire::LotSN, "xsd:string"))
				{	soap_flag_LotSN1--;
					continue;
				}
			}
			if (soap_flag_IVDataCollect1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:IVDataCollect", &a->_ns1__jKoIVMoveStd_USCORESpire::IVDataCollect, "xsd:string"))
				{	soap_flag_IVDataCollect1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__jKoIVMoveStd_USCORESpire *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire, SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire, sizeof(_ns1__jKoIVMoveStd_USCORESpire), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__jKoIVMoveStd_USCORESpire * SOAP_FMAC2 soap_instantiate__ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__jKoIVMoveStd_USCORESpire(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__jKoIVMoveStd_USCORESpire *p;
	size_t k = sizeof(_ns1__jKoIVMoveStd_USCORESpire);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__jKoIVMoveStd_USCORESpire);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__jKoIVMoveStd_USCORESpire, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__jKoIVMoveStd_USCORESpire location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__jKoIVMoveStd_USCORESpire::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__jKoIVMoveStd_USCORESpire(soap, tag ? tag : "ns1:jKoIVMoveStd_Spire", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__jKoIVMoveStd_USCORESpire::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__jKoIVMoveStd_USCORESpire(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__jKoIVMoveStd_USCORESpire * SOAP_FMAC4 soap_get__ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, _ns1__jKoIVMoveStd_USCORESpire *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__jKoIVMoveStd_USCORESpire(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__jKoIVMoveStd_USCOREPasanResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__jKoIVMoveStd_USCOREPasanResponse::jKoIVMoveStd_USCOREPasanResult = NULL;
	/* transient soap skipped */
}

void _ns1__jKoIVMoveStd_USCOREPasanResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitResult(soap, &this->_ns1__jKoIVMoveStd_USCOREPasanResponse::jKoIVMoveStd_USCOREPasanResult);
#endif
}

int _ns1__jKoIVMoveStd_USCOREPasanResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__jKoIVMoveStd_USCOREPasanResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__jKoIVMoveStd_USCOREPasanResponse(struct soap *soap, const char *tag, int id, const _ns1__jKoIVMoveStd_USCOREPasanResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse), type))
		return soap->error;
	if (a->jKoIVMoveStd_USCOREPasanResult)
		soap_element_result(soap, "ns1:jKoIVMoveStd_PasanResult");
	if (soap_out_PointerTons1__SubmitResult(soap, "ns1:jKoIVMoveStd_PasanResult", -1, &a->_ns1__jKoIVMoveStd_USCOREPasanResponse::jKoIVMoveStd_USCOREPasanResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__jKoIVMoveStd_USCOREPasanResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__jKoIVMoveStd_USCOREPasanResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__jKoIVMoveStd_USCOREPasanResponse * SOAP_FMAC4 soap_in__ns1__jKoIVMoveStd_USCOREPasanResponse(struct soap *soap, const char *tag, _ns1__jKoIVMoveStd_USCOREPasanResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__jKoIVMoveStd_USCOREPasanResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse, sizeof(_ns1__jKoIVMoveStd_USCOREPasanResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__jKoIVMoveStd_USCOREPasanResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_jKoIVMoveStd_USCOREPasanResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jKoIVMoveStd_USCOREPasanResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitResult(soap, "ns1:jKoIVMoveStd_PasanResult", &a->_ns1__jKoIVMoveStd_USCOREPasanResponse::jKoIVMoveStd_USCOREPasanResult, "ns1:SubmitResult"))
				{	soap_flag_jKoIVMoveStd_USCOREPasanResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:jKoIVMoveStd_PasanResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__jKoIVMoveStd_USCOREPasanResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse, SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse, sizeof(_ns1__jKoIVMoveStd_USCOREPasanResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__jKoIVMoveStd_USCOREPasanResponse * SOAP_FMAC2 soap_instantiate__ns1__jKoIVMoveStd_USCOREPasanResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__jKoIVMoveStd_USCOREPasanResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__jKoIVMoveStd_USCOREPasanResponse *p;
	size_t k = sizeof(_ns1__jKoIVMoveStd_USCOREPasanResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__jKoIVMoveStd_USCOREPasanResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__jKoIVMoveStd_USCOREPasanResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__jKoIVMoveStd_USCOREPasanResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__jKoIVMoveStd_USCOREPasanResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__jKoIVMoveStd_USCOREPasanResponse(soap, tag ? tag : "ns1:jKoIVMoveStd_PasanResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__jKoIVMoveStd_USCOREPasanResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__jKoIVMoveStd_USCOREPasanResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__jKoIVMoveStd_USCOREPasanResponse * SOAP_FMAC4 soap_get__ns1__jKoIVMoveStd_USCOREPasanResponse(struct soap *soap, _ns1__jKoIVMoveStd_USCOREPasanResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__jKoIVMoveStd_USCOREPasanResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__jKoIVMoveStd_USCOREPasan::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__jKoIVMoveStd_USCOREPasan::LotSN = NULL;
	this->_ns1__jKoIVMoveStd_USCOREPasan::IVDataCollect = NULL;
	/* transient soap skipped */
}

void _ns1__jKoIVMoveStd_USCOREPasan::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__jKoIVMoveStd_USCOREPasan::LotSN);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__jKoIVMoveStd_USCOREPasan::IVDataCollect);
#endif
}

int _ns1__jKoIVMoveStd_USCOREPasan::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__jKoIVMoveStd_USCOREPasan(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, const char *tag, int id, const _ns1__jKoIVMoveStd_USCOREPasan *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LotSN", -1, &a->_ns1__jKoIVMoveStd_USCOREPasan::LotSN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:IVDataCollect", -1, &a->_ns1__jKoIVMoveStd_USCOREPasan::IVDataCollect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__jKoIVMoveStd_USCOREPasan::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__jKoIVMoveStd_USCOREPasan(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__jKoIVMoveStd_USCOREPasan * SOAP_FMAC4 soap_in__ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, const char *tag, _ns1__jKoIVMoveStd_USCOREPasan *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__jKoIVMoveStd_USCOREPasan *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan, sizeof(_ns1__jKoIVMoveStd_USCOREPasan), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__jKoIVMoveStd_USCOREPasan *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LotSN1 = 1;
	size_t soap_flag_IVDataCollect1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LotSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LotSN", &a->_ns1__jKoIVMoveStd_USCOREPasan::LotSN, "xsd:string"))
				{	soap_flag_LotSN1--;
					continue;
				}
			}
			if (soap_flag_IVDataCollect1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:IVDataCollect", &a->_ns1__jKoIVMoveStd_USCOREPasan::IVDataCollect, "xsd:string"))
				{	soap_flag_IVDataCollect1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__jKoIVMoveStd_USCOREPasan *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan, SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan, sizeof(_ns1__jKoIVMoveStd_USCOREPasan), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__jKoIVMoveStd_USCOREPasan * SOAP_FMAC2 soap_instantiate__ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__jKoIVMoveStd_USCOREPasan(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__jKoIVMoveStd_USCOREPasan *p;
	size_t k = sizeof(_ns1__jKoIVMoveStd_USCOREPasan);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__jKoIVMoveStd_USCOREPasan);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__jKoIVMoveStd_USCOREPasan, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__jKoIVMoveStd_USCOREPasan location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__jKoIVMoveStd_USCOREPasan::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__jKoIVMoveStd_USCOREPasan(soap, tag ? tag : "ns1:jKoIVMoveStd_Pasan", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__jKoIVMoveStd_USCOREPasan::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__jKoIVMoveStd_USCOREPasan(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__jKoIVMoveStd_USCOREPasan * SOAP_FMAC4 soap_get__ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, _ns1__jKoIVMoveStd_USCOREPasan *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__jKoIVMoveStd_USCOREPasan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__IV_USCOREDataCollectionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__IV_USCOREDataCollectionResponse::IV_USCOREDataCollectionResult = NULL;
	/* transient soap skipped */
}

void _ns1__IV_USCOREDataCollectionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitResult(soap, &this->_ns1__IV_USCOREDataCollectionResponse::IV_USCOREDataCollectionResult);
#endif
}

int _ns1__IV_USCOREDataCollectionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__IV_USCOREDataCollectionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__IV_USCOREDataCollectionResponse(struct soap *soap, const char *tag, int id, const _ns1__IV_USCOREDataCollectionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse), type))
		return soap->error;
	if (a->IV_USCOREDataCollectionResult)
		soap_element_result(soap, "ns1:IV_DataCollectionResult");
	if (soap_out_PointerTons1__SubmitResult(soap, "ns1:IV_DataCollectionResult", -1, &a->_ns1__IV_USCOREDataCollectionResponse::IV_USCOREDataCollectionResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__IV_USCOREDataCollectionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__IV_USCOREDataCollectionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__IV_USCOREDataCollectionResponse * SOAP_FMAC4 soap_in__ns1__IV_USCOREDataCollectionResponse(struct soap *soap, const char *tag, _ns1__IV_USCOREDataCollectionResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__IV_USCOREDataCollectionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse, sizeof(_ns1__IV_USCOREDataCollectionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__IV_USCOREDataCollectionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IV_USCOREDataCollectionResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IV_USCOREDataCollectionResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitResult(soap, "ns1:IV_DataCollectionResult", &a->_ns1__IV_USCOREDataCollectionResponse::IV_USCOREDataCollectionResult, "ns1:SubmitResult"))
				{	soap_flag_IV_USCOREDataCollectionResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:IV_DataCollectionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__IV_USCOREDataCollectionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse, SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse, sizeof(_ns1__IV_USCOREDataCollectionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__IV_USCOREDataCollectionResponse * SOAP_FMAC2 soap_instantiate__ns1__IV_USCOREDataCollectionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__IV_USCOREDataCollectionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__IV_USCOREDataCollectionResponse *p;
	size_t k = sizeof(_ns1__IV_USCOREDataCollectionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__IV_USCOREDataCollectionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__IV_USCOREDataCollectionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__IV_USCOREDataCollectionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__IV_USCOREDataCollectionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__IV_USCOREDataCollectionResponse(soap, tag ? tag : "ns1:IV_DataCollectionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__IV_USCOREDataCollectionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__IV_USCOREDataCollectionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__IV_USCOREDataCollectionResponse * SOAP_FMAC4 soap_get__ns1__IV_USCOREDataCollectionResponse(struct soap *soap, _ns1__IV_USCOREDataCollectionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__IV_USCOREDataCollectionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__IV_USCOREDataCollection::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__IV_USCOREDataCollection::TestData = NULL;
	this->_ns1__IV_USCOREDataCollection::LotSN = NULL;
	/* transient soap skipped */
}

void _ns1__IV_USCOREDataCollection::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__IV_USCOREDataCollection::TestData);
	soap_serialize_PointerTostd__string(soap, &this->_ns1__IV_USCOREDataCollection::LotSN);
#endif
}

int _ns1__IV_USCOREDataCollection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__IV_USCOREDataCollection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__IV_USCOREDataCollection(struct soap *soap, const char *tag, int id, const _ns1__IV_USCOREDataCollection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__IV_USCOREDataCollection), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:TestData", -1, &a->_ns1__IV_USCOREDataCollection::TestData, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:LotSN", -1, &a->_ns1__IV_USCOREDataCollection::LotSN, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__IV_USCOREDataCollection::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__IV_USCOREDataCollection(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__IV_USCOREDataCollection * SOAP_FMAC4 soap_in__ns1__IV_USCOREDataCollection(struct soap *soap, const char *tag, _ns1__IV_USCOREDataCollection *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__IV_USCOREDataCollection *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__IV_USCOREDataCollection, sizeof(_ns1__IV_USCOREDataCollection), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__IV_USCOREDataCollection)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__IV_USCOREDataCollection *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TestData1 = 1;
	size_t soap_flag_LotSN1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TestData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:TestData", &a->_ns1__IV_USCOREDataCollection::TestData, "xsd:string"))
				{	soap_flag_TestData1--;
					continue;
				}
			}
			if (soap_flag_LotSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:LotSN", &a->_ns1__IV_USCOREDataCollection::LotSN, "xsd:string"))
				{	soap_flag_LotSN1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__IV_USCOREDataCollection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__IV_USCOREDataCollection, SOAP_TYPE__ns1__IV_USCOREDataCollection, sizeof(_ns1__IV_USCOREDataCollection), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__IV_USCOREDataCollection * SOAP_FMAC2 soap_instantiate__ns1__IV_USCOREDataCollection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__IV_USCOREDataCollection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__IV_USCOREDataCollection *p;
	size_t k = sizeof(_ns1__IV_USCOREDataCollection);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__IV_USCOREDataCollection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__IV_USCOREDataCollection);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__IV_USCOREDataCollection, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__IV_USCOREDataCollection location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__IV_USCOREDataCollection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__IV_USCOREDataCollection(soap, tag ? tag : "ns1:IV_DataCollection", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__IV_USCOREDataCollection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__IV_USCOREDataCollection(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__IV_USCOREDataCollection * SOAP_FMAC4 soap_get__ns1__IV_USCOREDataCollection(struct soap *soap, _ns1__IV_USCOREDataCollection *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__IV_USCOREDataCollection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetCurrentSpecBySnResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetCurrentSpecBySnResponse::GetCurrentSpecBySnResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetCurrentSpecBySnResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitResult(soap, &this->_ns1__GetCurrentSpecBySnResponse::GetCurrentSpecBySnResult);
#endif
}

int _ns1__GetCurrentSpecBySnResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetCurrentSpecBySnResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetCurrentSpecBySnResponse(struct soap *soap, const char *tag, int id, const _ns1__GetCurrentSpecBySnResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetCurrentSpecBySnResponse), type))
		return soap->error;
	if (a->GetCurrentSpecBySnResult)
		soap_element_result(soap, "ns1:GetCurrentSpecBySnResult");
	if (soap_out_PointerTons1__SubmitResult(soap, "ns1:GetCurrentSpecBySnResult", -1, &a->_ns1__GetCurrentSpecBySnResponse::GetCurrentSpecBySnResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetCurrentSpecBySnResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetCurrentSpecBySnResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetCurrentSpecBySnResponse * SOAP_FMAC4 soap_in__ns1__GetCurrentSpecBySnResponse(struct soap *soap, const char *tag, _ns1__GetCurrentSpecBySnResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetCurrentSpecBySnResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetCurrentSpecBySnResponse, sizeof(_ns1__GetCurrentSpecBySnResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetCurrentSpecBySnResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetCurrentSpecBySnResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetCurrentSpecBySnResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetCurrentSpecBySnResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitResult(soap, "ns1:GetCurrentSpecBySnResult", &a->_ns1__GetCurrentSpecBySnResponse::GetCurrentSpecBySnResult, "ns1:SubmitResult"))
				{	soap_flag_GetCurrentSpecBySnResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetCurrentSpecBySnResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetCurrentSpecBySnResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetCurrentSpecBySnResponse, SOAP_TYPE__ns1__GetCurrentSpecBySnResponse, sizeof(_ns1__GetCurrentSpecBySnResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetCurrentSpecBySnResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCurrentSpecBySnResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetCurrentSpecBySnResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetCurrentSpecBySnResponse *p;
	size_t k = sizeof(_ns1__GetCurrentSpecBySnResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetCurrentSpecBySnResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetCurrentSpecBySnResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetCurrentSpecBySnResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetCurrentSpecBySnResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetCurrentSpecBySnResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetCurrentSpecBySnResponse(soap, tag ? tag : "ns1:GetCurrentSpecBySnResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetCurrentSpecBySnResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetCurrentSpecBySnResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetCurrentSpecBySnResponse * SOAP_FMAC4 soap_get__ns1__GetCurrentSpecBySnResponse(struct soap *soap, _ns1__GetCurrentSpecBySnResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetCurrentSpecBySnResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetCurrentSpecBySn::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetCurrentSpecBySn::ContainerName = NULL;
	/* transient soap skipped */
}

void _ns1__GetCurrentSpecBySn::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetCurrentSpecBySn::ContainerName);
#endif
}

int _ns1__GetCurrentSpecBySn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetCurrentSpecBySn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetCurrentSpecBySn(struct soap *soap, const char *tag, int id, const _ns1__GetCurrentSpecBySn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetCurrentSpecBySn), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ContainerName", -1, &a->_ns1__GetCurrentSpecBySn::ContainerName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetCurrentSpecBySn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetCurrentSpecBySn(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetCurrentSpecBySn * SOAP_FMAC4 soap_in__ns1__GetCurrentSpecBySn(struct soap *soap, const char *tag, _ns1__GetCurrentSpecBySn *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetCurrentSpecBySn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetCurrentSpecBySn, sizeof(_ns1__GetCurrentSpecBySn), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetCurrentSpecBySn)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetCurrentSpecBySn *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ContainerName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ContainerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ContainerName", &a->_ns1__GetCurrentSpecBySn::ContainerName, "xsd:string"))
				{	soap_flag_ContainerName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetCurrentSpecBySn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetCurrentSpecBySn, SOAP_TYPE__ns1__GetCurrentSpecBySn, sizeof(_ns1__GetCurrentSpecBySn), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetCurrentSpecBySn * SOAP_FMAC2 soap_instantiate__ns1__GetCurrentSpecBySn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetCurrentSpecBySn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetCurrentSpecBySn *p;
	size_t k = sizeof(_ns1__GetCurrentSpecBySn);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetCurrentSpecBySn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetCurrentSpecBySn);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetCurrentSpecBySn, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetCurrentSpecBySn location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetCurrentSpecBySn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetCurrentSpecBySn(soap, tag ? tag : "ns1:GetCurrentSpecBySn", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetCurrentSpecBySn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetCurrentSpecBySn(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetCurrentSpecBySn * SOAP_FMAC4 soap_get__ns1__GetCurrentSpecBySn(struct soap *soap, _ns1__GetCurrentSpecBySn *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetCurrentSpecBySn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetWorkCenterIDResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetWorkCenterIDResponse::GetWorkCenterIDResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetWorkCenterIDResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__SubmitResult(soap, &this->_ns1__GetWorkCenterIDResponse::GetWorkCenterIDResult);
#endif
}

int _ns1__GetWorkCenterIDResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetWorkCenterIDResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetWorkCenterIDResponse(struct soap *soap, const char *tag, int id, const _ns1__GetWorkCenterIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetWorkCenterIDResponse), type))
		return soap->error;
	if (a->GetWorkCenterIDResult)
		soap_element_result(soap, "ns1:GetWorkCenterIDResult");
	if (soap_out_PointerTons1__SubmitResult(soap, "ns1:GetWorkCenterIDResult", -1, &a->_ns1__GetWorkCenterIDResponse::GetWorkCenterIDResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetWorkCenterIDResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetWorkCenterIDResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetWorkCenterIDResponse * SOAP_FMAC4 soap_in__ns1__GetWorkCenterIDResponse(struct soap *soap, const char *tag, _ns1__GetWorkCenterIDResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetWorkCenterIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetWorkCenterIDResponse, sizeof(_ns1__GetWorkCenterIDResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetWorkCenterIDResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetWorkCenterIDResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetWorkCenterIDResult1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetWorkCenterIDResult1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__SubmitResult(soap, "ns1:GetWorkCenterIDResult", &a->_ns1__GetWorkCenterIDResponse::GetWorkCenterIDResult, "ns1:SubmitResult"))
				{	soap_flag_GetWorkCenterIDResult1--;
					continue;
				}
			}
			soap_check_result(soap, "ns1:GetWorkCenterIDResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetWorkCenterIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetWorkCenterIDResponse, SOAP_TYPE__ns1__GetWorkCenterIDResponse, sizeof(_ns1__GetWorkCenterIDResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetWorkCenterIDResponse * SOAP_FMAC2 soap_instantiate__ns1__GetWorkCenterIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetWorkCenterIDResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetWorkCenterIDResponse *p;
	size_t k = sizeof(_ns1__GetWorkCenterIDResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetWorkCenterIDResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetWorkCenterIDResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetWorkCenterIDResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetWorkCenterIDResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetWorkCenterIDResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetWorkCenterIDResponse(soap, tag ? tag : "ns1:GetWorkCenterIDResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetWorkCenterIDResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetWorkCenterIDResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetWorkCenterIDResponse * SOAP_FMAC4 soap_get__ns1__GetWorkCenterIDResponse(struct soap *soap, _ns1__GetWorkCenterIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetWorkCenterIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetWorkCenterID::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetWorkCenterID::ContainerName = NULL;
	/* transient soap skipped */
}

void _ns1__GetWorkCenterID::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__GetWorkCenterID::ContainerName);
#endif
}

int _ns1__GetWorkCenterID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetWorkCenterID(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetWorkCenterID(struct soap *soap, const char *tag, int id, const _ns1__GetWorkCenterID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetWorkCenterID), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ContainerName", -1, &a->_ns1__GetWorkCenterID::ContainerName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetWorkCenterID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetWorkCenterID(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetWorkCenterID * SOAP_FMAC4 soap_in__ns1__GetWorkCenterID(struct soap *soap, const char *tag, _ns1__GetWorkCenterID *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetWorkCenterID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetWorkCenterID, sizeof(_ns1__GetWorkCenterID), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetWorkCenterID)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetWorkCenterID *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ContainerName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ContainerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ContainerName", &a->_ns1__GetWorkCenterID::ContainerName, "xsd:string"))
				{	soap_flag_ContainerName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetWorkCenterID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetWorkCenterID, SOAP_TYPE__ns1__GetWorkCenterID, sizeof(_ns1__GetWorkCenterID), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetWorkCenterID * SOAP_FMAC2 soap_instantiate__ns1__GetWorkCenterID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetWorkCenterID(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetWorkCenterID *p;
	size_t k = sizeof(_ns1__GetWorkCenterID);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__ns1__GetWorkCenterID, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _ns1__GetWorkCenterID);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _ns1__GetWorkCenterID, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetWorkCenterID location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _ns1__GetWorkCenterID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetWorkCenterID(soap, tag ? tag : "ns1:GetWorkCenterID", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetWorkCenterID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetWorkCenterID(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetWorkCenterID * SOAP_FMAC4 soap_get__ns1__GetWorkCenterID(struct soap *soap, _ns1__GetWorkCenterID *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetWorkCenterID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__FIDailyWorkReturnEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__FIDailyWorkReturnEntity::RECORD_USCOREID = NULL;
	soap_default_xsd__decimal(soap, &this->ns1__FIDailyWorkReturnEntity::DATAFLAG);
	this->ns1__FIDailyWorkReturnEntity::MESSAGE = NULL;
	/* transient soap skipped */
}

void ns1__FIDailyWorkReturnEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__FIDailyWorkReturnEntity::RECORD_USCOREID);
	soap_serialize_xsd__decimal(soap, &this->ns1__FIDailyWorkReturnEntity::DATAFLAG);
	soap_serialize_PointerTostd__string(soap, &this->ns1__FIDailyWorkReturnEntity::MESSAGE);
#endif
}

int ns1__FIDailyWorkReturnEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__FIDailyWorkReturnEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__FIDailyWorkReturnEntity(struct soap *soap, const char *tag, int id, const ns1__FIDailyWorkReturnEntity *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__FIDailyWorkReturnEntity), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:RECORD_ID", -1, &a->ns1__FIDailyWorkReturnEntity::RECORD_USCOREID, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "ns1:DATAFLAG", -1, &a->ns1__FIDailyWorkReturnEntity::DATAFLAG, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MESSAGE", -1, &a->ns1__FIDailyWorkReturnEntity::MESSAGE, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__FIDailyWorkReturnEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__FIDailyWorkReturnEntity(soap, tag, this, type);
}

SOAP_FMAC3 ns1__FIDailyWorkReturnEntity * SOAP_FMAC4 soap_in_ns1__FIDailyWorkReturnEntity(struct soap *soap, const char *tag, ns1__FIDailyWorkReturnEntity *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__FIDailyWorkReturnEntity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__FIDailyWorkReturnEntity, sizeof(ns1__FIDailyWorkReturnEntity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__FIDailyWorkReturnEntity)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__FIDailyWorkReturnEntity *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RECORD_USCOREID1 = 1;
	size_t soap_flag_DATAFLAG1 = 1;
	size_t soap_flag_MESSAGE1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RECORD_USCOREID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:RECORD_ID", &a->ns1__FIDailyWorkReturnEntity::RECORD_USCOREID, "xsd:string"))
				{	soap_flag_RECORD_USCOREID1--;
					continue;
				}
			}
			if (soap_flag_DATAFLAG1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "ns1:DATAFLAG", &a->ns1__FIDailyWorkReturnEntity::DATAFLAG, "xsd:decimal"))
				{	soap_flag_DATAFLAG1--;
					continue;
				}
			}
			if (soap_flag_MESSAGE1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MESSAGE", &a->ns1__FIDailyWorkReturnEntity::MESSAGE, "xsd:string"))
				{	soap_flag_MESSAGE1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DATAFLAG1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__FIDailyWorkReturnEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__FIDailyWorkReturnEntity, SOAP_TYPE_ns1__FIDailyWorkReturnEntity, sizeof(ns1__FIDailyWorkReturnEntity), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__FIDailyWorkReturnEntity * SOAP_FMAC2 soap_instantiate_ns1__FIDailyWorkReturnEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__FIDailyWorkReturnEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__FIDailyWorkReturnEntity *p;
	size_t k = sizeof(ns1__FIDailyWorkReturnEntity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__FIDailyWorkReturnEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__FIDailyWorkReturnEntity);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__FIDailyWorkReturnEntity, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__FIDailyWorkReturnEntity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__FIDailyWorkReturnEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__FIDailyWorkReturnEntity(soap, tag ? tag : "ns1:FIDailyWorkReturnEntity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__FIDailyWorkReturnEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__FIDailyWorkReturnEntity(soap, this, tag, type);
}

SOAP_FMAC3 ns1__FIDailyWorkReturnEntity * SOAP_FMAC4 soap_get_ns1__FIDailyWorkReturnEntity(struct soap *soap, ns1__FIDailyWorkReturnEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__FIDailyWorkReturnEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfFIDailyWorkReturnEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity(soap, &this->ns1__ArrayOfFIDailyWorkReturnEntity::FIDailyWorkReturnEntity);
	/* transient soap skipped */
}

void ns1__ArrayOfFIDailyWorkReturnEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity(soap, &this->ns1__ArrayOfFIDailyWorkReturnEntity::FIDailyWorkReturnEntity);
#endif
}

int ns1__ArrayOfFIDailyWorkReturnEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfFIDailyWorkReturnEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfFIDailyWorkReturnEntity(struct soap *soap, const char *tag, int id, const ns1__ArrayOfFIDailyWorkReturnEntity *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity(soap, "ns1:FIDailyWorkReturnEntity", -1, &a->ns1__ArrayOfFIDailyWorkReturnEntity::FIDailyWorkReturnEntity, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfFIDailyWorkReturnEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfFIDailyWorkReturnEntity(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfFIDailyWorkReturnEntity * SOAP_FMAC4 soap_in_ns1__ArrayOfFIDailyWorkReturnEntity(struct soap *soap, const char *tag, ns1__ArrayOfFIDailyWorkReturnEntity *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfFIDailyWorkReturnEntity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity, sizeof(ns1__ArrayOfFIDailyWorkReturnEntity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfFIDailyWorkReturnEntity *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity(soap, "ns1:FIDailyWorkReturnEntity", &a->ns1__ArrayOfFIDailyWorkReturnEntity::FIDailyWorkReturnEntity, "ns1:FIDailyWorkReturnEntity"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfFIDailyWorkReturnEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity, SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity, sizeof(ns1__ArrayOfFIDailyWorkReturnEntity), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfFIDailyWorkReturnEntity * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfFIDailyWorkReturnEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfFIDailyWorkReturnEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfFIDailyWorkReturnEntity *p;
	size_t k = sizeof(ns1__ArrayOfFIDailyWorkReturnEntity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfFIDailyWorkReturnEntity);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfFIDailyWorkReturnEntity, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfFIDailyWorkReturnEntity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfFIDailyWorkReturnEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfFIDailyWorkReturnEntity(soap, tag ? tag : "ns1:ArrayOfFIDailyWorkReturnEntity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfFIDailyWorkReturnEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfFIDailyWorkReturnEntity(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfFIDailyWorkReturnEntity * SOAP_FMAC4 soap_get_ns1__ArrayOfFIDailyWorkReturnEntity(struct soap *soap, ns1__ArrayOfFIDailyWorkReturnEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfFIDailyWorkReturnEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__MaterialBatchResultInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__decimal(soap, &this->ns1__MaterialBatchResultInfo::RECORD_USCOREID);
	soap_default_xsd__decimal(soap, &this->ns1__MaterialBatchResultInfo::DATAFLAG);
	this->ns1__MaterialBatchResultInfo::MESSAGE = NULL;
	/* transient soap skipped */
}

void ns1__MaterialBatchResultInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__decimal(soap, &this->ns1__MaterialBatchResultInfo::RECORD_USCOREID);
	soap_serialize_xsd__decimal(soap, &this->ns1__MaterialBatchResultInfo::DATAFLAG);
	soap_serialize_PointerTostd__string(soap, &this->ns1__MaterialBatchResultInfo::MESSAGE);
#endif
}

int ns1__MaterialBatchResultInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MaterialBatchResultInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MaterialBatchResultInfo(struct soap *soap, const char *tag, int id, const ns1__MaterialBatchResultInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MaterialBatchResultInfo), type))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "ns1:RECORD_ID", -1, &a->ns1__MaterialBatchResultInfo::RECORD_USCOREID, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "ns1:DATAFLAG", -1, &a->ns1__MaterialBatchResultInfo::DATAFLAG, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MESSAGE", -1, &a->ns1__MaterialBatchResultInfo::MESSAGE, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__MaterialBatchResultInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MaterialBatchResultInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MaterialBatchResultInfo * SOAP_FMAC4 soap_in_ns1__MaterialBatchResultInfo(struct soap *soap, const char *tag, ns1__MaterialBatchResultInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MaterialBatchResultInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MaterialBatchResultInfo, sizeof(ns1__MaterialBatchResultInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__MaterialBatchResultInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__MaterialBatchResultInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RECORD_USCOREID1 = 1;
	size_t soap_flag_DATAFLAG1 = 1;
	size_t soap_flag_MESSAGE1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RECORD_USCOREID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "ns1:RECORD_ID", &a->ns1__MaterialBatchResultInfo::RECORD_USCOREID, "xsd:decimal"))
				{	soap_flag_RECORD_USCOREID1--;
					continue;
				}
			}
			if (soap_flag_DATAFLAG1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "ns1:DATAFLAG", &a->ns1__MaterialBatchResultInfo::DATAFLAG, "xsd:decimal"))
				{	soap_flag_DATAFLAG1--;
					continue;
				}
			}
			if (soap_flag_MESSAGE1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MESSAGE", &a->ns1__MaterialBatchResultInfo::MESSAGE, "xsd:string"))
				{	soap_flag_MESSAGE1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RECORD_USCOREID1 > 0 || soap_flag_DATAFLAG1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__MaterialBatchResultInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MaterialBatchResultInfo, SOAP_TYPE_ns1__MaterialBatchResultInfo, sizeof(ns1__MaterialBatchResultInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__MaterialBatchResultInfo * SOAP_FMAC2 soap_instantiate_ns1__MaterialBatchResultInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MaterialBatchResultInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__MaterialBatchResultInfo *p;
	size_t k = sizeof(ns1__MaterialBatchResultInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__MaterialBatchResultInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__MaterialBatchResultInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__MaterialBatchResultInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__MaterialBatchResultInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__MaterialBatchResultInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__MaterialBatchResultInfo(soap, tag ? tag : "ns1:MaterialBatchResultInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__MaterialBatchResultInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MaterialBatchResultInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MaterialBatchResultInfo * SOAP_FMAC4 soap_get_ns1__MaterialBatchResultInfo(struct soap *soap, ns1__MaterialBatchResultInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MaterialBatchResultInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfMaterialBatchResultInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo(soap, &this->ns1__ArrayOfMaterialBatchResultInfo::MaterialBatchResultInfo);
	/* transient soap skipped */
}

void ns1__ArrayOfMaterialBatchResultInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo(soap, &this->ns1__ArrayOfMaterialBatchResultInfo::MaterialBatchResultInfo);
#endif
}

int ns1__ArrayOfMaterialBatchResultInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfMaterialBatchResultInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfMaterialBatchResultInfo(struct soap *soap, const char *tag, int id, const ns1__ArrayOfMaterialBatchResultInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo(soap, "ns1:MaterialBatchResultInfo", -1, &a->ns1__ArrayOfMaterialBatchResultInfo::MaterialBatchResultInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfMaterialBatchResultInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfMaterialBatchResultInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfMaterialBatchResultInfo * SOAP_FMAC4 soap_in_ns1__ArrayOfMaterialBatchResultInfo(struct soap *soap, const char *tag, ns1__ArrayOfMaterialBatchResultInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfMaterialBatchResultInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo, sizeof(ns1__ArrayOfMaterialBatchResultInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfMaterialBatchResultInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo(soap, "ns1:MaterialBatchResultInfo", &a->ns1__ArrayOfMaterialBatchResultInfo::MaterialBatchResultInfo, "ns1:MaterialBatchResultInfo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfMaterialBatchResultInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo, SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo, sizeof(ns1__ArrayOfMaterialBatchResultInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfMaterialBatchResultInfo * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfMaterialBatchResultInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfMaterialBatchResultInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfMaterialBatchResultInfo *p;
	size_t k = sizeof(ns1__ArrayOfMaterialBatchResultInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfMaterialBatchResultInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfMaterialBatchResultInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfMaterialBatchResultInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfMaterialBatchResultInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfMaterialBatchResultInfo(soap, tag ? tag : "ns1:ArrayOfMaterialBatchResultInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfMaterialBatchResultInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfMaterialBatchResultInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfMaterialBatchResultInfo * SOAP_FMAC4 soap_get_ns1__ArrayOfMaterialBatchResultInfo(struct soap *soap, ns1__ArrayOfMaterialBatchResultInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfMaterialBatchResultInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__DefectResultInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__DefectResultInfo::RECORD_USCOREID = NULL;
	this->ns1__DefectResultInfo::DATAFLAG = NULL;
	this->ns1__DefectResultInfo::MESSAGE = NULL;
	/* transient soap skipped */
}

void ns1__DefectResultInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__DefectResultInfo::RECORD_USCOREID);
	soap_serialize_PointerTostd__string(soap, &this->ns1__DefectResultInfo::DATAFLAG);
	soap_serialize_PointerTostd__string(soap, &this->ns1__DefectResultInfo::MESSAGE);
#endif
}

int ns1__DefectResultInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DefectResultInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DefectResultInfo(struct soap *soap, const char *tag, int id, const ns1__DefectResultInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DefectResultInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:RECORD_ID", -1, &a->ns1__DefectResultInfo::RECORD_USCOREID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:DATAFLAG", -1, &a->ns1__DefectResultInfo::DATAFLAG, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:MESSAGE", -1, &a->ns1__DefectResultInfo::MESSAGE, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DefectResultInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DefectResultInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DefectResultInfo * SOAP_FMAC4 soap_in_ns1__DefectResultInfo(struct soap *soap, const char *tag, ns1__DefectResultInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DefectResultInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DefectResultInfo, sizeof(ns1__DefectResultInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__DefectResultInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__DefectResultInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RECORD_USCOREID1 = 1;
	size_t soap_flag_DATAFLAG1 = 1;
	size_t soap_flag_MESSAGE1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RECORD_USCOREID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:RECORD_ID", &a->ns1__DefectResultInfo::RECORD_USCOREID, "xsd:string"))
				{	soap_flag_RECORD_USCOREID1--;
					continue;
				}
			}
			if (soap_flag_DATAFLAG1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:DATAFLAG", &a->ns1__DefectResultInfo::DATAFLAG, "xsd:string"))
				{	soap_flag_DATAFLAG1--;
					continue;
				}
			}
			if (soap_flag_MESSAGE1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:MESSAGE", &a->ns1__DefectResultInfo::MESSAGE, "xsd:string"))
				{	soap_flag_MESSAGE1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DefectResultInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DefectResultInfo, SOAP_TYPE_ns1__DefectResultInfo, sizeof(ns1__DefectResultInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__DefectResultInfo * SOAP_FMAC2 soap_instantiate_ns1__DefectResultInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DefectResultInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__DefectResultInfo *p;
	size_t k = sizeof(ns1__DefectResultInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__DefectResultInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__DefectResultInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__DefectResultInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__DefectResultInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__DefectResultInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__DefectResultInfo(soap, tag ? tag : "ns1:DefectResultInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DefectResultInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DefectResultInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DefectResultInfo * SOAP_FMAC4 soap_get_ns1__DefectResultInfo(struct soap *soap, ns1__DefectResultInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DefectResultInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfDefectResultInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__DefectResultInfo(soap, &this->ns1__ArrayOfDefectResultInfo::DefectResultInfo);
	/* transient soap skipped */
}

void ns1__ArrayOfDefectResultInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__DefectResultInfo(soap, &this->ns1__ArrayOfDefectResultInfo::DefectResultInfo);
#endif
}

int ns1__ArrayOfDefectResultInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfDefectResultInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDefectResultInfo(struct soap *soap, const char *tag, int id, const ns1__ArrayOfDefectResultInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDefectResultInfo), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__DefectResultInfo(soap, "ns1:DefectResultInfo", -1, &a->ns1__ArrayOfDefectResultInfo::DefectResultInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfDefectResultInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfDefectResultInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfDefectResultInfo * SOAP_FMAC4 soap_in_ns1__ArrayOfDefectResultInfo(struct soap *soap, const char *tag, ns1__ArrayOfDefectResultInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfDefectResultInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDefectResultInfo, sizeof(ns1__ArrayOfDefectResultInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfDefectResultInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfDefectResultInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__DefectResultInfo(soap, "ns1:DefectResultInfo", &a->ns1__ArrayOfDefectResultInfo::DefectResultInfo, "ns1:DefectResultInfo"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfDefectResultInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDefectResultInfo, SOAP_TYPE_ns1__ArrayOfDefectResultInfo, sizeof(ns1__ArrayOfDefectResultInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfDefectResultInfo * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfDefectResultInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfDefectResultInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfDefectResultInfo *p;
	size_t k = sizeof(ns1__ArrayOfDefectResultInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfDefectResultInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfDefectResultInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfDefectResultInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfDefectResultInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfDefectResultInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfDefectResultInfo(soap, tag ? tag : "ns1:ArrayOfDefectResultInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfDefectResultInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfDefectResultInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfDefectResultInfo * SOAP_FMAC4 soap_get_ns1__ArrayOfDefectResultInfo(struct soap *soap, ns1__ArrayOfDefectResultInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDefectResultInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfSubmitResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SubmitResult(soap, &this->ns1__ArrayOfSubmitResult::SubmitResult);
	/* transient soap skipped */
}

void ns1__ArrayOfSubmitResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__SubmitResult(soap, &this->ns1__ArrayOfSubmitResult::SubmitResult);
#endif
}

int ns1__ArrayOfSubmitResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfSubmitResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfSubmitResult(struct soap *soap, const char *tag, int id, const ns1__ArrayOfSubmitResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfSubmitResult), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__SubmitResult(soap, "ns1:SubmitResult", -1, &a->ns1__ArrayOfSubmitResult::SubmitResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfSubmitResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfSubmitResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfSubmitResult * SOAP_FMAC4 soap_in_ns1__ArrayOfSubmitResult(struct soap *soap, const char *tag, ns1__ArrayOfSubmitResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfSubmitResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfSubmitResult, sizeof(ns1__ArrayOfSubmitResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfSubmitResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfSubmitResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTons1__SubmitResult(soap, "ns1:SubmitResult", &a->ns1__ArrayOfSubmitResult::SubmitResult, "ns1:SubmitResult"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfSubmitResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfSubmitResult, SOAP_TYPE_ns1__ArrayOfSubmitResult, sizeof(ns1__ArrayOfSubmitResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfSubmitResult * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSubmitResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfSubmitResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfSubmitResult *p;
	size_t k = sizeof(ns1__ArrayOfSubmitResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ArrayOfSubmitResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ArrayOfSubmitResult);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ArrayOfSubmitResult, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfSubmitResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ArrayOfSubmitResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfSubmitResult(soap, tag ? tag : "ns1:ArrayOfSubmitResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfSubmitResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfSubmitResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfSubmitResult * SOAP_FMAC4 soap_get_ns1__ArrayOfSubmitResult(struct soap *soap, ns1__ArrayOfSubmitResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfSubmitResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__SubmitResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SubmitResult::ResultCode = NULL;
	this->ns1__SubmitResult::ResultMsg = NULL;
	this->ns1__SubmitResult::ResultTable = NULL;
	this->ns1__SubmitResult::ResultFilename = NULL;
	/* transient soap skipped */
}

void ns1__SubmitResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__SubmitResult::ResultCode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SubmitResult::ResultMsg);
	soap_serialize_PointerTo_ns1__SubmitResult_ResultTable(soap, &this->ns1__SubmitResult::ResultTable);
	soap_serialize_PointerTostd__string(soap, &this->ns1__SubmitResult::ResultFilename);
#endif
}

int ns1__SubmitResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubmitResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubmitResult(struct soap *soap, const char *tag, int id, const ns1__SubmitResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubmitResult), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ResultCode", -1, &a->ns1__SubmitResult::ResultCode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ResultMsg", -1, &a->ns1__SubmitResult::ResultMsg, ""))
		return soap->error;
	if (soap_out_PointerTo_ns1__SubmitResult_ResultTable(soap, "ns1:ResultTable", -1, &a->ns1__SubmitResult::ResultTable, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:ResultFilename", -1, &a->ns1__SubmitResult::ResultFilename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__SubmitResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SubmitResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubmitResult * SOAP_FMAC4 soap_in_ns1__SubmitResult(struct soap *soap, const char *tag, ns1__SubmitResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubmitResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubmitResult, sizeof(ns1__SubmitResult), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__SubmitResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__SubmitResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ResultCode1 = 1;
	size_t soap_flag_ResultMsg1 = 1;
	size_t soap_flag_ResultTable1 = 1;
	size_t soap_flag_ResultFilename1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ResultCode", &a->ns1__SubmitResult::ResultCode, "xsd:string"))
				{	soap_flag_ResultCode1--;
					continue;
				}
			}
			if (soap_flag_ResultMsg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ResultMsg", &a->ns1__SubmitResult::ResultMsg, "xsd:string"))
				{	soap_flag_ResultMsg1--;
					continue;
				}
			}
			if (soap_flag_ResultTable1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SubmitResult_ResultTable(soap, "ns1:ResultTable", &a->ns1__SubmitResult::ResultTable, ""))
				{	soap_flag_ResultTable1--;
					continue;
				}
			}
			if (soap_flag_ResultFilename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "ns1:ResultFilename", &a->ns1__SubmitResult::ResultFilename, "xsd:string"))
				{	soap_flag_ResultFilename1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SubmitResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubmitResult, SOAP_TYPE_ns1__SubmitResult, sizeof(ns1__SubmitResult), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__SubmitResult * SOAP_FMAC2 soap_instantiate_ns1__SubmitResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubmitResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__SubmitResult *p;
	size_t k = sizeof(ns1__SubmitResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__SubmitResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__SubmitResult);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__SubmitResult, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__SubmitResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__SubmitResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__SubmitResult(soap, tag ? tag : "ns1:SubmitResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SubmitResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubmitResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubmitResult * SOAP_FMAC4 soap_get_ns1__SubmitResult(struct soap *soap, ns1__SubmitResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubmitResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?(\\d+|\\d*\\.\\d*)")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__decimal, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Login_(struct soap *soap, struct __ns1__Login_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Login_(struct soap *soap, const struct __ns1__Login_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Login(soap, &a->ns1__Login);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Login_(struct soap *soap, const char *tag, int id, const struct __ns1__Login_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Login(soap, "ns1:Login", -1, &a->ns1__Login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login_ * SOAP_FMAC4 soap_in___ns1__Login_(struct soap *soap, const char *tag, struct __ns1__Login_ *a, const char *type)
{
	size_t soap_flag_ns1__Login = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Login_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Login_, sizeof(struct __ns1__Login_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Login_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Login && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Login(soap, "ns1:Login", &a->ns1__Login, ""))
				{	soap_flag_ns1__Login--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Login_ * SOAP_FMAC2 soap_instantiate___ns1__Login_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Login_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Login_ *p;
	size_t k = sizeof(struct __ns1__Login_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Login_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Login_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Login_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Login_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Login_(struct soap *soap, const struct __ns1__Login_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Login_(soap, tag ? tag : "-ns1:Login", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login_ * SOAP_FMAC4 soap_get___ns1__Login_(struct soap *soap, struct __ns1__Login_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Login_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CanLogin_(struct soap *soap, struct __ns1__CanLogin_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CanLogin = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CanLogin_(struct soap *soap, const struct __ns1__CanLogin_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CanLogin(soap, &a->ns1__CanLogin);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CanLogin_(struct soap *soap, const char *tag, int id, const struct __ns1__CanLogin_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CanLogin(soap, "ns1:CanLogin", -1, &a->ns1__CanLogin, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CanLogin_ * SOAP_FMAC4 soap_in___ns1__CanLogin_(struct soap *soap, const char *tag, struct __ns1__CanLogin_ *a, const char *type)
{
	size_t soap_flag_ns1__CanLogin = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CanLogin_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CanLogin_, sizeof(struct __ns1__CanLogin_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CanLogin_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CanLogin && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CanLogin(soap, "ns1:CanLogin", &a->ns1__CanLogin, ""))
				{	soap_flag_ns1__CanLogin--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CanLogin_ * SOAP_FMAC2 soap_instantiate___ns1__CanLogin_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CanLogin_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CanLogin_ *p;
	size_t k = sizeof(struct __ns1__CanLogin_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CanLogin_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CanLogin_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CanLogin_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CanLogin_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CanLogin_(struct soap *soap, const struct __ns1__CanLogin_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CanLogin_(soap, tag ? tag : "-ns1:CanLogin", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CanLogin_ * SOAP_FMAC4 soap_get___ns1__CanLogin_(struct soap *soap, struct __ns1__CanLogin_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CanLogin_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(struct soap *soap, struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(struct soap *soap, const struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, &a->ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(struct soap *soap, const char *tag, int id, const struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, "ns1:Upload_FIDWUL_DATAFLAGs", -1, &a->ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ * SOAP_FMAC4 soap_in___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(struct soap *soap, const char *tag, struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ *a, const char *type)
{
	size_t soap_flag_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_, sizeof(struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, "ns1:Upload_FIDWUL_DATAFLAGs", &a->ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, ""))
				{	soap_flag_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ * SOAP_FMAC2 soap_instantiate___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ *p;
	size_t k = sizeof(struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(struct soap *soap, const struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(soap, tag ? tag : "-ns1:Upload_FIDWUL_DATAFLAGs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ * SOAP_FMAC4 soap_get___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(struct soap *soap, struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetMaterialBatchResultToMES_(struct soap *soap, struct __ns1__SetMaterialBatchResultToMES_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetMaterialBatchResultToMES = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetMaterialBatchResultToMES_(struct soap *soap, const struct __ns1__SetMaterialBatchResultToMES_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetMaterialBatchResultToMES(soap, &a->ns1__SetMaterialBatchResultToMES);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetMaterialBatchResultToMES_(struct soap *soap, const char *tag, int id, const struct __ns1__SetMaterialBatchResultToMES_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetMaterialBatchResultToMES(soap, "ns1:SetMaterialBatchResultToMES", -1, &a->ns1__SetMaterialBatchResultToMES, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetMaterialBatchResultToMES_ * SOAP_FMAC4 soap_in___ns1__SetMaterialBatchResultToMES_(struct soap *soap, const char *tag, struct __ns1__SetMaterialBatchResultToMES_ *a, const char *type)
{
	size_t soap_flag_ns1__SetMaterialBatchResultToMES = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SetMaterialBatchResultToMES_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetMaterialBatchResultToMES_, sizeof(struct __ns1__SetMaterialBatchResultToMES_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetMaterialBatchResultToMES_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetMaterialBatchResultToMES && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SetMaterialBatchResultToMES(soap, "ns1:SetMaterialBatchResultToMES", &a->ns1__SetMaterialBatchResultToMES, ""))
				{	soap_flag_ns1__SetMaterialBatchResultToMES--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SetMaterialBatchResultToMES_ * SOAP_FMAC2 soap_instantiate___ns1__SetMaterialBatchResultToMES_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetMaterialBatchResultToMES_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SetMaterialBatchResultToMES_ *p;
	size_t k = sizeof(struct __ns1__SetMaterialBatchResultToMES_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SetMaterialBatchResultToMES_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SetMaterialBatchResultToMES_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SetMaterialBatchResultToMES_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SetMaterialBatchResultToMES_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetMaterialBatchResultToMES_(struct soap *soap, const struct __ns1__SetMaterialBatchResultToMES_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SetMaterialBatchResultToMES_(soap, tag ? tag : "-ns1:SetMaterialBatchResultToMES", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetMaterialBatchResultToMES_ * SOAP_FMAC4 soap_get___ns1__SetMaterialBatchResultToMES_(struct soap *soap, struct __ns1__SetMaterialBatchResultToMES_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetMaterialBatchResultToMES_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetDefectResultToMES_(struct soap *soap, struct __ns1__SetDefectResultToMES_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetDefectResultToMES = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetDefectResultToMES_(struct soap *soap, const struct __ns1__SetDefectResultToMES_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetDefectResultToMES(soap, &a->ns1__SetDefectResultToMES);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetDefectResultToMES_(struct soap *soap, const char *tag, int id, const struct __ns1__SetDefectResultToMES_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetDefectResultToMES(soap, "ns1:SetDefectResultToMES", -1, &a->ns1__SetDefectResultToMES, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetDefectResultToMES_ * SOAP_FMAC4 soap_in___ns1__SetDefectResultToMES_(struct soap *soap, const char *tag, struct __ns1__SetDefectResultToMES_ *a, const char *type)
{
	size_t soap_flag_ns1__SetDefectResultToMES = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SetDefectResultToMES_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetDefectResultToMES_, sizeof(struct __ns1__SetDefectResultToMES_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetDefectResultToMES_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetDefectResultToMES && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SetDefectResultToMES(soap, "ns1:SetDefectResultToMES", &a->ns1__SetDefectResultToMES, ""))
				{	soap_flag_ns1__SetDefectResultToMES--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SetDefectResultToMES_ * SOAP_FMAC2 soap_instantiate___ns1__SetDefectResultToMES_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetDefectResultToMES_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SetDefectResultToMES_ *p;
	size_t k = sizeof(struct __ns1__SetDefectResultToMES_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SetDefectResultToMES_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SetDefectResultToMES_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SetDefectResultToMES_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SetDefectResultToMES_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetDefectResultToMES_(struct soap *soap, const struct __ns1__SetDefectResultToMES_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SetDefectResultToMES_(soap, tag ? tag : "-ns1:SetDefectResultToMES", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetDefectResultToMES_ * SOAP_FMAC4 soap_get___ns1__SetDefectResultToMES_(struct soap *soap, struct __ns1__SetDefectResultToMES_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetDefectResultToMES_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDefectInfoToSAP_(struct soap *soap, struct __ns1__GetDefectInfoToSAP_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDefectInfoToSAP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDefectInfoToSAP_(struct soap *soap, const struct __ns1__GetDefectInfoToSAP_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDefectInfoToSAP(soap, &a->ns1__GetDefectInfoToSAP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDefectInfoToSAP_(struct soap *soap, const char *tag, int id, const struct __ns1__GetDefectInfoToSAP_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDefectInfoToSAP(soap, "ns1:GetDefectInfoToSAP", -1, &a->ns1__GetDefectInfoToSAP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDefectInfoToSAP_ * SOAP_FMAC4 soap_in___ns1__GetDefectInfoToSAP_(struct soap *soap, const char *tag, struct __ns1__GetDefectInfoToSAP_ *a, const char *type)
{
	size_t soap_flag_ns1__GetDefectInfoToSAP = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDefectInfoToSAP_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDefectInfoToSAP_, sizeof(struct __ns1__GetDefectInfoToSAP_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDefectInfoToSAP_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDefectInfoToSAP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDefectInfoToSAP(soap, "ns1:GetDefectInfoToSAP", &a->ns1__GetDefectInfoToSAP, ""))
				{	soap_flag_ns1__GetDefectInfoToSAP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDefectInfoToSAP_ * SOAP_FMAC2 soap_instantiate___ns1__GetDefectInfoToSAP_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDefectInfoToSAP_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDefectInfoToSAP_ *p;
	size_t k = sizeof(struct __ns1__GetDefectInfoToSAP_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDefectInfoToSAP_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDefectInfoToSAP_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDefectInfoToSAP_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDefectInfoToSAP_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDefectInfoToSAP_(struct soap *soap, const struct __ns1__GetDefectInfoToSAP_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDefectInfoToSAP_(soap, tag ? tag : "-ns1:GetDefectInfoToSAP", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDefectInfoToSAP_ * SOAP_FMAC4 soap_get___ns1__GetDefectInfoToSAP_(struct soap *soap, struct __ns1__GetDefectInfoToSAP_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDefectInfoToSAP_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetFtpAddress_(struct soap *soap, struct __ns1__GetFtpAddress_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetFtpAddress = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetFtpAddress_(struct soap *soap, const struct __ns1__GetFtpAddress_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetFtpAddress(soap, &a->ns1__GetFtpAddress);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetFtpAddress_(struct soap *soap, const char *tag, int id, const struct __ns1__GetFtpAddress_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetFtpAddress(soap, "ns1:GetFtpAddress", -1, &a->ns1__GetFtpAddress, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFtpAddress_ * SOAP_FMAC4 soap_in___ns1__GetFtpAddress_(struct soap *soap, const char *tag, struct __ns1__GetFtpAddress_ *a, const char *type)
{
	size_t soap_flag_ns1__GetFtpAddress = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetFtpAddress_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetFtpAddress_, sizeof(struct __ns1__GetFtpAddress_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetFtpAddress_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetFtpAddress && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetFtpAddress(soap, "ns1:GetFtpAddress", &a->ns1__GetFtpAddress, ""))
				{	soap_flag_ns1__GetFtpAddress--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetFtpAddress_ * SOAP_FMAC2 soap_instantiate___ns1__GetFtpAddress_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetFtpAddress_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetFtpAddress_ *p;
	size_t k = sizeof(struct __ns1__GetFtpAddress_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetFtpAddress_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetFtpAddress_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetFtpAddress_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetFtpAddress_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetFtpAddress_(struct soap *soap, const struct __ns1__GetFtpAddress_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetFtpAddress_(soap, tag ? tag : "-ns1:GetFtpAddress", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFtpAddress_ * SOAP_FMAC4 soap_get___ns1__GetFtpAddress_(struct soap *soap, struct __ns1__GetFtpAddress_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetFtpAddress_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Iscalibrationcontainer_(struct soap *soap, struct __ns1__Iscalibrationcontainer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Iscalibrationcontainer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Iscalibrationcontainer_(struct soap *soap, const struct __ns1__Iscalibrationcontainer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Iscalibrationcontainer(soap, &a->ns1__Iscalibrationcontainer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Iscalibrationcontainer_(struct soap *soap, const char *tag, int id, const struct __ns1__Iscalibrationcontainer_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Iscalibrationcontainer(soap, "ns1:Iscalibrationcontainer", -1, &a->ns1__Iscalibrationcontainer, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Iscalibrationcontainer_ * SOAP_FMAC4 soap_in___ns1__Iscalibrationcontainer_(struct soap *soap, const char *tag, struct __ns1__Iscalibrationcontainer_ *a, const char *type)
{
	size_t soap_flag_ns1__Iscalibrationcontainer = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Iscalibrationcontainer_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Iscalibrationcontainer_, sizeof(struct __ns1__Iscalibrationcontainer_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Iscalibrationcontainer_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Iscalibrationcontainer && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Iscalibrationcontainer(soap, "ns1:Iscalibrationcontainer", &a->ns1__Iscalibrationcontainer, ""))
				{	soap_flag_ns1__Iscalibrationcontainer--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Iscalibrationcontainer_ * SOAP_FMAC2 soap_instantiate___ns1__Iscalibrationcontainer_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Iscalibrationcontainer_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Iscalibrationcontainer_ *p;
	size_t k = sizeof(struct __ns1__Iscalibrationcontainer_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Iscalibrationcontainer_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Iscalibrationcontainer_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Iscalibrationcontainer_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Iscalibrationcontainer_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Iscalibrationcontainer_(struct soap *soap, const struct __ns1__Iscalibrationcontainer_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Iscalibrationcontainer_(soap, tag ? tag : "-ns1:Iscalibrationcontainer", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Iscalibrationcontainer_ * SOAP_FMAC4 soap_get___ns1__Iscalibrationcontainer_(struct soap *soap, struct __ns1__Iscalibrationcontainer_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Iscalibrationcontainer_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTensileTestRule_(struct soap *soap, struct __ns1__GetTensileTestRule_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTensileTestRule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTensileTestRule_(struct soap *soap, const struct __ns1__GetTensileTestRule_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetTensileTestRule(soap, &a->ns1__GetTensileTestRule);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTensileTestRule_(struct soap *soap, const char *tag, int id, const struct __ns1__GetTensileTestRule_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetTensileTestRule(soap, "ns1:GetTensileTestRule", -1, &a->ns1__GetTensileTestRule, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTensileTestRule_ * SOAP_FMAC4 soap_in___ns1__GetTensileTestRule_(struct soap *soap, const char *tag, struct __ns1__GetTensileTestRule_ *a, const char *type)
{
	size_t soap_flag_ns1__GetTensileTestRule = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetTensileTestRule_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTensileTestRule_, sizeof(struct __ns1__GetTensileTestRule_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTensileTestRule_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTensileTestRule && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetTensileTestRule(soap, "ns1:GetTensileTestRule", &a->ns1__GetTensileTestRule, ""))
				{	soap_flag_ns1__GetTensileTestRule--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetTensileTestRule_ * SOAP_FMAC2 soap_instantiate___ns1__GetTensileTestRule_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTensileTestRule_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetTensileTestRule_ *p;
	size_t k = sizeof(struct __ns1__GetTensileTestRule_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetTensileTestRule_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetTensileTestRule_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetTensileTestRule_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetTensileTestRule_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTensileTestRule_(struct soap *soap, const struct __ns1__GetTensileTestRule_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetTensileTestRule_(soap, tag ? tag : "-ns1:GetTensileTestRule", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTensileTestRule_ * SOAP_FMAC4 soap_get___ns1__GetTensileTestRule_(struct soap *soap, struct __ns1__GetTensileTestRule_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTensileTestRule_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetContainerDataInfoMES_(struct soap *soap, struct __ns1__GetContainerDataInfoMES_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetContainerDataInfoMES = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetContainerDataInfoMES_(struct soap *soap, const struct __ns1__GetContainerDataInfoMES_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetContainerDataInfoMES(soap, &a->ns1__GetContainerDataInfoMES);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetContainerDataInfoMES_(struct soap *soap, const char *tag, int id, const struct __ns1__GetContainerDataInfoMES_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetContainerDataInfoMES(soap, "ns1:GetContainerDataInfoMES", -1, &a->ns1__GetContainerDataInfoMES, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetContainerDataInfoMES_ * SOAP_FMAC4 soap_in___ns1__GetContainerDataInfoMES_(struct soap *soap, const char *tag, struct __ns1__GetContainerDataInfoMES_ *a, const char *type)
{
	size_t soap_flag_ns1__GetContainerDataInfoMES = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetContainerDataInfoMES_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetContainerDataInfoMES_, sizeof(struct __ns1__GetContainerDataInfoMES_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetContainerDataInfoMES_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetContainerDataInfoMES && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetContainerDataInfoMES(soap, "ns1:GetContainerDataInfoMES", &a->ns1__GetContainerDataInfoMES, ""))
				{	soap_flag_ns1__GetContainerDataInfoMES--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetContainerDataInfoMES_ * SOAP_FMAC2 soap_instantiate___ns1__GetContainerDataInfoMES_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetContainerDataInfoMES_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetContainerDataInfoMES_ *p;
	size_t k = sizeof(struct __ns1__GetContainerDataInfoMES_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetContainerDataInfoMES_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetContainerDataInfoMES_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetContainerDataInfoMES_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetContainerDataInfoMES_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetContainerDataInfoMES_(struct soap *soap, const struct __ns1__GetContainerDataInfoMES_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetContainerDataInfoMES_(soap, tag ? tag : "-ns1:GetContainerDataInfoMES", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetContainerDataInfoMES_ * SOAP_FMAC4 soap_get___ns1__GetContainerDataInfoMES_(struct soap *soap, struct __ns1__GetContainerDataInfoMES_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetContainerDataInfoMES_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadTensileInfoToMes_(struct soap *soap, struct __ns1__UploadTensileInfoToMes_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UploadTensileInfoToMes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadTensileInfoToMes_(struct soap *soap, const struct __ns1__UploadTensileInfoToMes_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UploadTensileInfoToMes(soap, &a->ns1__UploadTensileInfoToMes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadTensileInfoToMes_(struct soap *soap, const char *tag, int id, const struct __ns1__UploadTensileInfoToMes_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UploadTensileInfoToMes(soap, "ns1:UploadTensileInfoToMes", -1, &a->ns1__UploadTensileInfoToMes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadTensileInfoToMes_ * SOAP_FMAC4 soap_in___ns1__UploadTensileInfoToMes_(struct soap *soap, const char *tag, struct __ns1__UploadTensileInfoToMes_ *a, const char *type)
{
	size_t soap_flag_ns1__UploadTensileInfoToMes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UploadTensileInfoToMes_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadTensileInfoToMes_, sizeof(struct __ns1__UploadTensileInfoToMes_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadTensileInfoToMes_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UploadTensileInfoToMes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UploadTensileInfoToMes(soap, "ns1:UploadTensileInfoToMes", &a->ns1__UploadTensileInfoToMes, ""))
				{	soap_flag_ns1__UploadTensileInfoToMes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UploadTensileInfoToMes_ * SOAP_FMAC2 soap_instantiate___ns1__UploadTensileInfoToMes_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadTensileInfoToMes_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UploadTensileInfoToMes_ *p;
	size_t k = sizeof(struct __ns1__UploadTensileInfoToMes_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__UploadTensileInfoToMes_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__UploadTensileInfoToMes_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__UploadTensileInfoToMes_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UploadTensileInfoToMes_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadTensileInfoToMes_(struct soap *soap, const struct __ns1__UploadTensileInfoToMes_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UploadTensileInfoToMes_(soap, tag ? tag : "-ns1:UploadTensileInfoToMes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadTensileInfoToMes_ * SOAP_FMAC4 soap_get___ns1__UploadTensileInfoToMes_(struct soap *soap, struct __ns1__UploadTensileInfoToMes_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadTensileInfoToMes_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SafetyInfoMoveStd_(struct soap *soap, struct __ns1__SafetyInfoMoveStd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SafetyInfoMoveStd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SafetyInfoMoveStd_(struct soap *soap, const struct __ns1__SafetyInfoMoveStd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SafetyInfoMoveStd(soap, &a->ns1__SafetyInfoMoveStd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SafetyInfoMoveStd_(struct soap *soap, const char *tag, int id, const struct __ns1__SafetyInfoMoveStd_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SafetyInfoMoveStd(soap, "ns1:SafetyInfoMoveStd", -1, &a->ns1__SafetyInfoMoveStd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SafetyInfoMoveStd_ * SOAP_FMAC4 soap_in___ns1__SafetyInfoMoveStd_(struct soap *soap, const char *tag, struct __ns1__SafetyInfoMoveStd_ *a, const char *type)
{
	size_t soap_flag_ns1__SafetyInfoMoveStd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SafetyInfoMoveStd_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SafetyInfoMoveStd_, sizeof(struct __ns1__SafetyInfoMoveStd_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SafetyInfoMoveStd_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SafetyInfoMoveStd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SafetyInfoMoveStd(soap, "ns1:SafetyInfoMoveStd", &a->ns1__SafetyInfoMoveStd, ""))
				{	soap_flag_ns1__SafetyInfoMoveStd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SafetyInfoMoveStd_ * SOAP_FMAC2 soap_instantiate___ns1__SafetyInfoMoveStd_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SafetyInfoMoveStd_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SafetyInfoMoveStd_ *p;
	size_t k = sizeof(struct __ns1__SafetyInfoMoveStd_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SafetyInfoMoveStd_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SafetyInfoMoveStd_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SafetyInfoMoveStd_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SafetyInfoMoveStd_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SafetyInfoMoveStd_(struct soap *soap, const struct __ns1__SafetyInfoMoveStd_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SafetyInfoMoveStd_(soap, tag ? tag : "-ns1:SafetyInfoMoveStd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SafetyInfoMoveStd_ * SOAP_FMAC4 soap_get___ns1__SafetyInfoMoveStd_(struct soap *soap, struct __ns1__SafetyInfoMoveStd_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SafetyInfoMoveStd_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ELInfoMoveStd_(struct soap *soap, struct __ns1__ELInfoMoveStd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ELInfoMoveStd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ELInfoMoveStd_(struct soap *soap, const struct __ns1__ELInfoMoveStd_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ELInfoMoveStd(soap, &a->ns1__ELInfoMoveStd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ELInfoMoveStd_(struct soap *soap, const char *tag, int id, const struct __ns1__ELInfoMoveStd_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ELInfoMoveStd(soap, "ns1:ELInfoMoveStd", -1, &a->ns1__ELInfoMoveStd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ELInfoMoveStd_ * SOAP_FMAC4 soap_in___ns1__ELInfoMoveStd_(struct soap *soap, const char *tag, struct __ns1__ELInfoMoveStd_ *a, const char *type)
{
	size_t soap_flag_ns1__ELInfoMoveStd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ELInfoMoveStd_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ELInfoMoveStd_, sizeof(struct __ns1__ELInfoMoveStd_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ELInfoMoveStd_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ELInfoMoveStd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ELInfoMoveStd(soap, "ns1:ELInfoMoveStd", &a->ns1__ELInfoMoveStd, ""))
				{	soap_flag_ns1__ELInfoMoveStd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ELInfoMoveStd_ * SOAP_FMAC2 soap_instantiate___ns1__ELInfoMoveStd_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ELInfoMoveStd_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ELInfoMoveStd_ *p;
	size_t k = sizeof(struct __ns1__ELInfoMoveStd_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ELInfoMoveStd_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ELInfoMoveStd_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ELInfoMoveStd_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ELInfoMoveStd_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ELInfoMoveStd_(struct soap *soap, const struct __ns1__ELInfoMoveStd_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ELInfoMoveStd_(soap, tag ? tag : "-ns1:ELInfoMoveStd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ELInfoMoveStd_ * SOAP_FMAC4 soap_get___ns1__ELInfoMoveStd_(struct soap *soap, struct __ns1__ELInfoMoveStd_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ELInfoMoveStd_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ELPictureAddress_(struct soap *soap, struct __ns1__ELPictureAddress_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ELPictureAddress = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ELPictureAddress_(struct soap *soap, const struct __ns1__ELPictureAddress_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ELPictureAddress(soap, &a->ns1__ELPictureAddress);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ELPictureAddress_(struct soap *soap, const char *tag, int id, const struct __ns1__ELPictureAddress_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ELPictureAddress(soap, "ns1:ELPictureAddress", -1, &a->ns1__ELPictureAddress, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ELPictureAddress_ * SOAP_FMAC4 soap_in___ns1__ELPictureAddress_(struct soap *soap, const char *tag, struct __ns1__ELPictureAddress_ *a, const char *type)
{
	size_t soap_flag_ns1__ELPictureAddress = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ELPictureAddress_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ELPictureAddress_, sizeof(struct __ns1__ELPictureAddress_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ELPictureAddress_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ELPictureAddress && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ELPictureAddress(soap, "ns1:ELPictureAddress", &a->ns1__ELPictureAddress, ""))
				{	soap_flag_ns1__ELPictureAddress--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ELPictureAddress_ * SOAP_FMAC2 soap_instantiate___ns1__ELPictureAddress_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ELPictureAddress_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ELPictureAddress_ *p;
	size_t k = sizeof(struct __ns1__ELPictureAddress_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ELPictureAddress_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ELPictureAddress_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ELPictureAddress_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ELPictureAddress_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ELPictureAddress_(struct soap *soap, const struct __ns1__ELPictureAddress_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ELPictureAddress_(soap, tag ? tag : "-ns1:ELPictureAddress", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ELPictureAddress_ * SOAP_FMAC4 soap_get___ns1__ELPictureAddress_(struct soap *soap, struct __ns1__ELPictureAddress_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ELPictureAddress_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__jKoIVMoveStd_USCORESpire_(struct soap *soap, struct __ns1__jKoIVMoveStd_USCORESpire_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__jKoIVMoveStd_USCORESpire = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__jKoIVMoveStd_USCORESpire_(struct soap *soap, const struct __ns1__jKoIVMoveStd_USCORESpire_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__jKoIVMoveStd_USCORESpire(soap, &a->ns1__jKoIVMoveStd_USCORESpire);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__jKoIVMoveStd_USCORESpire_(struct soap *soap, const char *tag, int id, const struct __ns1__jKoIVMoveStd_USCORESpire_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__jKoIVMoveStd_USCORESpire(soap, "ns1:jKoIVMoveStd_Spire", -1, &a->ns1__jKoIVMoveStd_USCORESpire, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jKoIVMoveStd_USCORESpire_ * SOAP_FMAC4 soap_in___ns1__jKoIVMoveStd_USCORESpire_(struct soap *soap, const char *tag, struct __ns1__jKoIVMoveStd_USCORESpire_ *a, const char *type)
{
	size_t soap_flag_ns1__jKoIVMoveStd_USCORESpire = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__jKoIVMoveStd_USCORESpire_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire_, sizeof(struct __ns1__jKoIVMoveStd_USCORESpire_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__jKoIVMoveStd_USCORESpire_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__jKoIVMoveStd_USCORESpire && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__jKoIVMoveStd_USCORESpire(soap, "ns1:jKoIVMoveStd_Spire", &a->ns1__jKoIVMoveStd_USCORESpire, ""))
				{	soap_flag_ns1__jKoIVMoveStd_USCORESpire--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__jKoIVMoveStd_USCORESpire_ * SOAP_FMAC2 soap_instantiate___ns1__jKoIVMoveStd_USCORESpire_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__jKoIVMoveStd_USCORESpire_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__jKoIVMoveStd_USCORESpire_ *p;
	size_t k = sizeof(struct __ns1__jKoIVMoveStd_USCORESpire_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__jKoIVMoveStd_USCORESpire_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__jKoIVMoveStd_USCORESpire_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__jKoIVMoveStd_USCORESpire_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__jKoIVMoveStd_USCORESpire_(struct soap *soap, const struct __ns1__jKoIVMoveStd_USCORESpire_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__jKoIVMoveStd_USCORESpire_(soap, tag ? tag : "-ns1:jKoIVMoveStd_Spire", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jKoIVMoveStd_USCORESpire_ * SOAP_FMAC4 soap_get___ns1__jKoIVMoveStd_USCORESpire_(struct soap *soap, struct __ns1__jKoIVMoveStd_USCORESpire_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__jKoIVMoveStd_USCORESpire_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__jKoIVMoveStd_USCOREPasan_(struct soap *soap, struct __ns1__jKoIVMoveStd_USCOREPasan_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__jKoIVMoveStd_USCOREPasan = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__jKoIVMoveStd_USCOREPasan_(struct soap *soap, const struct __ns1__jKoIVMoveStd_USCOREPasan_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(soap, &a->ns1__jKoIVMoveStd_USCOREPasan);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__jKoIVMoveStd_USCOREPasan_(struct soap *soap, const char *tag, int id, const struct __ns1__jKoIVMoveStd_USCOREPasan_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(soap, "ns1:jKoIVMoveStd_Pasan", -1, &a->ns1__jKoIVMoveStd_USCOREPasan, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jKoIVMoveStd_USCOREPasan_ * SOAP_FMAC4 soap_in___ns1__jKoIVMoveStd_USCOREPasan_(struct soap *soap, const char *tag, struct __ns1__jKoIVMoveStd_USCOREPasan_ *a, const char *type)
{
	size_t soap_flag_ns1__jKoIVMoveStd_USCOREPasan = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__jKoIVMoveStd_USCOREPasan_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan_, sizeof(struct __ns1__jKoIVMoveStd_USCOREPasan_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__jKoIVMoveStd_USCOREPasan_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__jKoIVMoveStd_USCOREPasan && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(soap, "ns1:jKoIVMoveStd_Pasan", &a->ns1__jKoIVMoveStd_USCOREPasan, ""))
				{	soap_flag_ns1__jKoIVMoveStd_USCOREPasan--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__jKoIVMoveStd_USCOREPasan_ * SOAP_FMAC2 soap_instantiate___ns1__jKoIVMoveStd_USCOREPasan_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__jKoIVMoveStd_USCOREPasan_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__jKoIVMoveStd_USCOREPasan_ *p;
	size_t k = sizeof(struct __ns1__jKoIVMoveStd_USCOREPasan_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__jKoIVMoveStd_USCOREPasan_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__jKoIVMoveStd_USCOREPasan_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__jKoIVMoveStd_USCOREPasan_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__jKoIVMoveStd_USCOREPasan_(struct soap *soap, const struct __ns1__jKoIVMoveStd_USCOREPasan_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__jKoIVMoveStd_USCOREPasan_(soap, tag ? tag : "-ns1:jKoIVMoveStd_Pasan", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jKoIVMoveStd_USCOREPasan_ * SOAP_FMAC4 soap_get___ns1__jKoIVMoveStd_USCOREPasan_(struct soap *soap, struct __ns1__jKoIVMoveStd_USCOREPasan_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__jKoIVMoveStd_USCOREPasan_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__IV_USCOREDataCollection_(struct soap *soap, struct __ns1__IV_USCOREDataCollection_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__IV_USCOREDataCollection = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__IV_USCOREDataCollection_(struct soap *soap, const struct __ns1__IV_USCOREDataCollection_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__IV_USCOREDataCollection(soap, &a->ns1__IV_USCOREDataCollection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__IV_USCOREDataCollection_(struct soap *soap, const char *tag, int id, const struct __ns1__IV_USCOREDataCollection_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__IV_USCOREDataCollection(soap, "ns1:IV_DataCollection", -1, &a->ns1__IV_USCOREDataCollection, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IV_USCOREDataCollection_ * SOAP_FMAC4 soap_in___ns1__IV_USCOREDataCollection_(struct soap *soap, const char *tag, struct __ns1__IV_USCOREDataCollection_ *a, const char *type)
{
	size_t soap_flag_ns1__IV_USCOREDataCollection = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__IV_USCOREDataCollection_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__IV_USCOREDataCollection_, sizeof(struct __ns1__IV_USCOREDataCollection_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__IV_USCOREDataCollection_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__IV_USCOREDataCollection && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__IV_USCOREDataCollection(soap, "ns1:IV_DataCollection", &a->ns1__IV_USCOREDataCollection, ""))
				{	soap_flag_ns1__IV_USCOREDataCollection--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__IV_USCOREDataCollection_ * SOAP_FMAC2 soap_instantiate___ns1__IV_USCOREDataCollection_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__IV_USCOREDataCollection_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__IV_USCOREDataCollection_ *p;
	size_t k = sizeof(struct __ns1__IV_USCOREDataCollection_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__IV_USCOREDataCollection_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__IV_USCOREDataCollection_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__IV_USCOREDataCollection_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__IV_USCOREDataCollection_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__IV_USCOREDataCollection_(struct soap *soap, const struct __ns1__IV_USCOREDataCollection_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__IV_USCOREDataCollection_(soap, tag ? tag : "-ns1:IV_DataCollection", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IV_USCOREDataCollection_ * SOAP_FMAC4 soap_get___ns1__IV_USCOREDataCollection_(struct soap *soap, struct __ns1__IV_USCOREDataCollection_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__IV_USCOREDataCollection_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetCurrentSpecBySn_(struct soap *soap, struct __ns1__GetCurrentSpecBySn_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetCurrentSpecBySn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetCurrentSpecBySn_(struct soap *soap, const struct __ns1__GetCurrentSpecBySn_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetCurrentSpecBySn(soap, &a->ns1__GetCurrentSpecBySn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetCurrentSpecBySn_(struct soap *soap, const char *tag, int id, const struct __ns1__GetCurrentSpecBySn_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetCurrentSpecBySn(soap, "ns1:GetCurrentSpecBySn", -1, &a->ns1__GetCurrentSpecBySn, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetCurrentSpecBySn_ * SOAP_FMAC4 soap_in___ns1__GetCurrentSpecBySn_(struct soap *soap, const char *tag, struct __ns1__GetCurrentSpecBySn_ *a, const char *type)
{
	size_t soap_flag_ns1__GetCurrentSpecBySn = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetCurrentSpecBySn_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetCurrentSpecBySn_, sizeof(struct __ns1__GetCurrentSpecBySn_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetCurrentSpecBySn_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetCurrentSpecBySn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetCurrentSpecBySn(soap, "ns1:GetCurrentSpecBySn", &a->ns1__GetCurrentSpecBySn, ""))
				{	soap_flag_ns1__GetCurrentSpecBySn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetCurrentSpecBySn_ * SOAP_FMAC2 soap_instantiate___ns1__GetCurrentSpecBySn_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetCurrentSpecBySn_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetCurrentSpecBySn_ *p;
	size_t k = sizeof(struct __ns1__GetCurrentSpecBySn_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetCurrentSpecBySn_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetCurrentSpecBySn_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetCurrentSpecBySn_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetCurrentSpecBySn_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetCurrentSpecBySn_(struct soap *soap, const struct __ns1__GetCurrentSpecBySn_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetCurrentSpecBySn_(soap, tag ? tag : "-ns1:GetCurrentSpecBySn", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetCurrentSpecBySn_ * SOAP_FMAC4 soap_get___ns1__GetCurrentSpecBySn_(struct soap *soap, struct __ns1__GetCurrentSpecBySn_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetCurrentSpecBySn_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetWorkCenterID_(struct soap *soap, struct __ns1__GetWorkCenterID_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetWorkCenterID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetWorkCenterID_(struct soap *soap, const struct __ns1__GetWorkCenterID_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetWorkCenterID(soap, &a->ns1__GetWorkCenterID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetWorkCenterID_(struct soap *soap, const char *tag, int id, const struct __ns1__GetWorkCenterID_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetWorkCenterID(soap, "ns1:GetWorkCenterID", -1, &a->ns1__GetWorkCenterID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetWorkCenterID_ * SOAP_FMAC4 soap_in___ns1__GetWorkCenterID_(struct soap *soap, const char *tag, struct __ns1__GetWorkCenterID_ *a, const char *type)
{
	size_t soap_flag_ns1__GetWorkCenterID = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetWorkCenterID_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetWorkCenterID_, sizeof(struct __ns1__GetWorkCenterID_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetWorkCenterID_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetWorkCenterID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetWorkCenterID(soap, "ns1:GetWorkCenterID", &a->ns1__GetWorkCenterID, ""))
				{	soap_flag_ns1__GetWorkCenterID--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetWorkCenterID_ * SOAP_FMAC2 soap_instantiate___ns1__GetWorkCenterID_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetWorkCenterID_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetWorkCenterID_ *p;
	size_t k = sizeof(struct __ns1__GetWorkCenterID_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetWorkCenterID_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetWorkCenterID_);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetWorkCenterID_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetWorkCenterID_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetWorkCenterID_(struct soap *soap, const struct __ns1__GetWorkCenterID_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetWorkCenterID_(soap, tag ? tag : "-ns1:GetWorkCenterID", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetWorkCenterID_ * SOAP_FMAC4 soap_get___ns1__GetWorkCenterID_(struct soap *soap, struct __ns1__GetWorkCenterID_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetWorkCenterID_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Login(struct soap *soap, struct __ns1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Login(struct soap *soap, const struct __ns1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Login(soap, &a->ns1__Login);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Login(struct soap *soap, const char *tag, int id, const struct __ns1__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Login(soap, "ns1:Login", -1, &a->ns1__Login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login * SOAP_FMAC4 soap_in___ns1__Login(struct soap *soap, const char *tag, struct __ns1__Login *a, const char *type)
{
	size_t soap_flag_ns1__Login = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Login *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Login, sizeof(struct __ns1__Login), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Login && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Login(soap, "ns1:Login", &a->ns1__Login, ""))
				{	soap_flag_ns1__Login--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Login * SOAP_FMAC2 soap_instantiate___ns1__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Login(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Login *p;
	size_t k = sizeof(struct __ns1__Login);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Login, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Login);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Login, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Login location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Login(struct soap *soap, const struct __ns1__Login *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Login(soap, tag ? tag : "-ns1:Login", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login * SOAP_FMAC4 soap_get___ns1__Login(struct soap *soap, struct __ns1__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CanLogin(struct soap *soap, struct __ns1__CanLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CanLogin = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CanLogin(struct soap *soap, const struct __ns1__CanLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CanLogin(soap, &a->ns1__CanLogin);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CanLogin(struct soap *soap, const char *tag, int id, const struct __ns1__CanLogin *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CanLogin(soap, "ns1:CanLogin", -1, &a->ns1__CanLogin, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CanLogin * SOAP_FMAC4 soap_in___ns1__CanLogin(struct soap *soap, const char *tag, struct __ns1__CanLogin *a, const char *type)
{
	size_t soap_flag_ns1__CanLogin = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CanLogin *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CanLogin, sizeof(struct __ns1__CanLogin), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CanLogin(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CanLogin && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__CanLogin(soap, "ns1:CanLogin", &a->ns1__CanLogin, ""))
				{	soap_flag_ns1__CanLogin--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CanLogin * SOAP_FMAC2 soap_instantiate___ns1__CanLogin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CanLogin(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CanLogin *p;
	size_t k = sizeof(struct __ns1__CanLogin);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__CanLogin, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__CanLogin);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__CanLogin, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CanLogin location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CanLogin(struct soap *soap, const struct __ns1__CanLogin *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CanLogin(soap, tag ? tag : "-ns1:CanLogin", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CanLogin * SOAP_FMAC4 soap_get___ns1__CanLogin(struct soap *soap, struct __ns1__CanLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CanLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, const struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, &a->ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, const char *tag, int id, const struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, "ns1:Upload_FIDWUL_DATAFLAGs", -1, &a->ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs * SOAP_FMAC4 soap_in___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, const char *tag, struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *a, const char *type)
{
	size_t soap_flag_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, sizeof(struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, "ns1:Upload_FIDWUL_DATAFLAGs", &a->ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, ""))
				{	soap_flag_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs * SOAP_FMAC2 soap_instantiate___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *p;
	size_t k = sizeof(struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, const struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, tag ? tag : "-ns1:Upload_FIDWUL_DATAFLAGs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs * SOAP_FMAC4 soap_get___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetMaterialBatchResultToMES(struct soap *soap, struct __ns1__SetMaterialBatchResultToMES *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetMaterialBatchResultToMES = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetMaterialBatchResultToMES(struct soap *soap, const struct __ns1__SetMaterialBatchResultToMES *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetMaterialBatchResultToMES(soap, &a->ns1__SetMaterialBatchResultToMES);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetMaterialBatchResultToMES(struct soap *soap, const char *tag, int id, const struct __ns1__SetMaterialBatchResultToMES *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetMaterialBatchResultToMES(soap, "ns1:SetMaterialBatchResultToMES", -1, &a->ns1__SetMaterialBatchResultToMES, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetMaterialBatchResultToMES * SOAP_FMAC4 soap_in___ns1__SetMaterialBatchResultToMES(struct soap *soap, const char *tag, struct __ns1__SetMaterialBatchResultToMES *a, const char *type)
{
	size_t soap_flag_ns1__SetMaterialBatchResultToMES = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SetMaterialBatchResultToMES *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetMaterialBatchResultToMES, sizeof(struct __ns1__SetMaterialBatchResultToMES), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetMaterialBatchResultToMES(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetMaterialBatchResultToMES && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SetMaterialBatchResultToMES(soap, "ns1:SetMaterialBatchResultToMES", &a->ns1__SetMaterialBatchResultToMES, ""))
				{	soap_flag_ns1__SetMaterialBatchResultToMES--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SetMaterialBatchResultToMES * SOAP_FMAC2 soap_instantiate___ns1__SetMaterialBatchResultToMES(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetMaterialBatchResultToMES(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SetMaterialBatchResultToMES *p;
	size_t k = sizeof(struct __ns1__SetMaterialBatchResultToMES);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SetMaterialBatchResultToMES, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SetMaterialBatchResultToMES);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SetMaterialBatchResultToMES, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SetMaterialBatchResultToMES location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetMaterialBatchResultToMES(struct soap *soap, const struct __ns1__SetMaterialBatchResultToMES *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SetMaterialBatchResultToMES(soap, tag ? tag : "-ns1:SetMaterialBatchResultToMES", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetMaterialBatchResultToMES * SOAP_FMAC4 soap_get___ns1__SetMaterialBatchResultToMES(struct soap *soap, struct __ns1__SetMaterialBatchResultToMES *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetMaterialBatchResultToMES(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SetDefectResultToMES(struct soap *soap, struct __ns1__SetDefectResultToMES *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SetDefectResultToMES = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SetDefectResultToMES(struct soap *soap, const struct __ns1__SetDefectResultToMES *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SetDefectResultToMES(soap, &a->ns1__SetDefectResultToMES);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SetDefectResultToMES(struct soap *soap, const char *tag, int id, const struct __ns1__SetDefectResultToMES *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SetDefectResultToMES(soap, "ns1:SetDefectResultToMES", -1, &a->ns1__SetDefectResultToMES, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetDefectResultToMES * SOAP_FMAC4 soap_in___ns1__SetDefectResultToMES(struct soap *soap, const char *tag, struct __ns1__SetDefectResultToMES *a, const char *type)
{
	size_t soap_flag_ns1__SetDefectResultToMES = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SetDefectResultToMES *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SetDefectResultToMES, sizeof(struct __ns1__SetDefectResultToMES), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SetDefectResultToMES(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SetDefectResultToMES && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SetDefectResultToMES(soap, "ns1:SetDefectResultToMES", &a->ns1__SetDefectResultToMES, ""))
				{	soap_flag_ns1__SetDefectResultToMES--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SetDefectResultToMES * SOAP_FMAC2 soap_instantiate___ns1__SetDefectResultToMES(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SetDefectResultToMES(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SetDefectResultToMES *p;
	size_t k = sizeof(struct __ns1__SetDefectResultToMES);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SetDefectResultToMES, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SetDefectResultToMES);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SetDefectResultToMES, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SetDefectResultToMES location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SetDefectResultToMES(struct soap *soap, const struct __ns1__SetDefectResultToMES *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SetDefectResultToMES(soap, tag ? tag : "-ns1:SetDefectResultToMES", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SetDefectResultToMES * SOAP_FMAC4 soap_get___ns1__SetDefectResultToMES(struct soap *soap, struct __ns1__SetDefectResultToMES *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SetDefectResultToMES(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetDefectInfoToSAP(struct soap *soap, struct __ns1__GetDefectInfoToSAP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetDefectInfoToSAP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetDefectInfoToSAP(struct soap *soap, const struct __ns1__GetDefectInfoToSAP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetDefectInfoToSAP(soap, &a->ns1__GetDefectInfoToSAP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetDefectInfoToSAP(struct soap *soap, const char *tag, int id, const struct __ns1__GetDefectInfoToSAP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetDefectInfoToSAP(soap, "ns1:GetDefectInfoToSAP", -1, &a->ns1__GetDefectInfoToSAP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDefectInfoToSAP * SOAP_FMAC4 soap_in___ns1__GetDefectInfoToSAP(struct soap *soap, const char *tag, struct __ns1__GetDefectInfoToSAP *a, const char *type)
{
	size_t soap_flag_ns1__GetDefectInfoToSAP = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetDefectInfoToSAP *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetDefectInfoToSAP, sizeof(struct __ns1__GetDefectInfoToSAP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetDefectInfoToSAP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetDefectInfoToSAP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetDefectInfoToSAP(soap, "ns1:GetDefectInfoToSAP", &a->ns1__GetDefectInfoToSAP, ""))
				{	soap_flag_ns1__GetDefectInfoToSAP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetDefectInfoToSAP * SOAP_FMAC2 soap_instantiate___ns1__GetDefectInfoToSAP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetDefectInfoToSAP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetDefectInfoToSAP *p;
	size_t k = sizeof(struct __ns1__GetDefectInfoToSAP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetDefectInfoToSAP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetDefectInfoToSAP);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetDefectInfoToSAP, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetDefectInfoToSAP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetDefectInfoToSAP(struct soap *soap, const struct __ns1__GetDefectInfoToSAP *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetDefectInfoToSAP(soap, tag ? tag : "-ns1:GetDefectInfoToSAP", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetDefectInfoToSAP * SOAP_FMAC4 soap_get___ns1__GetDefectInfoToSAP(struct soap *soap, struct __ns1__GetDefectInfoToSAP *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetDefectInfoToSAP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetFtpAddress(struct soap *soap, struct __ns1__GetFtpAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetFtpAddress = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetFtpAddress(struct soap *soap, const struct __ns1__GetFtpAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetFtpAddress(soap, &a->ns1__GetFtpAddress);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetFtpAddress(struct soap *soap, const char *tag, int id, const struct __ns1__GetFtpAddress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetFtpAddress(soap, "ns1:GetFtpAddress", -1, &a->ns1__GetFtpAddress, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFtpAddress * SOAP_FMAC4 soap_in___ns1__GetFtpAddress(struct soap *soap, const char *tag, struct __ns1__GetFtpAddress *a, const char *type)
{
	size_t soap_flag_ns1__GetFtpAddress = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetFtpAddress *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetFtpAddress, sizeof(struct __ns1__GetFtpAddress), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetFtpAddress(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetFtpAddress && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetFtpAddress(soap, "ns1:GetFtpAddress", &a->ns1__GetFtpAddress, ""))
				{	soap_flag_ns1__GetFtpAddress--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetFtpAddress * SOAP_FMAC2 soap_instantiate___ns1__GetFtpAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetFtpAddress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetFtpAddress *p;
	size_t k = sizeof(struct __ns1__GetFtpAddress);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetFtpAddress, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetFtpAddress);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetFtpAddress, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetFtpAddress location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetFtpAddress(struct soap *soap, const struct __ns1__GetFtpAddress *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetFtpAddress(soap, tag ? tag : "-ns1:GetFtpAddress", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetFtpAddress * SOAP_FMAC4 soap_get___ns1__GetFtpAddress(struct soap *soap, struct __ns1__GetFtpAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetFtpAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Iscalibrationcontainer(struct soap *soap, struct __ns1__Iscalibrationcontainer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Iscalibrationcontainer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Iscalibrationcontainer(struct soap *soap, const struct __ns1__Iscalibrationcontainer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Iscalibrationcontainer(soap, &a->ns1__Iscalibrationcontainer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Iscalibrationcontainer(struct soap *soap, const char *tag, int id, const struct __ns1__Iscalibrationcontainer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Iscalibrationcontainer(soap, "ns1:Iscalibrationcontainer", -1, &a->ns1__Iscalibrationcontainer, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Iscalibrationcontainer * SOAP_FMAC4 soap_in___ns1__Iscalibrationcontainer(struct soap *soap, const char *tag, struct __ns1__Iscalibrationcontainer *a, const char *type)
{
	size_t soap_flag_ns1__Iscalibrationcontainer = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Iscalibrationcontainer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Iscalibrationcontainer, sizeof(struct __ns1__Iscalibrationcontainer), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Iscalibrationcontainer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Iscalibrationcontainer && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__Iscalibrationcontainer(soap, "ns1:Iscalibrationcontainer", &a->ns1__Iscalibrationcontainer, ""))
				{	soap_flag_ns1__Iscalibrationcontainer--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Iscalibrationcontainer * SOAP_FMAC2 soap_instantiate___ns1__Iscalibrationcontainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Iscalibrationcontainer(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Iscalibrationcontainer *p;
	size_t k = sizeof(struct __ns1__Iscalibrationcontainer);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__Iscalibrationcontainer, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__Iscalibrationcontainer);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__Iscalibrationcontainer, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Iscalibrationcontainer location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Iscalibrationcontainer(struct soap *soap, const struct __ns1__Iscalibrationcontainer *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Iscalibrationcontainer(soap, tag ? tag : "-ns1:Iscalibrationcontainer", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Iscalibrationcontainer * SOAP_FMAC4 soap_get___ns1__Iscalibrationcontainer(struct soap *soap, struct __ns1__Iscalibrationcontainer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Iscalibrationcontainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetTensileTestRule(struct soap *soap, struct __ns1__GetTensileTestRule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetTensileTestRule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetTensileTestRule(struct soap *soap, const struct __ns1__GetTensileTestRule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetTensileTestRule(soap, &a->ns1__GetTensileTestRule);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetTensileTestRule(struct soap *soap, const char *tag, int id, const struct __ns1__GetTensileTestRule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetTensileTestRule(soap, "ns1:GetTensileTestRule", -1, &a->ns1__GetTensileTestRule, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTensileTestRule * SOAP_FMAC4 soap_in___ns1__GetTensileTestRule(struct soap *soap, const char *tag, struct __ns1__GetTensileTestRule *a, const char *type)
{
	size_t soap_flag_ns1__GetTensileTestRule = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetTensileTestRule *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetTensileTestRule, sizeof(struct __ns1__GetTensileTestRule), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetTensileTestRule(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetTensileTestRule && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetTensileTestRule(soap, "ns1:GetTensileTestRule", &a->ns1__GetTensileTestRule, ""))
				{	soap_flag_ns1__GetTensileTestRule--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetTensileTestRule * SOAP_FMAC2 soap_instantiate___ns1__GetTensileTestRule(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetTensileTestRule(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetTensileTestRule *p;
	size_t k = sizeof(struct __ns1__GetTensileTestRule);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetTensileTestRule, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetTensileTestRule);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetTensileTestRule, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetTensileTestRule location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetTensileTestRule(struct soap *soap, const struct __ns1__GetTensileTestRule *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetTensileTestRule(soap, tag ? tag : "-ns1:GetTensileTestRule", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetTensileTestRule * SOAP_FMAC4 soap_get___ns1__GetTensileTestRule(struct soap *soap, struct __ns1__GetTensileTestRule *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetTensileTestRule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetContainerDataInfoMES(struct soap *soap, struct __ns1__GetContainerDataInfoMES *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetContainerDataInfoMES = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetContainerDataInfoMES(struct soap *soap, const struct __ns1__GetContainerDataInfoMES *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetContainerDataInfoMES(soap, &a->ns1__GetContainerDataInfoMES);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetContainerDataInfoMES(struct soap *soap, const char *tag, int id, const struct __ns1__GetContainerDataInfoMES *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetContainerDataInfoMES(soap, "ns1:GetContainerDataInfoMES", -1, &a->ns1__GetContainerDataInfoMES, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetContainerDataInfoMES * SOAP_FMAC4 soap_in___ns1__GetContainerDataInfoMES(struct soap *soap, const char *tag, struct __ns1__GetContainerDataInfoMES *a, const char *type)
{
	size_t soap_flag_ns1__GetContainerDataInfoMES = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetContainerDataInfoMES *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetContainerDataInfoMES, sizeof(struct __ns1__GetContainerDataInfoMES), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetContainerDataInfoMES(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetContainerDataInfoMES && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetContainerDataInfoMES(soap, "ns1:GetContainerDataInfoMES", &a->ns1__GetContainerDataInfoMES, ""))
				{	soap_flag_ns1__GetContainerDataInfoMES--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetContainerDataInfoMES * SOAP_FMAC2 soap_instantiate___ns1__GetContainerDataInfoMES(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetContainerDataInfoMES(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetContainerDataInfoMES *p;
	size_t k = sizeof(struct __ns1__GetContainerDataInfoMES);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetContainerDataInfoMES, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetContainerDataInfoMES);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetContainerDataInfoMES, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetContainerDataInfoMES location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetContainerDataInfoMES(struct soap *soap, const struct __ns1__GetContainerDataInfoMES *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetContainerDataInfoMES(soap, tag ? tag : "-ns1:GetContainerDataInfoMES", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetContainerDataInfoMES * SOAP_FMAC4 soap_get___ns1__GetContainerDataInfoMES(struct soap *soap, struct __ns1__GetContainerDataInfoMES *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetContainerDataInfoMES(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadTensileInfoToMes(struct soap *soap, struct __ns1__UploadTensileInfoToMes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UploadTensileInfoToMes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadTensileInfoToMes(struct soap *soap, const struct __ns1__UploadTensileInfoToMes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UploadTensileInfoToMes(soap, &a->ns1__UploadTensileInfoToMes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadTensileInfoToMes(struct soap *soap, const char *tag, int id, const struct __ns1__UploadTensileInfoToMes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UploadTensileInfoToMes(soap, "ns1:UploadTensileInfoToMes", -1, &a->ns1__UploadTensileInfoToMes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadTensileInfoToMes * SOAP_FMAC4 soap_in___ns1__UploadTensileInfoToMes(struct soap *soap, const char *tag, struct __ns1__UploadTensileInfoToMes *a, const char *type)
{
	size_t soap_flag_ns1__UploadTensileInfoToMes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UploadTensileInfoToMes *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadTensileInfoToMes, sizeof(struct __ns1__UploadTensileInfoToMes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadTensileInfoToMes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UploadTensileInfoToMes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__UploadTensileInfoToMes(soap, "ns1:UploadTensileInfoToMes", &a->ns1__UploadTensileInfoToMes, ""))
				{	soap_flag_ns1__UploadTensileInfoToMes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__UploadTensileInfoToMes * SOAP_FMAC2 soap_instantiate___ns1__UploadTensileInfoToMes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadTensileInfoToMes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__UploadTensileInfoToMes *p;
	size_t k = sizeof(struct __ns1__UploadTensileInfoToMes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__UploadTensileInfoToMes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__UploadTensileInfoToMes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__UploadTensileInfoToMes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__UploadTensileInfoToMes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadTensileInfoToMes(struct soap *soap, const struct __ns1__UploadTensileInfoToMes *a, const char *tag, const char *type)
{
	if (soap_out___ns1__UploadTensileInfoToMes(soap, tag ? tag : "-ns1:UploadTensileInfoToMes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadTensileInfoToMes * SOAP_FMAC4 soap_get___ns1__UploadTensileInfoToMes(struct soap *soap, struct __ns1__UploadTensileInfoToMes *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadTensileInfoToMes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SafetyInfoMoveStd(struct soap *soap, struct __ns1__SafetyInfoMoveStd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SafetyInfoMoveStd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SafetyInfoMoveStd(struct soap *soap, const struct __ns1__SafetyInfoMoveStd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SafetyInfoMoveStd(soap, &a->ns1__SafetyInfoMoveStd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SafetyInfoMoveStd(struct soap *soap, const char *tag, int id, const struct __ns1__SafetyInfoMoveStd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SafetyInfoMoveStd(soap, "ns1:SafetyInfoMoveStd", -1, &a->ns1__SafetyInfoMoveStd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SafetyInfoMoveStd * SOAP_FMAC4 soap_in___ns1__SafetyInfoMoveStd(struct soap *soap, const char *tag, struct __ns1__SafetyInfoMoveStd *a, const char *type)
{
	size_t soap_flag_ns1__SafetyInfoMoveStd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SafetyInfoMoveStd *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SafetyInfoMoveStd, sizeof(struct __ns1__SafetyInfoMoveStd), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SafetyInfoMoveStd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SafetyInfoMoveStd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__SafetyInfoMoveStd(soap, "ns1:SafetyInfoMoveStd", &a->ns1__SafetyInfoMoveStd, ""))
				{	soap_flag_ns1__SafetyInfoMoveStd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__SafetyInfoMoveStd * SOAP_FMAC2 soap_instantiate___ns1__SafetyInfoMoveStd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SafetyInfoMoveStd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__SafetyInfoMoveStd *p;
	size_t k = sizeof(struct __ns1__SafetyInfoMoveStd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__SafetyInfoMoveStd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__SafetyInfoMoveStd);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__SafetyInfoMoveStd, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__SafetyInfoMoveStd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SafetyInfoMoveStd(struct soap *soap, const struct __ns1__SafetyInfoMoveStd *a, const char *tag, const char *type)
{
	if (soap_out___ns1__SafetyInfoMoveStd(soap, tag ? tag : "-ns1:SafetyInfoMoveStd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SafetyInfoMoveStd * SOAP_FMAC4 soap_get___ns1__SafetyInfoMoveStd(struct soap *soap, struct __ns1__SafetyInfoMoveStd *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SafetyInfoMoveStd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ELInfoMoveStd(struct soap *soap, struct __ns1__ELInfoMoveStd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ELInfoMoveStd = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ELInfoMoveStd(struct soap *soap, const struct __ns1__ELInfoMoveStd *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ELInfoMoveStd(soap, &a->ns1__ELInfoMoveStd);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ELInfoMoveStd(struct soap *soap, const char *tag, int id, const struct __ns1__ELInfoMoveStd *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ELInfoMoveStd(soap, "ns1:ELInfoMoveStd", -1, &a->ns1__ELInfoMoveStd, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ELInfoMoveStd * SOAP_FMAC4 soap_in___ns1__ELInfoMoveStd(struct soap *soap, const char *tag, struct __ns1__ELInfoMoveStd *a, const char *type)
{
	size_t soap_flag_ns1__ELInfoMoveStd = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ELInfoMoveStd *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ELInfoMoveStd, sizeof(struct __ns1__ELInfoMoveStd), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ELInfoMoveStd(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ELInfoMoveStd && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ELInfoMoveStd(soap, "ns1:ELInfoMoveStd", &a->ns1__ELInfoMoveStd, ""))
				{	soap_flag_ns1__ELInfoMoveStd--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ELInfoMoveStd * SOAP_FMAC2 soap_instantiate___ns1__ELInfoMoveStd(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ELInfoMoveStd(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ELInfoMoveStd *p;
	size_t k = sizeof(struct __ns1__ELInfoMoveStd);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ELInfoMoveStd, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ELInfoMoveStd);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ELInfoMoveStd, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ELInfoMoveStd location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ELInfoMoveStd(struct soap *soap, const struct __ns1__ELInfoMoveStd *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ELInfoMoveStd(soap, tag ? tag : "-ns1:ELInfoMoveStd", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ELInfoMoveStd * SOAP_FMAC4 soap_get___ns1__ELInfoMoveStd(struct soap *soap, struct __ns1__ELInfoMoveStd *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ELInfoMoveStd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ELPictureAddress(struct soap *soap, struct __ns1__ELPictureAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ELPictureAddress = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ELPictureAddress(struct soap *soap, const struct __ns1__ELPictureAddress *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ELPictureAddress(soap, &a->ns1__ELPictureAddress);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ELPictureAddress(struct soap *soap, const char *tag, int id, const struct __ns1__ELPictureAddress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ELPictureAddress(soap, "ns1:ELPictureAddress", -1, &a->ns1__ELPictureAddress, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ELPictureAddress * SOAP_FMAC4 soap_in___ns1__ELPictureAddress(struct soap *soap, const char *tag, struct __ns1__ELPictureAddress *a, const char *type)
{
	size_t soap_flag_ns1__ELPictureAddress = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ELPictureAddress *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ELPictureAddress, sizeof(struct __ns1__ELPictureAddress), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ELPictureAddress(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ELPictureAddress && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__ELPictureAddress(soap, "ns1:ELPictureAddress", &a->ns1__ELPictureAddress, ""))
				{	soap_flag_ns1__ELPictureAddress--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ELPictureAddress * SOAP_FMAC2 soap_instantiate___ns1__ELPictureAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ELPictureAddress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ELPictureAddress *p;
	size_t k = sizeof(struct __ns1__ELPictureAddress);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__ELPictureAddress, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__ELPictureAddress);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__ELPictureAddress, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ELPictureAddress location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ELPictureAddress(struct soap *soap, const struct __ns1__ELPictureAddress *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ELPictureAddress(soap, tag ? tag : "-ns1:ELPictureAddress", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ELPictureAddress * SOAP_FMAC4 soap_get___ns1__ELPictureAddress(struct soap *soap, struct __ns1__ELPictureAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ELPictureAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, struct __ns1__jKoIVMoveStd_USCORESpire *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__jKoIVMoveStd_USCORESpire = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, const struct __ns1__jKoIVMoveStd_USCORESpire *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__jKoIVMoveStd_USCORESpire(soap, &a->ns1__jKoIVMoveStd_USCORESpire);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, const char *tag, int id, const struct __ns1__jKoIVMoveStd_USCORESpire *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__jKoIVMoveStd_USCORESpire(soap, "ns1:jKoIVMoveStd_Spire", -1, &a->ns1__jKoIVMoveStd_USCORESpire, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jKoIVMoveStd_USCORESpire * SOAP_FMAC4 soap_in___ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, const char *tag, struct __ns1__jKoIVMoveStd_USCORESpire *a, const char *type)
{
	size_t soap_flag_ns1__jKoIVMoveStd_USCORESpire = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__jKoIVMoveStd_USCORESpire *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire, sizeof(struct __ns1__jKoIVMoveStd_USCORESpire), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__jKoIVMoveStd_USCORESpire(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__jKoIVMoveStd_USCORESpire && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__jKoIVMoveStd_USCORESpire(soap, "ns1:jKoIVMoveStd_Spire", &a->ns1__jKoIVMoveStd_USCORESpire, ""))
				{	soap_flag_ns1__jKoIVMoveStd_USCORESpire--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__jKoIVMoveStd_USCORESpire * SOAP_FMAC2 soap_instantiate___ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__jKoIVMoveStd_USCORESpire(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__jKoIVMoveStd_USCORESpire *p;
	size_t k = sizeof(struct __ns1__jKoIVMoveStd_USCORESpire);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__jKoIVMoveStd_USCORESpire);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__jKoIVMoveStd_USCORESpire, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__jKoIVMoveStd_USCORESpire location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, const struct __ns1__jKoIVMoveStd_USCORESpire *a, const char *tag, const char *type)
{
	if (soap_out___ns1__jKoIVMoveStd_USCORESpire(soap, tag ? tag : "-ns1:jKoIVMoveStd_Spire", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jKoIVMoveStd_USCORESpire * SOAP_FMAC4 soap_get___ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, struct __ns1__jKoIVMoveStd_USCORESpire *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__jKoIVMoveStd_USCORESpire(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, struct __ns1__jKoIVMoveStd_USCOREPasan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__jKoIVMoveStd_USCOREPasan = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, const struct __ns1__jKoIVMoveStd_USCOREPasan *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(soap, &a->ns1__jKoIVMoveStd_USCOREPasan);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, const char *tag, int id, const struct __ns1__jKoIVMoveStd_USCOREPasan *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(soap, "ns1:jKoIVMoveStd_Pasan", -1, &a->ns1__jKoIVMoveStd_USCOREPasan, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jKoIVMoveStd_USCOREPasan * SOAP_FMAC4 soap_in___ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, const char *tag, struct __ns1__jKoIVMoveStd_USCOREPasan *a, const char *type)
{
	size_t soap_flag_ns1__jKoIVMoveStd_USCOREPasan = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__jKoIVMoveStd_USCOREPasan *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan, sizeof(struct __ns1__jKoIVMoveStd_USCOREPasan), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__jKoIVMoveStd_USCOREPasan(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__jKoIVMoveStd_USCOREPasan && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(soap, "ns1:jKoIVMoveStd_Pasan", &a->ns1__jKoIVMoveStd_USCOREPasan, ""))
				{	soap_flag_ns1__jKoIVMoveStd_USCOREPasan--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__jKoIVMoveStd_USCOREPasan * SOAP_FMAC2 soap_instantiate___ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__jKoIVMoveStd_USCOREPasan(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__jKoIVMoveStd_USCOREPasan *p;
	size_t k = sizeof(struct __ns1__jKoIVMoveStd_USCOREPasan);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__jKoIVMoveStd_USCOREPasan);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__jKoIVMoveStd_USCOREPasan, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__jKoIVMoveStd_USCOREPasan location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, const struct __ns1__jKoIVMoveStd_USCOREPasan *a, const char *tag, const char *type)
{
	if (soap_out___ns1__jKoIVMoveStd_USCOREPasan(soap, tag ? tag : "-ns1:jKoIVMoveStd_Pasan", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__jKoIVMoveStd_USCOREPasan * SOAP_FMAC4 soap_get___ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, struct __ns1__jKoIVMoveStd_USCOREPasan *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__jKoIVMoveStd_USCOREPasan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__IV_USCOREDataCollection(struct soap *soap, struct __ns1__IV_USCOREDataCollection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__IV_USCOREDataCollection = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__IV_USCOREDataCollection(struct soap *soap, const struct __ns1__IV_USCOREDataCollection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__IV_USCOREDataCollection(soap, &a->ns1__IV_USCOREDataCollection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__IV_USCOREDataCollection(struct soap *soap, const char *tag, int id, const struct __ns1__IV_USCOREDataCollection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__IV_USCOREDataCollection(soap, "ns1:IV_DataCollection", -1, &a->ns1__IV_USCOREDataCollection, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IV_USCOREDataCollection * SOAP_FMAC4 soap_in___ns1__IV_USCOREDataCollection(struct soap *soap, const char *tag, struct __ns1__IV_USCOREDataCollection *a, const char *type)
{
	size_t soap_flag_ns1__IV_USCOREDataCollection = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__IV_USCOREDataCollection *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__IV_USCOREDataCollection, sizeof(struct __ns1__IV_USCOREDataCollection), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__IV_USCOREDataCollection(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__IV_USCOREDataCollection && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__IV_USCOREDataCollection(soap, "ns1:IV_DataCollection", &a->ns1__IV_USCOREDataCollection, ""))
				{	soap_flag_ns1__IV_USCOREDataCollection--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__IV_USCOREDataCollection * SOAP_FMAC2 soap_instantiate___ns1__IV_USCOREDataCollection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__IV_USCOREDataCollection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__IV_USCOREDataCollection *p;
	size_t k = sizeof(struct __ns1__IV_USCOREDataCollection);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__IV_USCOREDataCollection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__IV_USCOREDataCollection);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__IV_USCOREDataCollection, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__IV_USCOREDataCollection location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__IV_USCOREDataCollection(struct soap *soap, const struct __ns1__IV_USCOREDataCollection *a, const char *tag, const char *type)
{
	if (soap_out___ns1__IV_USCOREDataCollection(soap, tag ? tag : "-ns1:IV_DataCollection", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IV_USCOREDataCollection * SOAP_FMAC4 soap_get___ns1__IV_USCOREDataCollection(struct soap *soap, struct __ns1__IV_USCOREDataCollection *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__IV_USCOREDataCollection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetCurrentSpecBySn(struct soap *soap, struct __ns1__GetCurrentSpecBySn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetCurrentSpecBySn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetCurrentSpecBySn(struct soap *soap, const struct __ns1__GetCurrentSpecBySn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetCurrentSpecBySn(soap, &a->ns1__GetCurrentSpecBySn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetCurrentSpecBySn(struct soap *soap, const char *tag, int id, const struct __ns1__GetCurrentSpecBySn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetCurrentSpecBySn(soap, "ns1:GetCurrentSpecBySn", -1, &a->ns1__GetCurrentSpecBySn, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetCurrentSpecBySn * SOAP_FMAC4 soap_in___ns1__GetCurrentSpecBySn(struct soap *soap, const char *tag, struct __ns1__GetCurrentSpecBySn *a, const char *type)
{
	size_t soap_flag_ns1__GetCurrentSpecBySn = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetCurrentSpecBySn *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetCurrentSpecBySn, sizeof(struct __ns1__GetCurrentSpecBySn), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetCurrentSpecBySn(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetCurrentSpecBySn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetCurrentSpecBySn(soap, "ns1:GetCurrentSpecBySn", &a->ns1__GetCurrentSpecBySn, ""))
				{	soap_flag_ns1__GetCurrentSpecBySn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetCurrentSpecBySn * SOAP_FMAC2 soap_instantiate___ns1__GetCurrentSpecBySn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetCurrentSpecBySn(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetCurrentSpecBySn *p;
	size_t k = sizeof(struct __ns1__GetCurrentSpecBySn);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetCurrentSpecBySn, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetCurrentSpecBySn);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetCurrentSpecBySn, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetCurrentSpecBySn location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetCurrentSpecBySn(struct soap *soap, const struct __ns1__GetCurrentSpecBySn *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetCurrentSpecBySn(soap, tag ? tag : "-ns1:GetCurrentSpecBySn", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetCurrentSpecBySn * SOAP_FMAC4 soap_get___ns1__GetCurrentSpecBySn(struct soap *soap, struct __ns1__GetCurrentSpecBySn *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetCurrentSpecBySn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetWorkCenterID(struct soap *soap, struct __ns1__GetWorkCenterID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetWorkCenterID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetWorkCenterID(struct soap *soap, const struct __ns1__GetWorkCenterID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetWorkCenterID(soap, &a->ns1__GetWorkCenterID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetWorkCenterID(struct soap *soap, const char *tag, int id, const struct __ns1__GetWorkCenterID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetWorkCenterID(soap, "ns1:GetWorkCenterID", -1, &a->ns1__GetWorkCenterID, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetWorkCenterID * SOAP_FMAC4 soap_in___ns1__GetWorkCenterID(struct soap *soap, const char *tag, struct __ns1__GetWorkCenterID *a, const char *type)
{
	size_t soap_flag_ns1__GetWorkCenterID = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetWorkCenterID *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetWorkCenterID, sizeof(struct __ns1__GetWorkCenterID), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetWorkCenterID(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetWorkCenterID && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_ns1__GetWorkCenterID(soap, "ns1:GetWorkCenterID", &a->ns1__GetWorkCenterID, ""))
				{	soap_flag_ns1__GetWorkCenterID--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetWorkCenterID * SOAP_FMAC2 soap_instantiate___ns1__GetWorkCenterID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetWorkCenterID(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetWorkCenterID *p;
	size_t k = sizeof(struct __ns1__GetWorkCenterID);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___ns1__GetWorkCenterID, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __ns1__GetWorkCenterID);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __ns1__GetWorkCenterID, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetWorkCenterID location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetWorkCenterID(struct soap *soap, const struct __ns1__GetWorkCenterID *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetWorkCenterID(soap, tag ? tag : "-ns1:GetWorkCenterID", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetWorkCenterID * SOAP_FMAC4 soap_get___ns1__GetWorkCenterID(struct soap *soap, struct __ns1__GetWorkCenterID *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetWorkCenterID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Login(struct soap *soap, _ns1__Login *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Login))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Login(struct soap *soap, const char *tag, int id, _ns1__Login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Login, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__Login ? type : NULL);
}

SOAP_FMAC3 _ns1__Login ** SOAP_FMAC4 soap_in_PointerTo_ns1__Login(struct soap *soap, const char *tag, _ns1__Login **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Login **)soap_malloc(soap, sizeof(_ns1__Login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Login *)soap_instantiate__ns1__Login(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Login, sizeof(_ns1__Login), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Login(struct soap *soap, _ns1__Login *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Login(soap, tag ? tag : "ns1:Login", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Login ** SOAP_FMAC4 soap_get_PointerTo_ns1__Login(struct soap *soap, _ns1__Login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CanLogin(struct soap *soap, _ns1__CanLogin *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CanLogin))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CanLogin(struct soap *soap, const char *tag, int id, _ns1__CanLogin *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CanLogin, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CanLogin ? type : NULL);
}

SOAP_FMAC3 _ns1__CanLogin ** SOAP_FMAC4 soap_in_PointerTo_ns1__CanLogin(struct soap *soap, const char *tag, _ns1__CanLogin **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CanLogin **)soap_malloc(soap, sizeof(_ns1__CanLogin *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CanLogin *)soap_instantiate__ns1__CanLogin(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CanLogin **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CanLogin, sizeof(_ns1__CanLogin), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CanLogin(struct soap *soap, _ns1__CanLogin *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CanLogin(soap, tag ? tag : "ns1:CanLogin", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CanLogin ** SOAP_FMAC4 soap_get_PointerTo_ns1__CanLogin(struct soap *soap, _ns1__CanLogin **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CanLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, const char *tag, int id, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs ? type : NULL);
}

SOAP_FMAC3 _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs ** SOAP_FMAC4 soap_in_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, const char *tag, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs **)soap_malloc(soap, sizeof(_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *)soap_instantiate__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, sizeof(_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, tag ? tag : "ns1:Upload_FIDWUL_DATAFLAGs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs ** SOAP_FMAC4 soap_get_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetMaterialBatchResultToMES(struct soap *soap, _ns1__SetMaterialBatchResultToMES *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetMaterialBatchResultToMES))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetMaterialBatchResultToMES(struct soap *soap, const char *tag, int id, _ns1__SetMaterialBatchResultToMES *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetMaterialBatchResultToMES, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SetMaterialBatchResultToMES ? type : NULL);
}

SOAP_FMAC3 _ns1__SetMaterialBatchResultToMES ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetMaterialBatchResultToMES(struct soap *soap, const char *tag, _ns1__SetMaterialBatchResultToMES **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetMaterialBatchResultToMES **)soap_malloc(soap, sizeof(_ns1__SetMaterialBatchResultToMES *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetMaterialBatchResultToMES *)soap_instantiate__ns1__SetMaterialBatchResultToMES(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SetMaterialBatchResultToMES **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetMaterialBatchResultToMES, sizeof(_ns1__SetMaterialBatchResultToMES), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetMaterialBatchResultToMES(struct soap *soap, _ns1__SetMaterialBatchResultToMES *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SetMaterialBatchResultToMES(soap, tag ? tag : "ns1:SetMaterialBatchResultToMES", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetMaterialBatchResultToMES ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetMaterialBatchResultToMES(struct soap *soap, _ns1__SetMaterialBatchResultToMES **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetMaterialBatchResultToMES(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SetDefectResultToMES(struct soap *soap, _ns1__SetDefectResultToMES *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SetDefectResultToMES))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SetDefectResultToMES(struct soap *soap, const char *tag, int id, _ns1__SetDefectResultToMES *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SetDefectResultToMES, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SetDefectResultToMES ? type : NULL);
}

SOAP_FMAC3 _ns1__SetDefectResultToMES ** SOAP_FMAC4 soap_in_PointerTo_ns1__SetDefectResultToMES(struct soap *soap, const char *tag, _ns1__SetDefectResultToMES **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SetDefectResultToMES **)soap_malloc(soap, sizeof(_ns1__SetDefectResultToMES *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SetDefectResultToMES *)soap_instantiate__ns1__SetDefectResultToMES(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SetDefectResultToMES **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SetDefectResultToMES, sizeof(_ns1__SetDefectResultToMES), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SetDefectResultToMES(struct soap *soap, _ns1__SetDefectResultToMES *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SetDefectResultToMES(soap, tag ? tag : "ns1:SetDefectResultToMES", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SetDefectResultToMES ** SOAP_FMAC4 soap_get_PointerTo_ns1__SetDefectResultToMES(struct soap *soap, _ns1__SetDefectResultToMES **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SetDefectResultToMES(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetDefectInfoToSAP(struct soap *soap, _ns1__GetDefectInfoToSAP *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetDefectInfoToSAP))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetDefectInfoToSAP(struct soap *soap, const char *tag, int id, _ns1__GetDefectInfoToSAP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetDefectInfoToSAP, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetDefectInfoToSAP ? type : NULL);
}

SOAP_FMAC3 _ns1__GetDefectInfoToSAP ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetDefectInfoToSAP(struct soap *soap, const char *tag, _ns1__GetDefectInfoToSAP **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetDefectInfoToSAP **)soap_malloc(soap, sizeof(_ns1__GetDefectInfoToSAP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetDefectInfoToSAP *)soap_instantiate__ns1__GetDefectInfoToSAP(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetDefectInfoToSAP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetDefectInfoToSAP, sizeof(_ns1__GetDefectInfoToSAP), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetDefectInfoToSAP(struct soap *soap, _ns1__GetDefectInfoToSAP *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetDefectInfoToSAP(soap, tag ? tag : "ns1:GetDefectInfoToSAP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetDefectInfoToSAP ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetDefectInfoToSAP(struct soap *soap, _ns1__GetDefectInfoToSAP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetDefectInfoToSAP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetFtpAddress(struct soap *soap, _ns1__GetFtpAddress *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetFtpAddress))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetFtpAddress(struct soap *soap, const char *tag, int id, _ns1__GetFtpAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetFtpAddress, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetFtpAddress ? type : NULL);
}

SOAP_FMAC3 _ns1__GetFtpAddress ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetFtpAddress(struct soap *soap, const char *tag, _ns1__GetFtpAddress **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetFtpAddress **)soap_malloc(soap, sizeof(_ns1__GetFtpAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetFtpAddress *)soap_instantiate__ns1__GetFtpAddress(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetFtpAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetFtpAddress, sizeof(_ns1__GetFtpAddress), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetFtpAddress(struct soap *soap, _ns1__GetFtpAddress *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetFtpAddress(soap, tag ? tag : "ns1:GetFtpAddress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetFtpAddress ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetFtpAddress(struct soap *soap, _ns1__GetFtpAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetFtpAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Iscalibrationcontainer(struct soap *soap, _ns1__Iscalibrationcontainer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Iscalibrationcontainer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Iscalibrationcontainer(struct soap *soap, const char *tag, int id, _ns1__Iscalibrationcontainer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Iscalibrationcontainer, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__Iscalibrationcontainer ? type : NULL);
}

SOAP_FMAC3 _ns1__Iscalibrationcontainer ** SOAP_FMAC4 soap_in_PointerTo_ns1__Iscalibrationcontainer(struct soap *soap, const char *tag, _ns1__Iscalibrationcontainer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Iscalibrationcontainer **)soap_malloc(soap, sizeof(_ns1__Iscalibrationcontainer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Iscalibrationcontainer *)soap_instantiate__ns1__Iscalibrationcontainer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Iscalibrationcontainer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Iscalibrationcontainer, sizeof(_ns1__Iscalibrationcontainer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Iscalibrationcontainer(struct soap *soap, _ns1__Iscalibrationcontainer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Iscalibrationcontainer(soap, tag ? tag : "ns1:Iscalibrationcontainer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Iscalibrationcontainer ** SOAP_FMAC4 soap_get_PointerTo_ns1__Iscalibrationcontainer(struct soap *soap, _ns1__Iscalibrationcontainer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Iscalibrationcontainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetTensileTestRule(struct soap *soap, _ns1__GetTensileTestRule *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetTensileTestRule))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetTensileTestRule(struct soap *soap, const char *tag, int id, _ns1__GetTensileTestRule *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetTensileTestRule, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetTensileTestRule ? type : NULL);
}

SOAP_FMAC3 _ns1__GetTensileTestRule ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetTensileTestRule(struct soap *soap, const char *tag, _ns1__GetTensileTestRule **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetTensileTestRule **)soap_malloc(soap, sizeof(_ns1__GetTensileTestRule *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetTensileTestRule *)soap_instantiate__ns1__GetTensileTestRule(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetTensileTestRule **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetTensileTestRule, sizeof(_ns1__GetTensileTestRule), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetTensileTestRule(struct soap *soap, _ns1__GetTensileTestRule *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetTensileTestRule(soap, tag ? tag : "ns1:GetTensileTestRule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetTensileTestRule ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetTensileTestRule(struct soap *soap, _ns1__GetTensileTestRule **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetTensileTestRule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetContainerDataInfoMES(struct soap *soap, _ns1__GetContainerDataInfoMES *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetContainerDataInfoMES))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetContainerDataInfoMES(struct soap *soap, const char *tag, int id, _ns1__GetContainerDataInfoMES *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetContainerDataInfoMES, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetContainerDataInfoMES ? type : NULL);
}

SOAP_FMAC3 _ns1__GetContainerDataInfoMES ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetContainerDataInfoMES(struct soap *soap, const char *tag, _ns1__GetContainerDataInfoMES **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetContainerDataInfoMES **)soap_malloc(soap, sizeof(_ns1__GetContainerDataInfoMES *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetContainerDataInfoMES *)soap_instantiate__ns1__GetContainerDataInfoMES(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetContainerDataInfoMES **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetContainerDataInfoMES, sizeof(_ns1__GetContainerDataInfoMES), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetContainerDataInfoMES(struct soap *soap, _ns1__GetContainerDataInfoMES *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetContainerDataInfoMES(soap, tag ? tag : "ns1:GetContainerDataInfoMES", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetContainerDataInfoMES ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetContainerDataInfoMES(struct soap *soap, _ns1__GetContainerDataInfoMES **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetContainerDataInfoMES(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UploadTensileInfoToMes(struct soap *soap, _ns1__UploadTensileInfoToMes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UploadTensileInfoToMes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UploadTensileInfoToMes(struct soap *soap, const char *tag, int id, _ns1__UploadTensileInfoToMes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UploadTensileInfoToMes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__UploadTensileInfoToMes ? type : NULL);
}

SOAP_FMAC3 _ns1__UploadTensileInfoToMes ** SOAP_FMAC4 soap_in_PointerTo_ns1__UploadTensileInfoToMes(struct soap *soap, const char *tag, _ns1__UploadTensileInfoToMes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UploadTensileInfoToMes **)soap_malloc(soap, sizeof(_ns1__UploadTensileInfoToMes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UploadTensileInfoToMes *)soap_instantiate__ns1__UploadTensileInfoToMes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__UploadTensileInfoToMes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UploadTensileInfoToMes, sizeof(_ns1__UploadTensileInfoToMes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UploadTensileInfoToMes(struct soap *soap, _ns1__UploadTensileInfoToMes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__UploadTensileInfoToMes(soap, tag ? tag : "ns1:UploadTensileInfoToMes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UploadTensileInfoToMes ** SOAP_FMAC4 soap_get_PointerTo_ns1__UploadTensileInfoToMes(struct soap *soap, _ns1__UploadTensileInfoToMes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UploadTensileInfoToMes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SafetyInfoMoveStd(struct soap *soap, _ns1__SafetyInfoMoveStd *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SafetyInfoMoveStd))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SafetyInfoMoveStd(struct soap *soap, const char *tag, int id, _ns1__SafetyInfoMoveStd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SafetyInfoMoveStd, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SafetyInfoMoveStd ? type : NULL);
}

SOAP_FMAC3 _ns1__SafetyInfoMoveStd ** SOAP_FMAC4 soap_in_PointerTo_ns1__SafetyInfoMoveStd(struct soap *soap, const char *tag, _ns1__SafetyInfoMoveStd **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SafetyInfoMoveStd **)soap_malloc(soap, sizeof(_ns1__SafetyInfoMoveStd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SafetyInfoMoveStd *)soap_instantiate__ns1__SafetyInfoMoveStd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SafetyInfoMoveStd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SafetyInfoMoveStd, sizeof(_ns1__SafetyInfoMoveStd), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SafetyInfoMoveStd(struct soap *soap, _ns1__SafetyInfoMoveStd *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SafetyInfoMoveStd(soap, tag ? tag : "ns1:SafetyInfoMoveStd", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SafetyInfoMoveStd ** SOAP_FMAC4 soap_get_PointerTo_ns1__SafetyInfoMoveStd(struct soap *soap, _ns1__SafetyInfoMoveStd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SafetyInfoMoveStd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ELInfoMoveStd(struct soap *soap, _ns1__ELInfoMoveStd *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ELInfoMoveStd))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ELInfoMoveStd(struct soap *soap, const char *tag, int id, _ns1__ELInfoMoveStd *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ELInfoMoveStd, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ELInfoMoveStd ? type : NULL);
}

SOAP_FMAC3 _ns1__ELInfoMoveStd ** SOAP_FMAC4 soap_in_PointerTo_ns1__ELInfoMoveStd(struct soap *soap, const char *tag, _ns1__ELInfoMoveStd **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ELInfoMoveStd **)soap_malloc(soap, sizeof(_ns1__ELInfoMoveStd *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ELInfoMoveStd *)soap_instantiate__ns1__ELInfoMoveStd(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ELInfoMoveStd **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ELInfoMoveStd, sizeof(_ns1__ELInfoMoveStd), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ELInfoMoveStd(struct soap *soap, _ns1__ELInfoMoveStd *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ELInfoMoveStd(soap, tag ? tag : "ns1:ELInfoMoveStd", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ELInfoMoveStd ** SOAP_FMAC4 soap_get_PointerTo_ns1__ELInfoMoveStd(struct soap *soap, _ns1__ELInfoMoveStd **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ELInfoMoveStd(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ELPictureAddress(struct soap *soap, _ns1__ELPictureAddress *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ELPictureAddress))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ELPictureAddress(struct soap *soap, const char *tag, int id, _ns1__ELPictureAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ELPictureAddress, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ELPictureAddress ? type : NULL);
}

SOAP_FMAC3 _ns1__ELPictureAddress ** SOAP_FMAC4 soap_in_PointerTo_ns1__ELPictureAddress(struct soap *soap, const char *tag, _ns1__ELPictureAddress **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ELPictureAddress **)soap_malloc(soap, sizeof(_ns1__ELPictureAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ELPictureAddress *)soap_instantiate__ns1__ELPictureAddress(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ELPictureAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ELPictureAddress, sizeof(_ns1__ELPictureAddress), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ELPictureAddress(struct soap *soap, _ns1__ELPictureAddress *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ELPictureAddress(soap, tag ? tag : "ns1:ELPictureAddress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ELPictureAddress ** SOAP_FMAC4 soap_get_PointerTo_ns1__ELPictureAddress(struct soap *soap, _ns1__ELPictureAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ELPictureAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, _ns1__jKoIVMoveStd_USCORESpire *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, const char *tag, int id, _ns1__jKoIVMoveStd_USCORESpire *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire ? type : NULL);
}

SOAP_FMAC3 _ns1__jKoIVMoveStd_USCORESpire ** SOAP_FMAC4 soap_in_PointerTo_ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, const char *tag, _ns1__jKoIVMoveStd_USCORESpire **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__jKoIVMoveStd_USCORESpire **)soap_malloc(soap, sizeof(_ns1__jKoIVMoveStd_USCORESpire *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__jKoIVMoveStd_USCORESpire *)soap_instantiate__ns1__jKoIVMoveStd_USCORESpire(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__jKoIVMoveStd_USCORESpire **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire, sizeof(_ns1__jKoIVMoveStd_USCORESpire), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, _ns1__jKoIVMoveStd_USCORESpire *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__jKoIVMoveStd_USCORESpire(soap, tag ? tag : "ns1:jKoIVMoveStd_Spire", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__jKoIVMoveStd_USCORESpire ** SOAP_FMAC4 soap_get_PointerTo_ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, _ns1__jKoIVMoveStd_USCORESpire **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__jKoIVMoveStd_USCORESpire(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, _ns1__jKoIVMoveStd_USCOREPasan *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, const char *tag, int id, _ns1__jKoIVMoveStd_USCOREPasan *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan ? type : NULL);
}

SOAP_FMAC3 _ns1__jKoIVMoveStd_USCOREPasan ** SOAP_FMAC4 soap_in_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, const char *tag, _ns1__jKoIVMoveStd_USCOREPasan **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__jKoIVMoveStd_USCOREPasan **)soap_malloc(soap, sizeof(_ns1__jKoIVMoveStd_USCOREPasan *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__jKoIVMoveStd_USCOREPasan *)soap_instantiate__ns1__jKoIVMoveStd_USCOREPasan(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__jKoIVMoveStd_USCOREPasan **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan, sizeof(_ns1__jKoIVMoveStd_USCOREPasan), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, _ns1__jKoIVMoveStd_USCOREPasan *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(soap, tag ? tag : "ns1:jKoIVMoveStd_Pasan", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__jKoIVMoveStd_USCOREPasan ** SOAP_FMAC4 soap_get_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, _ns1__jKoIVMoveStd_USCOREPasan **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__jKoIVMoveStd_USCOREPasan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__IV_USCOREDataCollection(struct soap *soap, _ns1__IV_USCOREDataCollection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__IV_USCOREDataCollection))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__IV_USCOREDataCollection(struct soap *soap, const char *tag, int id, _ns1__IV_USCOREDataCollection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__IV_USCOREDataCollection, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__IV_USCOREDataCollection ? type : NULL);
}

SOAP_FMAC3 _ns1__IV_USCOREDataCollection ** SOAP_FMAC4 soap_in_PointerTo_ns1__IV_USCOREDataCollection(struct soap *soap, const char *tag, _ns1__IV_USCOREDataCollection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__IV_USCOREDataCollection **)soap_malloc(soap, sizeof(_ns1__IV_USCOREDataCollection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__IV_USCOREDataCollection *)soap_instantiate__ns1__IV_USCOREDataCollection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__IV_USCOREDataCollection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__IV_USCOREDataCollection, sizeof(_ns1__IV_USCOREDataCollection), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__IV_USCOREDataCollection(struct soap *soap, _ns1__IV_USCOREDataCollection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__IV_USCOREDataCollection(soap, tag ? tag : "ns1:IV_DataCollection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__IV_USCOREDataCollection ** SOAP_FMAC4 soap_get_PointerTo_ns1__IV_USCOREDataCollection(struct soap *soap, _ns1__IV_USCOREDataCollection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__IV_USCOREDataCollection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetCurrentSpecBySn(struct soap *soap, _ns1__GetCurrentSpecBySn *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetCurrentSpecBySn))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetCurrentSpecBySn(struct soap *soap, const char *tag, int id, _ns1__GetCurrentSpecBySn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetCurrentSpecBySn, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetCurrentSpecBySn ? type : NULL);
}

SOAP_FMAC3 _ns1__GetCurrentSpecBySn ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetCurrentSpecBySn(struct soap *soap, const char *tag, _ns1__GetCurrentSpecBySn **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetCurrentSpecBySn **)soap_malloc(soap, sizeof(_ns1__GetCurrentSpecBySn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetCurrentSpecBySn *)soap_instantiate__ns1__GetCurrentSpecBySn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetCurrentSpecBySn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetCurrentSpecBySn, sizeof(_ns1__GetCurrentSpecBySn), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetCurrentSpecBySn(struct soap *soap, _ns1__GetCurrentSpecBySn *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetCurrentSpecBySn(soap, tag ? tag : "ns1:GetCurrentSpecBySn", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetCurrentSpecBySn ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetCurrentSpecBySn(struct soap *soap, _ns1__GetCurrentSpecBySn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetCurrentSpecBySn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetWorkCenterID(struct soap *soap, _ns1__GetWorkCenterID *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetWorkCenterID))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetWorkCenterID(struct soap *soap, const char *tag, int id, _ns1__GetWorkCenterID *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetWorkCenterID, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetWorkCenterID ? type : NULL);
}

SOAP_FMAC3 _ns1__GetWorkCenterID ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetWorkCenterID(struct soap *soap, const char *tag, _ns1__GetWorkCenterID **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetWorkCenterID **)soap_malloc(soap, sizeof(_ns1__GetWorkCenterID *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetWorkCenterID *)soap_instantiate__ns1__GetWorkCenterID(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetWorkCenterID **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetWorkCenterID, sizeof(_ns1__GetWorkCenterID), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetWorkCenterID(struct soap *soap, _ns1__GetWorkCenterID *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetWorkCenterID(soap, tag ? tag : "ns1:GetWorkCenterID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetWorkCenterID ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetWorkCenterID(struct soap *soap, _ns1__GetWorkCenterID **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetWorkCenterID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfFIDailyWorkReturnEntity(struct soap *soap, ns1__ArrayOfFIDailyWorkReturnEntity *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfFIDailyWorkReturnEntity(struct soap *soap, const char *tag, int id, ns1__ArrayOfFIDailyWorkReturnEntity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfFIDailyWorkReturnEntity ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfFIDailyWorkReturnEntity(struct soap *soap, const char *tag, ns1__ArrayOfFIDailyWorkReturnEntity **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfFIDailyWorkReturnEntity **)soap_malloc(soap, sizeof(ns1__ArrayOfFIDailyWorkReturnEntity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfFIDailyWorkReturnEntity *)soap_instantiate_ns1__ArrayOfFIDailyWorkReturnEntity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfFIDailyWorkReturnEntity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity, sizeof(ns1__ArrayOfFIDailyWorkReturnEntity), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfFIDailyWorkReturnEntity(struct soap *soap, ns1__ArrayOfFIDailyWorkReturnEntity *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfFIDailyWorkReturnEntity(soap, tag ? tag : "ns1:ArrayOfFIDailyWorkReturnEntity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfFIDailyWorkReturnEntity ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfFIDailyWorkReturnEntity(struct soap *soap, ns1__ArrayOfFIDailyWorkReturnEntity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfFIDailyWorkReturnEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfMaterialBatchResultInfo(struct soap *soap, ns1__ArrayOfMaterialBatchResultInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfMaterialBatchResultInfo(struct soap *soap, const char *tag, int id, ns1__ArrayOfMaterialBatchResultInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfMaterialBatchResultInfo ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfMaterialBatchResultInfo(struct soap *soap, const char *tag, ns1__ArrayOfMaterialBatchResultInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfMaterialBatchResultInfo **)soap_malloc(soap, sizeof(ns1__ArrayOfMaterialBatchResultInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfMaterialBatchResultInfo *)soap_instantiate_ns1__ArrayOfMaterialBatchResultInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfMaterialBatchResultInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo, sizeof(ns1__ArrayOfMaterialBatchResultInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfMaterialBatchResultInfo(struct soap *soap, ns1__ArrayOfMaterialBatchResultInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfMaterialBatchResultInfo(soap, tag ? tag : "ns1:ArrayOfMaterialBatchResultInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfMaterialBatchResultInfo ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfMaterialBatchResultInfo(struct soap *soap, ns1__ArrayOfMaterialBatchResultInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfMaterialBatchResultInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfDefectResultInfo(struct soap *soap, ns1__ArrayOfDefectResultInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfDefectResultInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfDefectResultInfo(struct soap *soap, const char *tag, int id, ns1__ArrayOfDefectResultInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfDefectResultInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfDefectResultInfo ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfDefectResultInfo ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfDefectResultInfo(struct soap *soap, const char *tag, ns1__ArrayOfDefectResultInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfDefectResultInfo **)soap_malloc(soap, sizeof(ns1__ArrayOfDefectResultInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfDefectResultInfo *)soap_instantiate_ns1__ArrayOfDefectResultInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfDefectResultInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfDefectResultInfo, sizeof(ns1__ArrayOfDefectResultInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfDefectResultInfo(struct soap *soap, ns1__ArrayOfDefectResultInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfDefectResultInfo(soap, tag ? tag : "ns1:ArrayOfDefectResultInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfDefectResultInfo ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfDefectResultInfo(struct soap *soap, ns1__ArrayOfDefectResultInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfDefectResultInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfSubmitResult(struct soap *soap, ns1__ArrayOfSubmitResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfSubmitResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfSubmitResult(struct soap *soap, const char *tag, int id, ns1__ArrayOfSubmitResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfSubmitResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfSubmitResult ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfSubmitResult ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfSubmitResult(struct soap *soap, const char *tag, ns1__ArrayOfSubmitResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfSubmitResult **)soap_malloc(soap, sizeof(ns1__ArrayOfSubmitResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfSubmitResult *)soap_instantiate_ns1__ArrayOfSubmitResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfSubmitResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfSubmitResult, sizeof(ns1__ArrayOfSubmitResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfSubmitResult(struct soap *soap, ns1__ArrayOfSubmitResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfSubmitResult(soap, tag ? tag : "ns1:ArrayOfSubmitResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfSubmitResult ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfSubmitResult(struct soap *soap, ns1__ArrayOfSubmitResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfSubmitResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FIDailyWorkReturnEntity(struct soap *soap, ns1__FIDailyWorkReturnEntity *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FIDailyWorkReturnEntity))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FIDailyWorkReturnEntity(struct soap *soap, const char *tag, int id, ns1__FIDailyWorkReturnEntity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FIDailyWorkReturnEntity, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__FIDailyWorkReturnEntity ? type : NULL);
}

SOAP_FMAC3 ns1__FIDailyWorkReturnEntity ** SOAP_FMAC4 soap_in_PointerTons1__FIDailyWorkReturnEntity(struct soap *soap, const char *tag, ns1__FIDailyWorkReturnEntity **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__FIDailyWorkReturnEntity **)soap_malloc(soap, sizeof(ns1__FIDailyWorkReturnEntity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__FIDailyWorkReturnEntity *)soap_instantiate_ns1__FIDailyWorkReturnEntity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__FIDailyWorkReturnEntity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FIDailyWorkReturnEntity, sizeof(ns1__FIDailyWorkReturnEntity), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FIDailyWorkReturnEntity(struct soap *soap, ns1__FIDailyWorkReturnEntity *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__FIDailyWorkReturnEntity(soap, tag ? tag : "ns1:FIDailyWorkReturnEntity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__FIDailyWorkReturnEntity ** SOAP_FMAC4 soap_get_PointerTons1__FIDailyWorkReturnEntity(struct soap *soap, ns1__FIDailyWorkReturnEntity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FIDailyWorkReturnEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MaterialBatchResultInfo(struct soap *soap, ns1__MaterialBatchResultInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MaterialBatchResultInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MaterialBatchResultInfo(struct soap *soap, const char *tag, int id, ns1__MaterialBatchResultInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MaterialBatchResultInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__MaterialBatchResultInfo ? type : NULL);
}

SOAP_FMAC3 ns1__MaterialBatchResultInfo ** SOAP_FMAC4 soap_in_PointerTons1__MaterialBatchResultInfo(struct soap *soap, const char *tag, ns1__MaterialBatchResultInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MaterialBatchResultInfo **)soap_malloc(soap, sizeof(ns1__MaterialBatchResultInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MaterialBatchResultInfo *)soap_instantiate_ns1__MaterialBatchResultInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__MaterialBatchResultInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MaterialBatchResultInfo, sizeof(ns1__MaterialBatchResultInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MaterialBatchResultInfo(struct soap *soap, ns1__MaterialBatchResultInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__MaterialBatchResultInfo(soap, tag ? tag : "ns1:MaterialBatchResultInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__MaterialBatchResultInfo ** SOAP_FMAC4 soap_get_PointerTons1__MaterialBatchResultInfo(struct soap *soap, ns1__MaterialBatchResultInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MaterialBatchResultInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DefectResultInfo(struct soap *soap, ns1__DefectResultInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DefectResultInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DefectResultInfo(struct soap *soap, const char *tag, int id, ns1__DefectResultInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DefectResultInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__DefectResultInfo ? type : NULL);
}

SOAP_FMAC3 ns1__DefectResultInfo ** SOAP_FMAC4 soap_in_PointerTons1__DefectResultInfo(struct soap *soap, const char *tag, ns1__DefectResultInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DefectResultInfo **)soap_malloc(soap, sizeof(ns1__DefectResultInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DefectResultInfo *)soap_instantiate_ns1__DefectResultInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__DefectResultInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DefectResultInfo, sizeof(ns1__DefectResultInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DefectResultInfo(struct soap *soap, ns1__DefectResultInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__DefectResultInfo(soap, tag ? tag : "ns1:DefectResultInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DefectResultInfo ** SOAP_FMAC4 soap_get_PointerTons1__DefectResultInfo(struct soap *soap, ns1__DefectResultInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DefectResultInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubmitResult(struct soap *soap, ns1__SubmitResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubmitResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubmitResult(struct soap *soap, const char *tag, int id, ns1__SubmitResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubmitResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__SubmitResult ? type : NULL);
}

SOAP_FMAC3 ns1__SubmitResult ** SOAP_FMAC4 soap_in_PointerTons1__SubmitResult(struct soap *soap, const char *tag, ns1__SubmitResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubmitResult **)soap_malloc(soap, sizeof(ns1__SubmitResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubmitResult *)soap_instantiate_ns1__SubmitResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__SubmitResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubmitResult, sizeof(ns1__SubmitResult), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubmitResult(struct soap *soap, ns1__SubmitResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__SubmitResult(soap, tag ? tag : "ns1:SubmitResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SubmitResult ** SOAP_FMAC4 soap_get_PointerTons1__SubmitResult(struct soap *soap, ns1__SubmitResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubmitResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SubmitResult_ResultTable(struct soap *soap, _ns1__SubmitResult_ResultTable *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SubmitResult_ResultTable))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SubmitResult_ResultTable(struct soap *soap, const char *tag, int id, _ns1__SubmitResult_ResultTable *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SubmitResult_ResultTable, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__SubmitResult_ResultTable ? type : NULL);
}

SOAP_FMAC3 _ns1__SubmitResult_ResultTable ** SOAP_FMAC4 soap_in_PointerTo_ns1__SubmitResult_ResultTable(struct soap *soap, const char *tag, _ns1__SubmitResult_ResultTable **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SubmitResult_ResultTable **)soap_malloc(soap, sizeof(_ns1__SubmitResult_ResultTable *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SubmitResult_ResultTable *)soap_instantiate__ns1__SubmitResult_ResultTable(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__SubmitResult_ResultTable **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SubmitResult_ResultTable, sizeof(_ns1__SubmitResult_ResultTable), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SubmitResult_ResultTable(struct soap *soap, _ns1__SubmitResult_ResultTable *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__SubmitResult_ResultTable(soap, tag ? tag : "ns1:SubmitResult-ResultTable", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SubmitResult_ResultTable ** SOAP_FMAC4 soap_get_PointerTo_ns1__SubmitResult_ResultTable(struct soap *soap, _ns1__SubmitResult_ResultTable **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SubmitResult_ResultTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity(struct soap *soap, std::vector<ns1__FIDailyWorkReturnEntity *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity(struct soap *soap, const std::vector<ns1__FIDailyWorkReturnEntity *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__FIDailyWorkReturnEntity *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__FIDailyWorkReturnEntity(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity(struct soap *soap, const char *tag, int id, const std::vector<ns1__FIDailyWorkReturnEntity *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__FIDailyWorkReturnEntity *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__FIDailyWorkReturnEntity(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__FIDailyWorkReturnEntity *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity(struct soap *soap, const char *tag, std::vector<ns1__FIDailyWorkReturnEntity *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__FIDailyWorkReturnEntity *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__FIDailyWorkReturnEntity, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity, sizeof(ns1__FIDailyWorkReturnEntity), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__FIDailyWorkReturnEntity(soap, tag, NULL, "ns1:FIDailyWorkReturnEntity"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__FIDailyWorkReturnEntity(soap, tag, &n, "ns1:FIDailyWorkReturnEntity"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__FIDailyWorkReturnEntity *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__FIDailyWorkReturnEntity *> *p;
	size_t k = sizeof(std::vector<ns1__FIDailyWorkReturnEntity *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__FIDailyWorkReturnEntity *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__FIDailyWorkReturnEntity *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__FIDailyWorkReturnEntity *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo(struct soap *soap, std::vector<ns1__MaterialBatchResultInfo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo(struct soap *soap, const std::vector<ns1__MaterialBatchResultInfo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__MaterialBatchResultInfo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__MaterialBatchResultInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo(struct soap *soap, const char *tag, int id, const std::vector<ns1__MaterialBatchResultInfo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__MaterialBatchResultInfo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__MaterialBatchResultInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__MaterialBatchResultInfo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo(struct soap *soap, const char *tag, std::vector<ns1__MaterialBatchResultInfo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__MaterialBatchResultInfo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__MaterialBatchResultInfo, SOAP_TYPE_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo, sizeof(ns1__MaterialBatchResultInfo), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__MaterialBatchResultInfo(soap, tag, NULL, "ns1:MaterialBatchResultInfo"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__MaterialBatchResultInfo(soap, tag, &n, "ns1:MaterialBatchResultInfo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__MaterialBatchResultInfo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__MaterialBatchResultInfo *> *p;
	size_t k = sizeof(std::vector<ns1__MaterialBatchResultInfo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__MaterialBatchResultInfo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__MaterialBatchResultInfo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__MaterialBatchResultInfo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__DefectResultInfo(struct soap *soap, std::vector<ns1__DefectResultInfo *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__DefectResultInfo(struct soap *soap, const std::vector<ns1__DefectResultInfo *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__DefectResultInfo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__DefectResultInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__DefectResultInfo(struct soap *soap, const char *tag, int id, const std::vector<ns1__DefectResultInfo *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__DefectResultInfo *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__DefectResultInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__DefectResultInfo *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__DefectResultInfo(struct soap *soap, const char *tag, std::vector<ns1__DefectResultInfo *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__DefectResultInfo(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__DefectResultInfo *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__DefectResultInfo, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DefectResultInfo, sizeof(ns1__DefectResultInfo), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__DefectResultInfo(soap, tag, NULL, "ns1:DefectResultInfo"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__DefectResultInfo(soap, tag, &n, "ns1:DefectResultInfo"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__DefectResultInfo *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__DefectResultInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__DefectResultInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__DefectResultInfo *> *p;
	size_t k = sizeof(std::vector<ns1__DefectResultInfo *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DefectResultInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__DefectResultInfo *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__DefectResultInfo *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__DefectResultInfo *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SubmitResult(struct soap *soap, std::vector<ns1__SubmitResult *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SubmitResult(struct soap *soap, const std::vector<ns1__SubmitResult *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__SubmitResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SubmitResult(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SubmitResult(struct soap *soap, const char *tag, int id, const std::vector<ns1__SubmitResult *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__SubmitResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SubmitResult(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SubmitResult *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SubmitResult(struct soap *soap, const char *tag, std::vector<ns1__SubmitResult *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SubmitResult(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__SubmitResult *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__SubmitResult, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubmitResult, sizeof(ns1__SubmitResult), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__SubmitResult(soap, tag, NULL, "ns1:SubmitResult"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__SubmitResult(soap, tag, &n, "ns1:SubmitResult"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__SubmitResult *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__SubmitResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SubmitResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__SubmitResult *> *p;
	size_t k = sizeof(std::vector<ns1__SubmitResult *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubmitResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<ns1__SubmitResult *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<ns1__SubmitResult *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__SubmitResult *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<char *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, (char*const*)&(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		char *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else
		{	if (!soap_inliteral(soap, tag, &n))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<char *> *p;
	size_t k = sizeof(std::vector<char *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<char *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<char *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<char *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
