/* soapStub.h
   Generated by gSOAP 2.8.63 for MESWebService.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://tempuri.org/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20863
# error "GSOAP VERSION 20863 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class _ns1__SubmitResult_ResultTable;	/* MESWebService.h:332 */
class ns1__SubmitResult;	/* MESWebService.h:151 */
class ns1__ArrayOfSubmitResult;	/* MESWebService.h:154 */
class ns1__ArrayOfDefectResultInfo;	/* MESWebService.h:157 */
class ns1__DefectResultInfo;	/* MESWebService.h:160 */
class ns1__ArrayOfMaterialBatchResultInfo;	/* MESWebService.h:163 */
class ns1__MaterialBatchResultInfo;	/* MESWebService.h:166 */
class ns1__ArrayOfFIDailyWorkReturnEntity;	/* MESWebService.h:169 */
class ns1__FIDailyWorkReturnEntity;	/* MESWebService.h:172 */
class _ns1__GetWorkCenterID;	/* MESWebService.h:175 */
class _ns1__GetWorkCenterIDResponse;	/* MESWebService.h:178 */
class _ns1__GetCurrentSpecBySn;	/* MESWebService.h:181 */
class _ns1__GetCurrentSpecBySnResponse;	/* MESWebService.h:184 */
class _ns1__IV_USCOREDataCollection;	/* MESWebService.h:187 */
class _ns1__IV_USCOREDataCollectionResponse;	/* MESWebService.h:190 */
class _ns1__jKoIVMoveStd_USCOREPasan;	/* MESWebService.h:193 */
class _ns1__jKoIVMoveStd_USCOREPasanResponse;	/* MESWebService.h:196 */
class _ns1__jKoIVMoveStd_USCORESpire;	/* MESWebService.h:199 */
class _ns1__jKoIVMoveStd_USCORESpireResponse;	/* MESWebService.h:202 */
class _ns1__ELPictureAddress;	/* MESWebService.h:205 */
class _ns1__ELPictureAddressResponse;	/* MESWebService.h:208 */
class _ns1__ELInfoMoveStd;	/* MESWebService.h:211 */
class _ns1__ELInfoMoveStdResponse;	/* MESWebService.h:214 */
class _ns1__SafetyInfoMoveStd;	/* MESWebService.h:217 */
class _ns1__SafetyInfoMoveStdResponse;	/* MESWebService.h:220 */
class _ns1__UploadTensileInfoToMes;	/* MESWebService.h:223 */
class _ns1__UploadTensileInfoToMesResponse;	/* MESWebService.h:226 */
class _ns1__GetContainerDataInfoMES;	/* MESWebService.h:229 */
class _ns1__GetContainerDataInfoMESResponse;	/* MESWebService.h:232 */
class _ns1__GetTensileTestRule;	/* MESWebService.h:235 */
class _ns1__GetTensileTestRuleResponse;	/* MESWebService.h:238 */
class _ns1__Iscalibrationcontainer;	/* MESWebService.h:241 */
class _ns1__IscalibrationcontainerResponse;	/* MESWebService.h:244 */
class _ns1__GetFtpAddress;	/* MESWebService.h:247 */
class _ns1__GetFtpAddressResponse;	/* MESWebService.h:250 */
class _ns1__GetDefectInfoToSAP;	/* MESWebService.h:253 */
class _ns1__GetDefectInfoToSAPResponse;	/* MESWebService.h:256 */
class _ns1__SetDefectResultToMES;	/* MESWebService.h:259 */
class _ns1__SetDefectResultToMESResponse;	/* MESWebService.h:262 */
class _ns1__SetMaterialBatchResultToMES;	/* MESWebService.h:265 */
class _ns1__SetMaterialBatchResultToMESResponse;	/* MESWebService.h:268 */
class _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs;	/* MESWebService.h:271 */
class _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse;	/* MESWebService.h:274 */
class _ns1__CanLogin;	/* MESWebService.h:277 */
class _ns1__CanLoginResponse;	/* MESWebService.h:280 */
class _ns1__Login;	/* MESWebService.h:283 */
class _ns1__LoginResponse;	/* MESWebService.h:286 */
struct __ns1__GetWorkCenterID;	/* MESWebService.h:1520 */
struct __ns1__GetCurrentSpecBySn;	/* MESWebService.h:1591 */
struct __ns1__IV_USCOREDataCollection;	/* MESWebService.h:1662 */
struct __ns1__jKoIVMoveStd_USCOREPasan;	/* MESWebService.h:1733 */
struct __ns1__jKoIVMoveStd_USCORESpire;	/* MESWebService.h:1804 */
struct __ns1__ELPictureAddress;	/* MESWebService.h:1875 */
struct __ns1__ELInfoMoveStd;	/* MESWebService.h:1946 */
struct __ns1__SafetyInfoMoveStd;	/* MESWebService.h:2017 */
struct __ns1__UploadTensileInfoToMes;	/* MESWebService.h:2088 */
struct __ns1__GetContainerDataInfoMES;	/* MESWebService.h:2159 */
struct __ns1__GetTensileTestRule;	/* MESWebService.h:2230 */
struct __ns1__Iscalibrationcontainer;	/* MESWebService.h:2301 */
struct __ns1__GetFtpAddress;	/* MESWebService.h:2372 */
struct __ns1__GetDefectInfoToSAP;	/* MESWebService.h:2443 */
struct __ns1__SetDefectResultToMES;	/* MESWebService.h:2514 */
struct __ns1__SetMaterialBatchResultToMES;	/* MESWebService.h:2585 */
struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs;	/* MESWebService.h:2656 */
struct __ns1__CanLogin;	/* MESWebService.h:2726 */
struct __ns1__Login;	/* MESWebService.h:2796 */
struct __ns1__GetWorkCenterID_;	/* MESWebService.h:2867 */
struct __ns1__GetCurrentSpecBySn_;	/* MESWebService.h:2938 */
struct __ns1__IV_USCOREDataCollection_;	/* MESWebService.h:3009 */
struct __ns1__jKoIVMoveStd_USCOREPasan_;	/* MESWebService.h:3080 */
struct __ns1__jKoIVMoveStd_USCORESpire_;	/* MESWebService.h:3151 */
struct __ns1__ELPictureAddress_;	/* MESWebService.h:3222 */
struct __ns1__ELInfoMoveStd_;	/* MESWebService.h:3293 */
struct __ns1__SafetyInfoMoveStd_;	/* MESWebService.h:3364 */
struct __ns1__UploadTensileInfoToMes_;	/* MESWebService.h:3435 */
struct __ns1__GetContainerDataInfoMES_;	/* MESWebService.h:3506 */
struct __ns1__GetTensileTestRule_;	/* MESWebService.h:3577 */
struct __ns1__Iscalibrationcontainer_;	/* MESWebService.h:3648 */
struct __ns1__GetFtpAddress_;	/* MESWebService.h:3719 */
struct __ns1__GetDefectInfoToSAP_;	/* MESWebService.h:3790 */
struct __ns1__SetDefectResultToMES_;	/* MESWebService.h:3861 */
struct __ns1__SetMaterialBatchResultToMES_;	/* MESWebService.h:3932 */
struct __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_;	/* MESWebService.h:4003 */
struct __ns1__CanLogin_;	/* MESWebService.h:4073 */
struct __ns1__Login_;	/* MESWebService.h:4143 */

/* MESWebService.h:332 */
#ifndef SOAP_TYPE__ns1__SubmitResult_ResultTable
#define SOAP_TYPE__ns1__SubmitResult_ResultTable (57)
/* complex XSD type 'ns1:SubmitResult-ResultTable': */
class SOAP_CMAC _ns1__SubmitResult_ResultTable {
      public:
        std::vector<char *> __any;
        char *__any_;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SubmitResult_ResultTable
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__SubmitResult_ResultTable; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SubmitResult_ResultTable, default initialized and not managed by a soap context
        virtual _ns1__SubmitResult_ResultTable *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__SubmitResult_ResultTable); }
      public:
        /// Constructor with initializations
        _ns1__SubmitResult_ResultTable() : __any(), __any_() { }
        virtual ~_ns1__SubmitResult_ResultTable() { }
        /// Friend allocator used by soap_new__ns1__SubmitResult_ResultTable(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SubmitResult_ResultTable * SOAP_FMAC2 soap_instantiate__ns1__SubmitResult_ResultTable(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:151 */
#ifndef SOAP_TYPE_ns1__SubmitResult
#define SOAP_TYPE_ns1__SubmitResult (10)
/* complex XSD type 'ns1:SubmitResult': */
class SOAP_CMAC ns1__SubmitResult {
      public:
        /// Optional element 'ns1:ResultCode' of XSD type 'xsd:string'
        std::string *ResultCode;
        /// Optional element 'ns1:ResultMsg' of XSD type 'xsd:string'
        std::string *ResultMsg;
        /// Optional element 'ns1:ResultTable' of XSD type 'ns1:SubmitResult-ResultTable'
        _ns1__SubmitResult_ResultTable *ResultTable;
        /// Optional element 'ns1:ResultFilename' of XSD type 'xsd:string'
        std::string *ResultFilename;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SubmitResult
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__SubmitResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SubmitResult, default initialized and not managed by a soap context
        virtual ns1__SubmitResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__SubmitResult); }
      public:
        /// Constructor with initializations
        ns1__SubmitResult() : ResultCode(), ResultMsg(), ResultTable(), ResultFilename(), soap() { }
        virtual ~ns1__SubmitResult() { }
        /// Friend allocator used by soap_new_ns1__SubmitResult(struct soap*, int)
        friend SOAP_FMAC1 ns1__SubmitResult * SOAP_FMAC2 soap_instantiate_ns1__SubmitResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:154 */
#ifndef SOAP_TYPE_ns1__ArrayOfSubmitResult
#define SOAP_TYPE_ns1__ArrayOfSubmitResult (11)
/* complex XSD type 'ns1:ArrayOfSubmitResult': */
class SOAP_CMAC ns1__ArrayOfSubmitResult {
      public:
        /// Optional element 'ns1:SubmitResult' of XSD type 'ns1:SubmitResult'
        std::vector<ns1__SubmitResult *> SubmitResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfSubmitResult
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfSubmitResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfSubmitResult, default initialized and not managed by a soap context
        virtual ns1__ArrayOfSubmitResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfSubmitResult); }
      public:
        /// Constructor with initializations
        ns1__ArrayOfSubmitResult() : SubmitResult(), soap() { }
        virtual ~ns1__ArrayOfSubmitResult() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfSubmitResult(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfSubmitResult * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfSubmitResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:157 */
#ifndef SOAP_TYPE_ns1__ArrayOfDefectResultInfo
#define SOAP_TYPE_ns1__ArrayOfDefectResultInfo (12)
/* complex XSD type 'ns1:ArrayOfDefectResultInfo': */
class SOAP_CMAC ns1__ArrayOfDefectResultInfo {
      public:
        /// Optional element 'ns1:DefectResultInfo' of XSD type 'ns1:DefectResultInfo'
        std::vector<ns1__DefectResultInfo *> DefectResultInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfDefectResultInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfDefectResultInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfDefectResultInfo, default initialized and not managed by a soap context
        virtual ns1__ArrayOfDefectResultInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfDefectResultInfo); }
      public:
        /// Constructor with initializations
        ns1__ArrayOfDefectResultInfo() : DefectResultInfo(), soap() { }
        virtual ~ns1__ArrayOfDefectResultInfo() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfDefectResultInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfDefectResultInfo * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfDefectResultInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:160 */
#ifndef SOAP_TYPE_ns1__DefectResultInfo
#define SOAP_TYPE_ns1__DefectResultInfo (13)
/* complex XSD type 'ns1:DefectResultInfo': */
class SOAP_CMAC ns1__DefectResultInfo {
      public:
        /// Optional element 'ns1:RECORD_ID' of XSD type 'xsd:string'
        std::string *RECORD_USCOREID;
        /// Optional element 'ns1:DATAFLAG' of XSD type 'xsd:string'
        std::string *DATAFLAG;
        /// Optional element 'ns1:MESSAGE' of XSD type 'xsd:string'
        std::string *MESSAGE;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DefectResultInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__DefectResultInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DefectResultInfo, default initialized and not managed by a soap context
        virtual ns1__DefectResultInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__DefectResultInfo); }
      public:
        /// Constructor with initializations
        ns1__DefectResultInfo() : RECORD_USCOREID(), DATAFLAG(), MESSAGE(), soap() { }
        virtual ~ns1__DefectResultInfo() { }
        /// Friend allocator used by soap_new_ns1__DefectResultInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__DefectResultInfo * SOAP_FMAC2 soap_instantiate_ns1__DefectResultInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:163 */
#ifndef SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo
#define SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo (14)
/* complex XSD type 'ns1:ArrayOfMaterialBatchResultInfo': */
class SOAP_CMAC ns1__ArrayOfMaterialBatchResultInfo {
      public:
        /// Optional element 'ns1:MaterialBatchResultInfo' of XSD type 'ns1:MaterialBatchResultInfo'
        std::vector<ns1__MaterialBatchResultInfo *> MaterialBatchResultInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfMaterialBatchResultInfo, default initialized and not managed by a soap context
        virtual ns1__ArrayOfMaterialBatchResultInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfMaterialBatchResultInfo); }
      public:
        /// Constructor with initializations
        ns1__ArrayOfMaterialBatchResultInfo() : MaterialBatchResultInfo(), soap() { }
        virtual ~ns1__ArrayOfMaterialBatchResultInfo() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfMaterialBatchResultInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfMaterialBatchResultInfo * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfMaterialBatchResultInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:166 */
#ifndef SOAP_TYPE_ns1__MaterialBatchResultInfo
#define SOAP_TYPE_ns1__MaterialBatchResultInfo (15)
/* complex XSD type 'ns1:MaterialBatchResultInfo': */
class SOAP_CMAC ns1__MaterialBatchResultInfo {
      public:
        /// Required element 'ns1:RECORD_ID' of XSD type 'xsd:decimal'
        std::string RECORD_USCOREID;
        /// Required element 'ns1:DATAFLAG' of XSD type 'xsd:decimal'
        std::string DATAFLAG;
        /// Optional element 'ns1:MESSAGE' of XSD type 'xsd:string'
        std::string *MESSAGE;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MaterialBatchResultInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__MaterialBatchResultInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MaterialBatchResultInfo, default initialized and not managed by a soap context
        virtual ns1__MaterialBatchResultInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__MaterialBatchResultInfo); }
      public:
        /// Constructor with initializations
        ns1__MaterialBatchResultInfo() : RECORD_USCOREID(), DATAFLAG(), MESSAGE(), soap() { }
        virtual ~ns1__MaterialBatchResultInfo() { }
        /// Friend allocator used by soap_new_ns1__MaterialBatchResultInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__MaterialBatchResultInfo * SOAP_FMAC2 soap_instantiate_ns1__MaterialBatchResultInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:169 */
#ifndef SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity
#define SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity (16)
/* complex XSD type 'ns1:ArrayOfFIDailyWorkReturnEntity': */
class SOAP_CMAC ns1__ArrayOfFIDailyWorkReturnEntity {
      public:
        /// Optional element 'ns1:FIDailyWorkReturnEntity' of XSD type 'ns1:FIDailyWorkReturnEntity'
        std::vector<ns1__FIDailyWorkReturnEntity *> FIDailyWorkReturnEntity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfFIDailyWorkReturnEntity, default initialized and not managed by a soap context
        virtual ns1__ArrayOfFIDailyWorkReturnEntity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfFIDailyWorkReturnEntity); }
      public:
        /// Constructor with initializations
        ns1__ArrayOfFIDailyWorkReturnEntity() : FIDailyWorkReturnEntity(), soap() { }
        virtual ~ns1__ArrayOfFIDailyWorkReturnEntity() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfFIDailyWorkReturnEntity(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfFIDailyWorkReturnEntity * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfFIDailyWorkReturnEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:172 */
#ifndef SOAP_TYPE_ns1__FIDailyWorkReturnEntity
#define SOAP_TYPE_ns1__FIDailyWorkReturnEntity (17)
/* complex XSD type 'ns1:FIDailyWorkReturnEntity': */
class SOAP_CMAC ns1__FIDailyWorkReturnEntity {
      public:
        /// Optional element 'ns1:RECORD_ID' of XSD type 'xsd:string'
        std::string *RECORD_USCOREID;
        /// Required element 'ns1:DATAFLAG' of XSD type 'xsd:decimal'
        std::string DATAFLAG;
        /// Optional element 'ns1:MESSAGE' of XSD type 'xsd:string'
        std::string *MESSAGE;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FIDailyWorkReturnEntity
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__FIDailyWorkReturnEntity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FIDailyWorkReturnEntity, default initialized and not managed by a soap context
        virtual ns1__FIDailyWorkReturnEntity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__FIDailyWorkReturnEntity); }
      public:
        /// Constructor with initializations
        ns1__FIDailyWorkReturnEntity() : RECORD_USCOREID(), DATAFLAG(), MESSAGE(), soap() { }
        virtual ~ns1__FIDailyWorkReturnEntity() { }
        /// Friend allocator used by soap_new_ns1__FIDailyWorkReturnEntity(struct soap*, int)
        friend SOAP_FMAC1 ns1__FIDailyWorkReturnEntity * SOAP_FMAC2 soap_instantiate_ns1__FIDailyWorkReturnEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:175 */
#ifndef SOAP_TYPE__ns1__GetWorkCenterID
#define SOAP_TYPE__ns1__GetWorkCenterID (18)
/* complex XSD type 'ns1:GetWorkCenterID': */
class SOAP_CMAC _ns1__GetWorkCenterID {
      public:
        /// Optional element 'ns1:ContainerName' of XSD type 'xsd:string'
        std::string *ContainerName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetWorkCenterID
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetWorkCenterID; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetWorkCenterID, default initialized and not managed by a soap context
        virtual _ns1__GetWorkCenterID *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetWorkCenterID); }
      public:
        /// Constructor with initializations
        _ns1__GetWorkCenterID() : ContainerName(), soap() { }
        virtual ~_ns1__GetWorkCenterID() { }
        /// Friend allocator used by soap_new__ns1__GetWorkCenterID(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetWorkCenterID * SOAP_FMAC2 soap_instantiate__ns1__GetWorkCenterID(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:178 */
#ifndef SOAP_TYPE__ns1__GetWorkCenterIDResponse
#define SOAP_TYPE__ns1__GetWorkCenterIDResponse (19)
/* complex XSD type 'ns1:GetWorkCenterIDResponse': */
class SOAP_CMAC _ns1__GetWorkCenterIDResponse {
      public:
        /// Optional element 'ns1:GetWorkCenterIDResult' of XSD type 'ns1:SubmitResult'
        ns1__SubmitResult *GetWorkCenterIDResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetWorkCenterIDResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetWorkCenterIDResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetWorkCenterIDResponse, default initialized and not managed by a soap context
        virtual _ns1__GetWorkCenterIDResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetWorkCenterIDResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetWorkCenterIDResponse() : GetWorkCenterIDResult(), soap() { }
        virtual ~_ns1__GetWorkCenterIDResponse() { }
        /// Friend allocator used by soap_new__ns1__GetWorkCenterIDResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetWorkCenterIDResponse * SOAP_FMAC2 soap_instantiate__ns1__GetWorkCenterIDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:181 */
#ifndef SOAP_TYPE__ns1__GetCurrentSpecBySn
#define SOAP_TYPE__ns1__GetCurrentSpecBySn (20)
/* complex XSD type 'ns1:GetCurrentSpecBySn': */
class SOAP_CMAC _ns1__GetCurrentSpecBySn {
      public:
        /// Optional element 'ns1:ContainerName' of XSD type 'xsd:string'
        std::string *ContainerName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCurrentSpecBySn
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetCurrentSpecBySn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCurrentSpecBySn, default initialized and not managed by a soap context
        virtual _ns1__GetCurrentSpecBySn *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetCurrentSpecBySn); }
      public:
        /// Constructor with initializations
        _ns1__GetCurrentSpecBySn() : ContainerName(), soap() { }
        virtual ~_ns1__GetCurrentSpecBySn() { }
        /// Friend allocator used by soap_new__ns1__GetCurrentSpecBySn(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCurrentSpecBySn * SOAP_FMAC2 soap_instantiate__ns1__GetCurrentSpecBySn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:184 */
#ifndef SOAP_TYPE__ns1__GetCurrentSpecBySnResponse
#define SOAP_TYPE__ns1__GetCurrentSpecBySnResponse (21)
/* complex XSD type 'ns1:GetCurrentSpecBySnResponse': */
class SOAP_CMAC _ns1__GetCurrentSpecBySnResponse {
      public:
        /// Optional element 'ns1:GetCurrentSpecBySnResult' of XSD type 'ns1:SubmitResult'
        ns1__SubmitResult *GetCurrentSpecBySnResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetCurrentSpecBySnResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetCurrentSpecBySnResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetCurrentSpecBySnResponse, default initialized and not managed by a soap context
        virtual _ns1__GetCurrentSpecBySnResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetCurrentSpecBySnResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetCurrentSpecBySnResponse() : GetCurrentSpecBySnResult(), soap() { }
        virtual ~_ns1__GetCurrentSpecBySnResponse() { }
        /// Friend allocator used by soap_new__ns1__GetCurrentSpecBySnResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetCurrentSpecBySnResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCurrentSpecBySnResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:187 */
#ifndef SOAP_TYPE__ns1__IV_USCOREDataCollection
#define SOAP_TYPE__ns1__IV_USCOREDataCollection (22)
/* complex XSD type 'ns1:IV_DataCollection': */
class SOAP_CMAC _ns1__IV_USCOREDataCollection {
      public:
        /// Optional element 'ns1:TestData' of XSD type 'xsd:string'
        std::string *TestData;
        /// Optional element 'ns1:LotSN' of XSD type 'xsd:string'
        std::string *LotSN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__IV_USCOREDataCollection
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__IV_USCOREDataCollection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__IV_USCOREDataCollection, default initialized and not managed by a soap context
        virtual _ns1__IV_USCOREDataCollection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__IV_USCOREDataCollection); }
      public:
        /// Constructor with initializations
        _ns1__IV_USCOREDataCollection() : TestData(), LotSN(), soap() { }
        virtual ~_ns1__IV_USCOREDataCollection() { }
        /// Friend allocator used by soap_new__ns1__IV_USCOREDataCollection(struct soap*, int)
        friend SOAP_FMAC1 _ns1__IV_USCOREDataCollection * SOAP_FMAC2 soap_instantiate__ns1__IV_USCOREDataCollection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:190 */
#ifndef SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse
#define SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse (23)
/* complex XSD type 'ns1:IV_DataCollectionResponse': */
class SOAP_CMAC _ns1__IV_USCOREDataCollectionResponse {
      public:
        /// Optional element 'ns1:IV_DataCollectionResult' of XSD type 'ns1:SubmitResult'
        ns1__SubmitResult *IV_USCOREDataCollectionResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__IV_USCOREDataCollectionResponse, default initialized and not managed by a soap context
        virtual _ns1__IV_USCOREDataCollectionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__IV_USCOREDataCollectionResponse); }
      public:
        /// Constructor with initializations
        _ns1__IV_USCOREDataCollectionResponse() : IV_USCOREDataCollectionResult(), soap() { }
        virtual ~_ns1__IV_USCOREDataCollectionResponse() { }
        /// Friend allocator used by soap_new__ns1__IV_USCOREDataCollectionResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__IV_USCOREDataCollectionResponse * SOAP_FMAC2 soap_instantiate__ns1__IV_USCOREDataCollectionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:193 */
#ifndef SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan
#define SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan (24)
/* complex XSD type 'ns1:jKoIVMoveStd_Pasan': */
class SOAP_CMAC _ns1__jKoIVMoveStd_USCOREPasan {
      public:
        /// Optional element 'ns1:LotSN' of XSD type 'xsd:string'
        std::string *LotSN;
        /// Optional element 'ns1:IVDataCollect' of XSD type 'xsd:string'
        std::string *IVDataCollect;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__jKoIVMoveStd_USCOREPasan, default initialized and not managed by a soap context
        virtual _ns1__jKoIVMoveStd_USCOREPasan *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__jKoIVMoveStd_USCOREPasan); }
      public:
        /// Constructor with initializations
        _ns1__jKoIVMoveStd_USCOREPasan() : LotSN(), IVDataCollect(), soap() { }
        virtual ~_ns1__jKoIVMoveStd_USCOREPasan() { }
        /// Friend allocator used by soap_new__ns1__jKoIVMoveStd_USCOREPasan(struct soap*, int)
        friend SOAP_FMAC1 _ns1__jKoIVMoveStd_USCOREPasan * SOAP_FMAC2 soap_instantiate__ns1__jKoIVMoveStd_USCOREPasan(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:196 */
#ifndef SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse
#define SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse (25)
/* complex XSD type 'ns1:jKoIVMoveStd_PasanResponse': */
class SOAP_CMAC _ns1__jKoIVMoveStd_USCOREPasanResponse {
      public:
        /// Optional element 'ns1:jKoIVMoveStd_PasanResult' of XSD type 'ns1:SubmitResult'
        ns1__SubmitResult *jKoIVMoveStd_USCOREPasanResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__jKoIVMoveStd_USCOREPasanResponse, default initialized and not managed by a soap context
        virtual _ns1__jKoIVMoveStd_USCOREPasanResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__jKoIVMoveStd_USCOREPasanResponse); }
      public:
        /// Constructor with initializations
        _ns1__jKoIVMoveStd_USCOREPasanResponse() : jKoIVMoveStd_USCOREPasanResult(), soap() { }
        virtual ~_ns1__jKoIVMoveStd_USCOREPasanResponse() { }
        /// Friend allocator used by soap_new__ns1__jKoIVMoveStd_USCOREPasanResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__jKoIVMoveStd_USCOREPasanResponse * SOAP_FMAC2 soap_instantiate__ns1__jKoIVMoveStd_USCOREPasanResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:199 */
#ifndef SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire
#define SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire (26)
/* complex XSD type 'ns1:jKoIVMoveStd_Spire': */
class SOAP_CMAC _ns1__jKoIVMoveStd_USCORESpire {
      public:
        /// Optional element 'ns1:LotSN' of XSD type 'xsd:string'
        std::string *LotSN;
        /// Optional element 'ns1:IVDataCollect' of XSD type 'xsd:string'
        std::string *IVDataCollect;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__jKoIVMoveStd_USCORESpire, default initialized and not managed by a soap context
        virtual _ns1__jKoIVMoveStd_USCORESpire *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__jKoIVMoveStd_USCORESpire); }
      public:
        /// Constructor with initializations
        _ns1__jKoIVMoveStd_USCORESpire() : LotSN(), IVDataCollect(), soap() { }
        virtual ~_ns1__jKoIVMoveStd_USCORESpire() { }
        /// Friend allocator used by soap_new__ns1__jKoIVMoveStd_USCORESpire(struct soap*, int)
        friend SOAP_FMAC1 _ns1__jKoIVMoveStd_USCORESpire * SOAP_FMAC2 soap_instantiate__ns1__jKoIVMoveStd_USCORESpire(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:202 */
#ifndef SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse
#define SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse (27)
/* complex XSD type 'ns1:jKoIVMoveStd_SpireResponse': */
class SOAP_CMAC _ns1__jKoIVMoveStd_USCORESpireResponse {
      public:
        /// Optional element 'ns1:jKoIVMoveStd_SpireResult' of XSD type 'ns1:SubmitResult'
        ns1__SubmitResult *jKoIVMoveStd_USCORESpireResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__jKoIVMoveStd_USCORESpireResponse, default initialized and not managed by a soap context
        virtual _ns1__jKoIVMoveStd_USCORESpireResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__jKoIVMoveStd_USCORESpireResponse); }
      public:
        /// Constructor with initializations
        _ns1__jKoIVMoveStd_USCORESpireResponse() : jKoIVMoveStd_USCORESpireResult(), soap() { }
        virtual ~_ns1__jKoIVMoveStd_USCORESpireResponse() { }
        /// Friend allocator used by soap_new__ns1__jKoIVMoveStd_USCORESpireResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__jKoIVMoveStd_USCORESpireResponse * SOAP_FMAC2 soap_instantiate__ns1__jKoIVMoveStd_USCORESpireResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:205 */
#ifndef SOAP_TYPE__ns1__ELPictureAddress
#define SOAP_TYPE__ns1__ELPictureAddress (28)
/* complex XSD type 'ns1:ELPictureAddress': */
class SOAP_CMAC _ns1__ELPictureAddress {
      public:
        /// Optional element 'ns1:LotSn' of XSD type 'xsd:string'
        std::string *LotSn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ELPictureAddress
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ELPictureAddress; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ELPictureAddress, default initialized and not managed by a soap context
        virtual _ns1__ELPictureAddress *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__ELPictureAddress); }
      public:
        /// Constructor with initializations
        _ns1__ELPictureAddress() : LotSn(), soap() { }
        virtual ~_ns1__ELPictureAddress() { }
        /// Friend allocator used by soap_new__ns1__ELPictureAddress(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ELPictureAddress * SOAP_FMAC2 soap_instantiate__ns1__ELPictureAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:208 */
#ifndef SOAP_TYPE__ns1__ELPictureAddressResponse
#define SOAP_TYPE__ns1__ELPictureAddressResponse (29)
/* complex XSD type 'ns1:ELPictureAddressResponse': */
class SOAP_CMAC _ns1__ELPictureAddressResponse {
      public:
        /// Optional element 'ns1:ELPictureAddressResult' of XSD type 'xsd:string'
        std::string *ELPictureAddressResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ELPictureAddressResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ELPictureAddressResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ELPictureAddressResponse, default initialized and not managed by a soap context
        virtual _ns1__ELPictureAddressResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__ELPictureAddressResponse); }
      public:
        /// Constructor with initializations
        _ns1__ELPictureAddressResponse() : ELPictureAddressResult(), soap() { }
        virtual ~_ns1__ELPictureAddressResponse() { }
        /// Friend allocator used by soap_new__ns1__ELPictureAddressResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ELPictureAddressResponse * SOAP_FMAC2 soap_instantiate__ns1__ELPictureAddressResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:211 */
#ifndef SOAP_TYPE__ns1__ELInfoMoveStd
#define SOAP_TYPE__ns1__ELInfoMoveStd (30)
/* complex XSD type 'ns1:ELInfoMoveStd': */
class SOAP_CMAC _ns1__ELInfoMoveStd {
      public:
        /// Optional element 'ns1:LotSN' of XSD type 'xsd:string'
        std::string *LotSN;
        /// Optional element 'ns1:TestData' of XSD type 'xsd:string'
        std::string *TestData;
        /// Optional element 'ns1:lstDefectInfo' of XSD type 'xsd:string'
        std::string *lstDefectInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ELInfoMoveStd
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ELInfoMoveStd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ELInfoMoveStd, default initialized and not managed by a soap context
        virtual _ns1__ELInfoMoveStd *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__ELInfoMoveStd); }
      public:
        /// Constructor with initializations
        _ns1__ELInfoMoveStd() : LotSN(), TestData(), lstDefectInfo(), soap() { }
        virtual ~_ns1__ELInfoMoveStd() { }
        /// Friend allocator used by soap_new__ns1__ELInfoMoveStd(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ELInfoMoveStd * SOAP_FMAC2 soap_instantiate__ns1__ELInfoMoveStd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:214 */
#ifndef SOAP_TYPE__ns1__ELInfoMoveStdResponse
#define SOAP_TYPE__ns1__ELInfoMoveStdResponse (31)
/* complex XSD type 'ns1:ELInfoMoveStdResponse': */
class SOAP_CMAC _ns1__ELInfoMoveStdResponse {
      public:
        /// Optional element 'ns1:ELInfoMoveStdResult' of XSD type 'ns1:SubmitResult'
        ns1__SubmitResult *ELInfoMoveStdResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ELInfoMoveStdResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ELInfoMoveStdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ELInfoMoveStdResponse, default initialized and not managed by a soap context
        virtual _ns1__ELInfoMoveStdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__ELInfoMoveStdResponse); }
      public:
        /// Constructor with initializations
        _ns1__ELInfoMoveStdResponse() : ELInfoMoveStdResult(), soap() { }
        virtual ~_ns1__ELInfoMoveStdResponse() { }
        /// Friend allocator used by soap_new__ns1__ELInfoMoveStdResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ELInfoMoveStdResponse * SOAP_FMAC2 soap_instantiate__ns1__ELInfoMoveStdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:217 */
#ifndef SOAP_TYPE__ns1__SafetyInfoMoveStd
#define SOAP_TYPE__ns1__SafetyInfoMoveStd (32)
/* complex XSD type 'ns1:SafetyInfoMoveStd': */
class SOAP_CMAC _ns1__SafetyInfoMoveStd {
      public:
        /// Required element 'ns1:TestDate' of XSD type 'xsd:dateTime'
        time_t TestDate;
        /// Optional element 'ns1:LotSN' of XSD type 'xsd:string'
        std::string *LotSN;
        /// Optional element 'ns1:Current' of XSD type 'xsd:string'
        std::string *Current;
        /// Optional element 'ns1:InsulationResistance' of XSD type 'xsd:string'
        std::string *InsulationResistance;
        /// Optional element 'ns1:GroundResistance' of XSD type 'xsd:string'
        std::string *GroundResistance;
        /// Optional element 'ns1:TestResult' of XSD type 'xsd:string'
        std::string *TestResult;
        /// Optional element 'ns1:IPAddress' of XSD type 'xsd:string'
        std::string *IPAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SafetyInfoMoveStd
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__SafetyInfoMoveStd; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SafetyInfoMoveStd, default initialized and not managed by a soap context
        virtual _ns1__SafetyInfoMoveStd *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__SafetyInfoMoveStd); }
      public:
        /// Constructor with initializations
        _ns1__SafetyInfoMoveStd() : TestDate(), LotSN(), Current(), InsulationResistance(), GroundResistance(), TestResult(), IPAddress(), soap() { }
        virtual ~_ns1__SafetyInfoMoveStd() { }
        /// Friend allocator used by soap_new__ns1__SafetyInfoMoveStd(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SafetyInfoMoveStd * SOAP_FMAC2 soap_instantiate__ns1__SafetyInfoMoveStd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:220 */
#ifndef SOAP_TYPE__ns1__SafetyInfoMoveStdResponse
#define SOAP_TYPE__ns1__SafetyInfoMoveStdResponse (33)
/* complex XSD type 'ns1:SafetyInfoMoveStdResponse': */
class SOAP_CMAC _ns1__SafetyInfoMoveStdResponse {
      public:
        /// Optional element 'ns1:SafetyInfoMoveStdResult' of XSD type 'ns1:SubmitResult'
        ns1__SubmitResult *SafetyInfoMoveStdResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SafetyInfoMoveStdResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__SafetyInfoMoveStdResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SafetyInfoMoveStdResponse, default initialized and not managed by a soap context
        virtual _ns1__SafetyInfoMoveStdResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__SafetyInfoMoveStdResponse); }
      public:
        /// Constructor with initializations
        _ns1__SafetyInfoMoveStdResponse() : SafetyInfoMoveStdResult(), soap() { }
        virtual ~_ns1__SafetyInfoMoveStdResponse() { }
        /// Friend allocator used by soap_new__ns1__SafetyInfoMoveStdResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SafetyInfoMoveStdResponse * SOAP_FMAC2 soap_instantiate__ns1__SafetyInfoMoveStdResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:223 */
#ifndef SOAP_TYPE__ns1__UploadTensileInfoToMes
#define SOAP_TYPE__ns1__UploadTensileInfoToMes (34)
/* complex XSD type 'ns1:UploadTensileInfoToMes': */
class SOAP_CMAC _ns1__UploadTensileInfoToMes {
      public:
        /// Optional element 'ns1:LotSn' of XSD type 'xsd:string'
        std::string *LotSn;
        /// Optional element 'ns1:TestData' of XSD type 'xsd:string'
        std::string *TestData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UploadTensileInfoToMes
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__UploadTensileInfoToMes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UploadTensileInfoToMes, default initialized and not managed by a soap context
        virtual _ns1__UploadTensileInfoToMes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__UploadTensileInfoToMes); }
      public:
        /// Constructor with initializations
        _ns1__UploadTensileInfoToMes() : LotSn(), TestData(), soap() { }
        virtual ~_ns1__UploadTensileInfoToMes() { }
        /// Friend allocator used by soap_new__ns1__UploadTensileInfoToMes(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UploadTensileInfoToMes * SOAP_FMAC2 soap_instantiate__ns1__UploadTensileInfoToMes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:226 */
#ifndef SOAP_TYPE__ns1__UploadTensileInfoToMesResponse
#define SOAP_TYPE__ns1__UploadTensileInfoToMesResponse (35)
/* complex XSD type 'ns1:UploadTensileInfoToMesResponse': */
class SOAP_CMAC _ns1__UploadTensileInfoToMesResponse {
      public:
        /// Optional element 'ns1:UploadTensileInfoToMesResult' of XSD type 'ns1:SubmitResult'
        ns1__SubmitResult *UploadTensileInfoToMesResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__UploadTensileInfoToMesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__UploadTensileInfoToMesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__UploadTensileInfoToMesResponse, default initialized and not managed by a soap context
        virtual _ns1__UploadTensileInfoToMesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__UploadTensileInfoToMesResponse); }
      public:
        /// Constructor with initializations
        _ns1__UploadTensileInfoToMesResponse() : UploadTensileInfoToMesResult(), soap() { }
        virtual ~_ns1__UploadTensileInfoToMesResponse() { }
        /// Friend allocator used by soap_new__ns1__UploadTensileInfoToMesResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__UploadTensileInfoToMesResponse * SOAP_FMAC2 soap_instantiate__ns1__UploadTensileInfoToMesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:229 */
#ifndef SOAP_TYPE__ns1__GetContainerDataInfoMES
#define SOAP_TYPE__ns1__GetContainerDataInfoMES (36)
/* complex XSD type 'ns1:GetContainerDataInfoMES': */
class SOAP_CMAC _ns1__GetContainerDataInfoMES {
      public:
        /// Optional element 'ns1:ContainerName' of XSD type 'xsd:string'
        std::string *ContainerName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetContainerDataInfoMES
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetContainerDataInfoMES; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetContainerDataInfoMES, default initialized and not managed by a soap context
        virtual _ns1__GetContainerDataInfoMES *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetContainerDataInfoMES); }
      public:
        /// Constructor with initializations
        _ns1__GetContainerDataInfoMES() : ContainerName(), soap() { }
        virtual ~_ns1__GetContainerDataInfoMES() { }
        /// Friend allocator used by soap_new__ns1__GetContainerDataInfoMES(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetContainerDataInfoMES * SOAP_FMAC2 soap_instantiate__ns1__GetContainerDataInfoMES(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:232 */
#ifndef SOAP_TYPE__ns1__GetContainerDataInfoMESResponse
#define SOAP_TYPE__ns1__GetContainerDataInfoMESResponse (37)
/* complex XSD type 'ns1:GetContainerDataInfoMESResponse': */
class SOAP_CMAC _ns1__GetContainerDataInfoMESResponse {
      public:
        /// Optional element 'ns1:GetContainerDataInfoMESResult' of XSD type 'ns1:ArrayOfSubmitResult'
        ns1__ArrayOfSubmitResult *GetContainerDataInfoMESResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetContainerDataInfoMESResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetContainerDataInfoMESResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetContainerDataInfoMESResponse, default initialized and not managed by a soap context
        virtual _ns1__GetContainerDataInfoMESResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetContainerDataInfoMESResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetContainerDataInfoMESResponse() : GetContainerDataInfoMESResult(), soap() { }
        virtual ~_ns1__GetContainerDataInfoMESResponse() { }
        /// Friend allocator used by soap_new__ns1__GetContainerDataInfoMESResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetContainerDataInfoMESResponse * SOAP_FMAC2 soap_instantiate__ns1__GetContainerDataInfoMESResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:235 */
#ifndef SOAP_TYPE__ns1__GetTensileTestRule
#define SOAP_TYPE__ns1__GetTensileTestRule (38)
/* complex XSD type 'ns1:GetTensileTestRule': */
class SOAP_CMAC _ns1__GetTensileTestRule {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetTensileTestRule
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetTensileTestRule; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetTensileTestRule, default initialized and not managed by a soap context
        virtual _ns1__GetTensileTestRule *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetTensileTestRule); }
      public:
        /// Constructor with initializations
        _ns1__GetTensileTestRule() : soap() { }
        virtual ~_ns1__GetTensileTestRule() { }
        /// Friend allocator used by soap_new__ns1__GetTensileTestRule(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetTensileTestRule * SOAP_FMAC2 soap_instantiate__ns1__GetTensileTestRule(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:238 */
#ifndef SOAP_TYPE__ns1__GetTensileTestRuleResponse
#define SOAP_TYPE__ns1__GetTensileTestRuleResponse (39)
/* complex XSD type 'ns1:GetTensileTestRuleResponse': */
class SOAP_CMAC _ns1__GetTensileTestRuleResponse {
      public:
        /// Optional element 'ns1:GetTensileTestRuleResult' of XSD type 'ns1:SubmitResult'
        ns1__SubmitResult *GetTensileTestRuleResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetTensileTestRuleResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetTensileTestRuleResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetTensileTestRuleResponse, default initialized and not managed by a soap context
        virtual _ns1__GetTensileTestRuleResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetTensileTestRuleResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetTensileTestRuleResponse() : GetTensileTestRuleResult(), soap() { }
        virtual ~_ns1__GetTensileTestRuleResponse() { }
        /// Friend allocator used by soap_new__ns1__GetTensileTestRuleResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetTensileTestRuleResponse * SOAP_FMAC2 soap_instantiate__ns1__GetTensileTestRuleResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:241 */
#ifndef SOAP_TYPE__ns1__Iscalibrationcontainer
#define SOAP_TYPE__ns1__Iscalibrationcontainer (40)
/* complex XSD type 'ns1:Iscalibrationcontainer': */
class SOAP_CMAC _ns1__Iscalibrationcontainer {
      public:
        /// Optional element 'ns1:ContainerName' of XSD type 'xsd:string'
        std::string *ContainerName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Iscalibrationcontainer
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Iscalibrationcontainer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Iscalibrationcontainer, default initialized and not managed by a soap context
        virtual _ns1__Iscalibrationcontainer *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Iscalibrationcontainer); }
      public:
        /// Constructor with initializations
        _ns1__Iscalibrationcontainer() : ContainerName(), soap() { }
        virtual ~_ns1__Iscalibrationcontainer() { }
        /// Friend allocator used by soap_new__ns1__Iscalibrationcontainer(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Iscalibrationcontainer * SOAP_FMAC2 soap_instantiate__ns1__Iscalibrationcontainer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:244 */
#ifndef SOAP_TYPE__ns1__IscalibrationcontainerResponse
#define SOAP_TYPE__ns1__IscalibrationcontainerResponse (41)
/* complex XSD type 'ns1:IscalibrationcontainerResponse': */
class SOAP_CMAC _ns1__IscalibrationcontainerResponse {
      public:
        /// Optional element 'ns1:IscalibrationcontainerResult' of XSD type 'ns1:SubmitResult'
        ns1__SubmitResult *IscalibrationcontainerResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__IscalibrationcontainerResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__IscalibrationcontainerResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__IscalibrationcontainerResponse, default initialized and not managed by a soap context
        virtual _ns1__IscalibrationcontainerResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__IscalibrationcontainerResponse); }
      public:
        /// Constructor with initializations
        _ns1__IscalibrationcontainerResponse() : IscalibrationcontainerResult(), soap() { }
        virtual ~_ns1__IscalibrationcontainerResponse() { }
        /// Friend allocator used by soap_new__ns1__IscalibrationcontainerResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__IscalibrationcontainerResponse * SOAP_FMAC2 soap_instantiate__ns1__IscalibrationcontainerResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:247 */
#ifndef SOAP_TYPE__ns1__GetFtpAddress
#define SOAP_TYPE__ns1__GetFtpAddress (42)
/* complex XSD type 'ns1:GetFtpAddress': */
class SOAP_CMAC _ns1__GetFtpAddress {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetFtpAddress
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetFtpAddress; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetFtpAddress, default initialized and not managed by a soap context
        virtual _ns1__GetFtpAddress *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetFtpAddress); }
      public:
        /// Constructor with initializations
        _ns1__GetFtpAddress() : soap() { }
        virtual ~_ns1__GetFtpAddress() { }
        /// Friend allocator used by soap_new__ns1__GetFtpAddress(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetFtpAddress * SOAP_FMAC2 soap_instantiate__ns1__GetFtpAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:250 */
#ifndef SOAP_TYPE__ns1__GetFtpAddressResponse
#define SOAP_TYPE__ns1__GetFtpAddressResponse (43)
/* complex XSD type 'ns1:GetFtpAddressResponse': */
class SOAP_CMAC _ns1__GetFtpAddressResponse {
      public:
        /// Optional element 'ns1:GetFtpAddressResult' of XSD type 'ns1:SubmitResult'
        ns1__SubmitResult *GetFtpAddressResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetFtpAddressResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetFtpAddressResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetFtpAddressResponse, default initialized and not managed by a soap context
        virtual _ns1__GetFtpAddressResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetFtpAddressResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetFtpAddressResponse() : GetFtpAddressResult(), soap() { }
        virtual ~_ns1__GetFtpAddressResponse() { }
        /// Friend allocator used by soap_new__ns1__GetFtpAddressResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetFtpAddressResponse * SOAP_FMAC2 soap_instantiate__ns1__GetFtpAddressResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:253 */
#ifndef SOAP_TYPE__ns1__GetDefectInfoToSAP
#define SOAP_TYPE__ns1__GetDefectInfoToSAP (44)
/* complex XSD type 'ns1:GetDefectInfoToSAP': */
class SOAP_CMAC _ns1__GetDefectInfoToSAP {
      public:
        /// Optional element 'ns1:UserName' of XSD type 'xsd:string'
        std::string *UserName;
        /// Optional element 'ns1:Password' of XSD type 'xsd:string'
        std::string *Password;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDefectInfoToSAP
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetDefectInfoToSAP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDefectInfoToSAP, default initialized and not managed by a soap context
        virtual _ns1__GetDefectInfoToSAP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetDefectInfoToSAP); }
      public:
        /// Constructor with initializations
        _ns1__GetDefectInfoToSAP() : UserName(), Password(), soap() { }
        virtual ~_ns1__GetDefectInfoToSAP() { }
        /// Friend allocator used by soap_new__ns1__GetDefectInfoToSAP(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDefectInfoToSAP * SOAP_FMAC2 soap_instantiate__ns1__GetDefectInfoToSAP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:256 */
#ifndef SOAP_TYPE__ns1__GetDefectInfoToSAPResponse
#define SOAP_TYPE__ns1__GetDefectInfoToSAPResponse (45)
/* complex XSD type 'ns1:GetDefectInfoToSAPResponse': */
class SOAP_CMAC _ns1__GetDefectInfoToSAPResponse {
      public:
        /// Optional element 'ns1:GetDefectInfoToSAPResult' of XSD type 'ns1:SubmitResult'
        ns1__SubmitResult *GetDefectInfoToSAPResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetDefectInfoToSAPResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetDefectInfoToSAPResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetDefectInfoToSAPResponse, default initialized and not managed by a soap context
        virtual _ns1__GetDefectInfoToSAPResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetDefectInfoToSAPResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetDefectInfoToSAPResponse() : GetDefectInfoToSAPResult(), soap() { }
        virtual ~_ns1__GetDefectInfoToSAPResponse() { }
        /// Friend allocator used by soap_new__ns1__GetDefectInfoToSAPResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetDefectInfoToSAPResponse * SOAP_FMAC2 soap_instantiate__ns1__GetDefectInfoToSAPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:259 */
#ifndef SOAP_TYPE__ns1__SetDefectResultToMES
#define SOAP_TYPE__ns1__SetDefectResultToMES (46)
/* complex XSD type 'ns1:SetDefectResultToMES': */
class SOAP_CMAC _ns1__SetDefectResultToMES {
      public:
        /// Optional element 'ns1:UserName' of XSD type 'xsd:string'
        std::string *UserName;
        /// Optional element 'ns1:Password' of XSD type 'xsd:string'
        std::string *Password;
        /// Optional element 'ns1:lstDefectResultInfo' of XSD type 'ns1:ArrayOfDefectResultInfo'
        ns1__ArrayOfDefectResultInfo *lstDefectResultInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetDefectResultToMES
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__SetDefectResultToMES; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetDefectResultToMES, default initialized and not managed by a soap context
        virtual _ns1__SetDefectResultToMES *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__SetDefectResultToMES); }
      public:
        /// Constructor with initializations
        _ns1__SetDefectResultToMES() : UserName(), Password(), lstDefectResultInfo(), soap() { }
        virtual ~_ns1__SetDefectResultToMES() { }
        /// Friend allocator used by soap_new__ns1__SetDefectResultToMES(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetDefectResultToMES * SOAP_FMAC2 soap_instantiate__ns1__SetDefectResultToMES(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:262 */
#ifndef SOAP_TYPE__ns1__SetDefectResultToMESResponse
#define SOAP_TYPE__ns1__SetDefectResultToMESResponse (47)
/* complex XSD type 'ns1:SetDefectResultToMESResponse': */
class SOAP_CMAC _ns1__SetDefectResultToMESResponse {
      public:
        /// Optional element 'ns1:SetDefectResultToMESResult' of XSD type 'ns1:ArrayOfSubmitResult'
        ns1__ArrayOfSubmitResult *SetDefectResultToMESResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetDefectResultToMESResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__SetDefectResultToMESResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetDefectResultToMESResponse, default initialized and not managed by a soap context
        virtual _ns1__SetDefectResultToMESResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__SetDefectResultToMESResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetDefectResultToMESResponse() : SetDefectResultToMESResult(), soap() { }
        virtual ~_ns1__SetDefectResultToMESResponse() { }
        /// Friend allocator used by soap_new__ns1__SetDefectResultToMESResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetDefectResultToMESResponse * SOAP_FMAC2 soap_instantiate__ns1__SetDefectResultToMESResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:265 */
#ifndef SOAP_TYPE__ns1__SetMaterialBatchResultToMES
#define SOAP_TYPE__ns1__SetMaterialBatchResultToMES (48)
/* complex XSD type 'ns1:SetMaterialBatchResultToMES': */
class SOAP_CMAC _ns1__SetMaterialBatchResultToMES {
      public:
        /// Optional element 'ns1:UserName' of XSD type 'xsd:string'
        std::string *UserName;
        /// Optional element 'ns1:Password' of XSD type 'xsd:string'
        std::string *Password;
        /// Optional element 'ns1:lstMaterialBatchResultInfo' of XSD type 'ns1:ArrayOfMaterialBatchResultInfo'
        ns1__ArrayOfMaterialBatchResultInfo *lstMaterialBatchResultInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetMaterialBatchResultToMES
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__SetMaterialBatchResultToMES; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetMaterialBatchResultToMES, default initialized and not managed by a soap context
        virtual _ns1__SetMaterialBatchResultToMES *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__SetMaterialBatchResultToMES); }
      public:
        /// Constructor with initializations
        _ns1__SetMaterialBatchResultToMES() : UserName(), Password(), lstMaterialBatchResultInfo(), soap() { }
        virtual ~_ns1__SetMaterialBatchResultToMES() { }
        /// Friend allocator used by soap_new__ns1__SetMaterialBatchResultToMES(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetMaterialBatchResultToMES * SOAP_FMAC2 soap_instantiate__ns1__SetMaterialBatchResultToMES(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:268 */
#ifndef SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse
#define SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse (49)
/* complex XSD type 'ns1:SetMaterialBatchResultToMESResponse': */
class SOAP_CMAC _ns1__SetMaterialBatchResultToMESResponse {
      public:
        /// Optional element 'ns1:SetMaterialBatchResultToMESResult' of XSD type 'ns1:ArrayOfSubmitResult'
        ns1__ArrayOfSubmitResult *SetMaterialBatchResultToMESResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SetMaterialBatchResultToMESResponse, default initialized and not managed by a soap context
        virtual _ns1__SetMaterialBatchResultToMESResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__SetMaterialBatchResultToMESResponse); }
      public:
        /// Constructor with initializations
        _ns1__SetMaterialBatchResultToMESResponse() : SetMaterialBatchResultToMESResult(), soap() { }
        virtual ~_ns1__SetMaterialBatchResultToMESResponse() { }
        /// Friend allocator used by soap_new__ns1__SetMaterialBatchResultToMESResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SetMaterialBatchResultToMESResponse * SOAP_FMAC2 soap_instantiate__ns1__SetMaterialBatchResultToMESResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:271 */
#ifndef SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs
#define SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs (50)
/* complex XSD type 'ns1:Upload_FIDWUL_DATAFLAGs': */
class SOAP_CMAC _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs {
      public:
        /// Optional element 'ns1:list' of XSD type 'ns1:ArrayOfFIDailyWorkReturnEntity'
        ns1__ArrayOfFIDailyWorkReturnEntity *list;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, default initialized and not managed by a soap context
        virtual _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs); }
      public:
        /// Constructor with initializations
        _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs() : list(), soap() { }
        virtual ~_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs() { }
        /// Friend allocator used by soap_new__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs * SOAP_FMAC2 soap_instantiate__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:274 */
#ifndef SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse
#define SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse (51)
/* complex XSD type 'ns1:Upload_FIDWUL_DATAFLAGsResponse': */
class SOAP_CMAC _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse {
      public:
        /// Optional element 'ns1:Upload_FIDWUL_DATAFLAGsResult' of XSD type 'xsd:string'
        std::string *Upload_USCOREFIDWUL_USCOREDATAFLAGsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse, default initialized and not managed by a soap context
        virtual _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse); }
      public:
        /// Constructor with initializations
        _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse() : Upload_USCOREFIDWUL_USCOREDATAFLAGsResult(), soap() { }
        virtual ~_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse() { }
        /// Friend allocator used by soap_new__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse * SOAP_FMAC2 soap_instantiate__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:277 */
#ifndef SOAP_TYPE__ns1__CanLogin
#define SOAP_TYPE__ns1__CanLogin (52)
/* complex XSD type 'ns1:CanLogin': */
class SOAP_CMAC _ns1__CanLogin {
      public:
        /// Optional element 'ns1:strUsername' of XSD type 'xsd:string'
        std::string *strUsername;
        /// Optional element 'ns1:strPassword' of XSD type 'xsd:string'
        std::string *strPassword;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CanLogin
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__CanLogin; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CanLogin, default initialized and not managed by a soap context
        virtual _ns1__CanLogin *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__CanLogin); }
      public:
        /// Constructor with initializations
        _ns1__CanLogin() : strUsername(), strPassword(), soap() { }
        virtual ~_ns1__CanLogin() { }
        /// Friend allocator used by soap_new__ns1__CanLogin(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CanLogin * SOAP_FMAC2 soap_instantiate__ns1__CanLogin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:280 */
#ifndef SOAP_TYPE__ns1__CanLoginResponse
#define SOAP_TYPE__ns1__CanLoginResponse (53)
/* complex XSD type 'ns1:CanLoginResponse': */
class SOAP_CMAC _ns1__CanLoginResponse {
      public:
        /// Optional element 'ns1:CanLoginResult' of XSD type 'ns1:SubmitResult'
        ns1__SubmitResult *CanLoginResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CanLoginResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__CanLoginResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CanLoginResponse, default initialized and not managed by a soap context
        virtual _ns1__CanLoginResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__CanLoginResponse); }
      public:
        /// Constructor with initializations
        _ns1__CanLoginResponse() : CanLoginResult(), soap() { }
        virtual ~_ns1__CanLoginResponse() { }
        /// Friend allocator used by soap_new__ns1__CanLoginResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CanLoginResponse * SOAP_FMAC2 soap_instantiate__ns1__CanLoginResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:283 */
#ifndef SOAP_TYPE__ns1__Login
#define SOAP_TYPE__ns1__Login (54)
/* complex XSD type 'ns1:Login': */
class SOAP_CMAC _ns1__Login {
      public:
        /// Optional element 'ns1:UserName' of XSD type 'xsd:string'
        std::string *UserName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Login
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Login; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Login, default initialized and not managed by a soap context
        virtual _ns1__Login *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Login); }
      public:
        /// Constructor with initializations
        _ns1__Login() : UserName(), soap() { }
        virtual ~_ns1__Login() { }
        /// Friend allocator used by soap_new__ns1__Login(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Login * SOAP_FMAC2 soap_instantiate__ns1__Login(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:286 */
#ifndef SOAP_TYPE__ns1__LoginResponse
#define SOAP_TYPE__ns1__LoginResponse (55)
/* complex XSD type 'ns1:LoginResponse': */
class SOAP_CMAC _ns1__LoginResponse {
      public:
        /// Optional element 'ns1:LoginResult' of XSD type 'ns1:SubmitResult'
        ns1__SubmitResult *LoginResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__LoginResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__LoginResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__LoginResponse, default initialized and not managed by a soap context
        virtual _ns1__LoginResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__LoginResponse); }
      public:
        /// Constructor with initializations
        _ns1__LoginResponse() : LoginResult(), soap() { }
        virtual ~_ns1__LoginResponse() { }
        /// Friend allocator used by soap_new__ns1__LoginResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__LoginResponse * SOAP_FMAC2 soap_instantiate__ns1__LoginResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:1520 */
#ifndef SOAP_TYPE___ns1__GetWorkCenterID
#define SOAP_TYPE___ns1__GetWorkCenterID (77)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetWorkCenterID {
      public:
        /** Optional element 'ns1:GetWorkCenterID' of XSD type 'ns1:GetWorkCenterID' */
        _ns1__GetWorkCenterID *ns1__GetWorkCenterID;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetWorkCenterID */
        long soap_type() const { return SOAP_TYPE___ns1__GetWorkCenterID; }
        /** Constructor with member initializations */
        __ns1__GetWorkCenterID() : ns1__GetWorkCenterID() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetWorkCenterID * SOAP_FMAC2 soap_instantiate___ns1__GetWorkCenterID(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:1591 */
#ifndef SOAP_TYPE___ns1__GetCurrentSpecBySn
#define SOAP_TYPE___ns1__GetCurrentSpecBySn (81)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetCurrentSpecBySn {
      public:
        /** Optional element 'ns1:GetCurrentSpecBySn' of XSD type 'ns1:GetCurrentSpecBySn' */
        _ns1__GetCurrentSpecBySn *ns1__GetCurrentSpecBySn;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetCurrentSpecBySn */
        long soap_type() const { return SOAP_TYPE___ns1__GetCurrentSpecBySn; }
        /** Constructor with member initializations */
        __ns1__GetCurrentSpecBySn() : ns1__GetCurrentSpecBySn() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetCurrentSpecBySn * SOAP_FMAC2 soap_instantiate___ns1__GetCurrentSpecBySn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:1662 */
#ifndef SOAP_TYPE___ns1__IV_USCOREDataCollection
#define SOAP_TYPE___ns1__IV_USCOREDataCollection (85)
/* Wrapper: */
struct SOAP_CMAC __ns1__IV_USCOREDataCollection {
      public:
        /** Optional element 'ns1:IV_DataCollection' of XSD type 'ns1:IV_DataCollection' */
        _ns1__IV_USCOREDataCollection *ns1__IV_USCOREDataCollection;
      public:
        /** Return unique type id SOAP_TYPE___ns1__IV_USCOREDataCollection */
        long soap_type() const { return SOAP_TYPE___ns1__IV_USCOREDataCollection; }
        /** Constructor with member initializations */
        __ns1__IV_USCOREDataCollection() : ns1__IV_USCOREDataCollection() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__IV_USCOREDataCollection * SOAP_FMAC2 soap_instantiate___ns1__IV_USCOREDataCollection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:1733 */
#ifndef SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan
#define SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan (89)
/* Wrapper: */
struct SOAP_CMAC __ns1__jKoIVMoveStd_USCOREPasan {
      public:
        /** Optional element 'ns1:jKoIVMoveStd_Pasan' of XSD type 'ns1:jKoIVMoveStd_Pasan' */
        _ns1__jKoIVMoveStd_USCOREPasan *ns1__jKoIVMoveStd_USCOREPasan;
      public:
        /** Return unique type id SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan */
        long soap_type() const { return SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan; }
        /** Constructor with member initializations */
        __ns1__jKoIVMoveStd_USCOREPasan() : ns1__jKoIVMoveStd_USCOREPasan() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__jKoIVMoveStd_USCOREPasan * SOAP_FMAC2 soap_instantiate___ns1__jKoIVMoveStd_USCOREPasan(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:1804 */
#ifndef SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire
#define SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire (93)
/* Wrapper: */
struct SOAP_CMAC __ns1__jKoIVMoveStd_USCORESpire {
      public:
        /** Optional element 'ns1:jKoIVMoveStd_Spire' of XSD type 'ns1:jKoIVMoveStd_Spire' */
        _ns1__jKoIVMoveStd_USCORESpire *ns1__jKoIVMoveStd_USCORESpire;
      public:
        /** Return unique type id SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire */
        long soap_type() const { return SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire; }
        /** Constructor with member initializations */
        __ns1__jKoIVMoveStd_USCORESpire() : ns1__jKoIVMoveStd_USCORESpire() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__jKoIVMoveStd_USCORESpire * SOAP_FMAC2 soap_instantiate___ns1__jKoIVMoveStd_USCORESpire(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:1875 */
#ifndef SOAP_TYPE___ns1__ELPictureAddress
#define SOAP_TYPE___ns1__ELPictureAddress (97)
/* Wrapper: */
struct SOAP_CMAC __ns1__ELPictureAddress {
      public:
        /** Optional element 'ns1:ELPictureAddress' of XSD type 'ns1:ELPictureAddress' */
        _ns1__ELPictureAddress *ns1__ELPictureAddress;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ELPictureAddress */
        long soap_type() const { return SOAP_TYPE___ns1__ELPictureAddress; }
        /** Constructor with member initializations */
        __ns1__ELPictureAddress() : ns1__ELPictureAddress() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ELPictureAddress * SOAP_FMAC2 soap_instantiate___ns1__ELPictureAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:1946 */
#ifndef SOAP_TYPE___ns1__ELInfoMoveStd
#define SOAP_TYPE___ns1__ELInfoMoveStd (101)
/* Wrapper: */
struct SOAP_CMAC __ns1__ELInfoMoveStd {
      public:
        /** Optional element 'ns1:ELInfoMoveStd' of XSD type 'ns1:ELInfoMoveStd' */
        _ns1__ELInfoMoveStd *ns1__ELInfoMoveStd;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ELInfoMoveStd */
        long soap_type() const { return SOAP_TYPE___ns1__ELInfoMoveStd; }
        /** Constructor with member initializations */
        __ns1__ELInfoMoveStd() : ns1__ELInfoMoveStd() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ELInfoMoveStd * SOAP_FMAC2 soap_instantiate___ns1__ELInfoMoveStd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:2017 */
#ifndef SOAP_TYPE___ns1__SafetyInfoMoveStd
#define SOAP_TYPE___ns1__SafetyInfoMoveStd (105)
/* Wrapper: */
struct SOAP_CMAC __ns1__SafetyInfoMoveStd {
      public:
        /** Optional element 'ns1:SafetyInfoMoveStd' of XSD type 'ns1:SafetyInfoMoveStd' */
        _ns1__SafetyInfoMoveStd *ns1__SafetyInfoMoveStd;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SafetyInfoMoveStd */
        long soap_type() const { return SOAP_TYPE___ns1__SafetyInfoMoveStd; }
        /** Constructor with member initializations */
        __ns1__SafetyInfoMoveStd() : ns1__SafetyInfoMoveStd() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SafetyInfoMoveStd * SOAP_FMAC2 soap_instantiate___ns1__SafetyInfoMoveStd(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:2088 */
#ifndef SOAP_TYPE___ns1__UploadTensileInfoToMes
#define SOAP_TYPE___ns1__UploadTensileInfoToMes (109)
/* Wrapper: */
struct SOAP_CMAC __ns1__UploadTensileInfoToMes {
      public:
        /** Optional element 'ns1:UploadTensileInfoToMes' of XSD type 'ns1:UploadTensileInfoToMes' */
        _ns1__UploadTensileInfoToMes *ns1__UploadTensileInfoToMes;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UploadTensileInfoToMes */
        long soap_type() const { return SOAP_TYPE___ns1__UploadTensileInfoToMes; }
        /** Constructor with member initializations */
        __ns1__UploadTensileInfoToMes() : ns1__UploadTensileInfoToMes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UploadTensileInfoToMes * SOAP_FMAC2 soap_instantiate___ns1__UploadTensileInfoToMes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:2159 */
#ifndef SOAP_TYPE___ns1__GetContainerDataInfoMES
#define SOAP_TYPE___ns1__GetContainerDataInfoMES (113)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetContainerDataInfoMES {
      public:
        /** Optional element 'ns1:GetContainerDataInfoMES' of XSD type 'ns1:GetContainerDataInfoMES' */
        _ns1__GetContainerDataInfoMES *ns1__GetContainerDataInfoMES;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetContainerDataInfoMES */
        long soap_type() const { return SOAP_TYPE___ns1__GetContainerDataInfoMES; }
        /** Constructor with member initializations */
        __ns1__GetContainerDataInfoMES() : ns1__GetContainerDataInfoMES() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetContainerDataInfoMES * SOAP_FMAC2 soap_instantiate___ns1__GetContainerDataInfoMES(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:2230 */
#ifndef SOAP_TYPE___ns1__GetTensileTestRule
#define SOAP_TYPE___ns1__GetTensileTestRule (117)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetTensileTestRule {
      public:
        /** Optional element 'ns1:GetTensileTestRule' of XSD type 'ns1:GetTensileTestRule' */
        _ns1__GetTensileTestRule *ns1__GetTensileTestRule;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetTensileTestRule */
        long soap_type() const { return SOAP_TYPE___ns1__GetTensileTestRule; }
        /** Constructor with member initializations */
        __ns1__GetTensileTestRule() : ns1__GetTensileTestRule() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetTensileTestRule * SOAP_FMAC2 soap_instantiate___ns1__GetTensileTestRule(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:2301 */
#ifndef SOAP_TYPE___ns1__Iscalibrationcontainer
#define SOAP_TYPE___ns1__Iscalibrationcontainer (121)
/* Wrapper: */
struct SOAP_CMAC __ns1__Iscalibrationcontainer {
      public:
        /** Optional element 'ns1:Iscalibrationcontainer' of XSD type 'ns1:Iscalibrationcontainer' */
        _ns1__Iscalibrationcontainer *ns1__Iscalibrationcontainer;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Iscalibrationcontainer */
        long soap_type() const { return SOAP_TYPE___ns1__Iscalibrationcontainer; }
        /** Constructor with member initializations */
        __ns1__Iscalibrationcontainer() : ns1__Iscalibrationcontainer() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Iscalibrationcontainer * SOAP_FMAC2 soap_instantiate___ns1__Iscalibrationcontainer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:2372 */
#ifndef SOAP_TYPE___ns1__GetFtpAddress
#define SOAP_TYPE___ns1__GetFtpAddress (125)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetFtpAddress {
      public:
        /** Optional element 'ns1:GetFtpAddress' of XSD type 'ns1:GetFtpAddress' */
        _ns1__GetFtpAddress *ns1__GetFtpAddress;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetFtpAddress */
        long soap_type() const { return SOAP_TYPE___ns1__GetFtpAddress; }
        /** Constructor with member initializations */
        __ns1__GetFtpAddress() : ns1__GetFtpAddress() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetFtpAddress * SOAP_FMAC2 soap_instantiate___ns1__GetFtpAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:2443 */
#ifndef SOAP_TYPE___ns1__GetDefectInfoToSAP
#define SOAP_TYPE___ns1__GetDefectInfoToSAP (129)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetDefectInfoToSAP {
      public:
        /** Optional element 'ns1:GetDefectInfoToSAP' of XSD type 'ns1:GetDefectInfoToSAP' */
        _ns1__GetDefectInfoToSAP *ns1__GetDefectInfoToSAP;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetDefectInfoToSAP */
        long soap_type() const { return SOAP_TYPE___ns1__GetDefectInfoToSAP; }
        /** Constructor with member initializations */
        __ns1__GetDefectInfoToSAP() : ns1__GetDefectInfoToSAP() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetDefectInfoToSAP * SOAP_FMAC2 soap_instantiate___ns1__GetDefectInfoToSAP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:2514 */
#ifndef SOAP_TYPE___ns1__SetDefectResultToMES
#define SOAP_TYPE___ns1__SetDefectResultToMES (133)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetDefectResultToMES {
      public:
        /** Optional element 'ns1:SetDefectResultToMES' of XSD type 'ns1:SetDefectResultToMES' */
        _ns1__SetDefectResultToMES *ns1__SetDefectResultToMES;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetDefectResultToMES */
        long soap_type() const { return SOAP_TYPE___ns1__SetDefectResultToMES; }
        /** Constructor with member initializations */
        __ns1__SetDefectResultToMES() : ns1__SetDefectResultToMES() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetDefectResultToMES * SOAP_FMAC2 soap_instantiate___ns1__SetDefectResultToMES(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:2585 */
#ifndef SOAP_TYPE___ns1__SetMaterialBatchResultToMES
#define SOAP_TYPE___ns1__SetMaterialBatchResultToMES (137)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetMaterialBatchResultToMES {
      public:
        /** Optional element 'ns1:SetMaterialBatchResultToMES' of XSD type 'ns1:SetMaterialBatchResultToMES' */
        _ns1__SetMaterialBatchResultToMES *ns1__SetMaterialBatchResultToMES;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetMaterialBatchResultToMES */
        long soap_type() const { return SOAP_TYPE___ns1__SetMaterialBatchResultToMES; }
        /** Constructor with member initializations */
        __ns1__SetMaterialBatchResultToMES() : ns1__SetMaterialBatchResultToMES() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetMaterialBatchResultToMES * SOAP_FMAC2 soap_instantiate___ns1__SetMaterialBatchResultToMES(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:2656 */
#ifndef SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs
#define SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs (141)
/* Wrapper: */
struct SOAP_CMAC __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs {
      public:
        /** Optional element 'ns1:Upload_FIDWUL_DATAFLAGs' of XSD type 'ns1:Upload_FIDWUL_DATAFLAGs' */
        _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs */
        long soap_type() const { return SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs; }
        /** Constructor with member initializations */
        __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs() : ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs * SOAP_FMAC2 soap_instantiate___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:2726 */
#ifndef SOAP_TYPE___ns1__CanLogin
#define SOAP_TYPE___ns1__CanLogin (145)
/* Wrapper: */
struct SOAP_CMAC __ns1__CanLogin {
      public:
        /** Optional element 'ns1:CanLogin' of XSD type 'ns1:CanLogin' */
        _ns1__CanLogin *ns1__CanLogin;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CanLogin */
        long soap_type() const { return SOAP_TYPE___ns1__CanLogin; }
        /** Constructor with member initializations */
        __ns1__CanLogin() : ns1__CanLogin() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CanLogin * SOAP_FMAC2 soap_instantiate___ns1__CanLogin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:2796 */
#ifndef SOAP_TYPE___ns1__Login
#define SOAP_TYPE___ns1__Login (149)
/* Wrapper: */
struct SOAP_CMAC __ns1__Login {
      public:
        /** Optional element 'ns1:Login' of XSD type 'ns1:Login' */
        _ns1__Login *ns1__Login;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Login */
        long soap_type() const { return SOAP_TYPE___ns1__Login; }
        /** Constructor with member initializations */
        __ns1__Login() : ns1__Login() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Login * SOAP_FMAC2 soap_instantiate___ns1__Login(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:2867 */
#ifndef SOAP_TYPE___ns1__GetWorkCenterID_
#define SOAP_TYPE___ns1__GetWorkCenterID_ (151)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetWorkCenterID_ {
      public:
        /** Optional element 'ns1:GetWorkCenterID' of XSD type 'ns1:GetWorkCenterID' */
        _ns1__GetWorkCenterID *ns1__GetWorkCenterID;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetWorkCenterID_ */
        long soap_type() const { return SOAP_TYPE___ns1__GetWorkCenterID_; }
        /** Constructor with member initializations */
        __ns1__GetWorkCenterID_() : ns1__GetWorkCenterID() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetWorkCenterID_ * SOAP_FMAC2 soap_instantiate___ns1__GetWorkCenterID_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:2938 */
#ifndef SOAP_TYPE___ns1__GetCurrentSpecBySn_
#define SOAP_TYPE___ns1__GetCurrentSpecBySn_ (153)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetCurrentSpecBySn_ {
      public:
        /** Optional element 'ns1:GetCurrentSpecBySn' of XSD type 'ns1:GetCurrentSpecBySn' */
        _ns1__GetCurrentSpecBySn *ns1__GetCurrentSpecBySn;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetCurrentSpecBySn_ */
        long soap_type() const { return SOAP_TYPE___ns1__GetCurrentSpecBySn_; }
        /** Constructor with member initializations */
        __ns1__GetCurrentSpecBySn_() : ns1__GetCurrentSpecBySn() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetCurrentSpecBySn_ * SOAP_FMAC2 soap_instantiate___ns1__GetCurrentSpecBySn_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:3009 */
#ifndef SOAP_TYPE___ns1__IV_USCOREDataCollection_
#define SOAP_TYPE___ns1__IV_USCOREDataCollection_ (155)
/* Wrapper: */
struct SOAP_CMAC __ns1__IV_USCOREDataCollection_ {
      public:
        /** Optional element 'ns1:IV_DataCollection' of XSD type 'ns1:IV_DataCollection' */
        _ns1__IV_USCOREDataCollection *ns1__IV_USCOREDataCollection;
      public:
        /** Return unique type id SOAP_TYPE___ns1__IV_USCOREDataCollection_ */
        long soap_type() const { return SOAP_TYPE___ns1__IV_USCOREDataCollection_; }
        /** Constructor with member initializations */
        __ns1__IV_USCOREDataCollection_() : ns1__IV_USCOREDataCollection() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__IV_USCOREDataCollection_ * SOAP_FMAC2 soap_instantiate___ns1__IV_USCOREDataCollection_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:3080 */
#ifndef SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan_
#define SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan_ (157)
/* Wrapper: */
struct SOAP_CMAC __ns1__jKoIVMoveStd_USCOREPasan_ {
      public:
        /** Optional element 'ns1:jKoIVMoveStd_Pasan' of XSD type 'ns1:jKoIVMoveStd_Pasan' */
        _ns1__jKoIVMoveStd_USCOREPasan *ns1__jKoIVMoveStd_USCOREPasan;
      public:
        /** Return unique type id SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan_ */
        long soap_type() const { return SOAP_TYPE___ns1__jKoIVMoveStd_USCOREPasan_; }
        /** Constructor with member initializations */
        __ns1__jKoIVMoveStd_USCOREPasan_() : ns1__jKoIVMoveStd_USCOREPasan() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__jKoIVMoveStd_USCOREPasan_ * SOAP_FMAC2 soap_instantiate___ns1__jKoIVMoveStd_USCOREPasan_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:3151 */
#ifndef SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire_
#define SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire_ (159)
/* Wrapper: */
struct SOAP_CMAC __ns1__jKoIVMoveStd_USCORESpire_ {
      public:
        /** Optional element 'ns1:jKoIVMoveStd_Spire' of XSD type 'ns1:jKoIVMoveStd_Spire' */
        _ns1__jKoIVMoveStd_USCORESpire *ns1__jKoIVMoveStd_USCORESpire;
      public:
        /** Return unique type id SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire_ */
        long soap_type() const { return SOAP_TYPE___ns1__jKoIVMoveStd_USCORESpire_; }
        /** Constructor with member initializations */
        __ns1__jKoIVMoveStd_USCORESpire_() : ns1__jKoIVMoveStd_USCORESpire() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__jKoIVMoveStd_USCORESpire_ * SOAP_FMAC2 soap_instantiate___ns1__jKoIVMoveStd_USCORESpire_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:3222 */
#ifndef SOAP_TYPE___ns1__ELPictureAddress_
#define SOAP_TYPE___ns1__ELPictureAddress_ (161)
/* Wrapper: */
struct SOAP_CMAC __ns1__ELPictureAddress_ {
      public:
        /** Optional element 'ns1:ELPictureAddress' of XSD type 'ns1:ELPictureAddress' */
        _ns1__ELPictureAddress *ns1__ELPictureAddress;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ELPictureAddress_ */
        long soap_type() const { return SOAP_TYPE___ns1__ELPictureAddress_; }
        /** Constructor with member initializations */
        __ns1__ELPictureAddress_() : ns1__ELPictureAddress() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ELPictureAddress_ * SOAP_FMAC2 soap_instantiate___ns1__ELPictureAddress_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:3293 */
#ifndef SOAP_TYPE___ns1__ELInfoMoveStd_
#define SOAP_TYPE___ns1__ELInfoMoveStd_ (163)
/* Wrapper: */
struct SOAP_CMAC __ns1__ELInfoMoveStd_ {
      public:
        /** Optional element 'ns1:ELInfoMoveStd' of XSD type 'ns1:ELInfoMoveStd' */
        _ns1__ELInfoMoveStd *ns1__ELInfoMoveStd;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ELInfoMoveStd_ */
        long soap_type() const { return SOAP_TYPE___ns1__ELInfoMoveStd_; }
        /** Constructor with member initializations */
        __ns1__ELInfoMoveStd_() : ns1__ELInfoMoveStd() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ELInfoMoveStd_ * SOAP_FMAC2 soap_instantiate___ns1__ELInfoMoveStd_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:3364 */
#ifndef SOAP_TYPE___ns1__SafetyInfoMoveStd_
#define SOAP_TYPE___ns1__SafetyInfoMoveStd_ (165)
/* Wrapper: */
struct SOAP_CMAC __ns1__SafetyInfoMoveStd_ {
      public:
        /** Optional element 'ns1:SafetyInfoMoveStd' of XSD type 'ns1:SafetyInfoMoveStd' */
        _ns1__SafetyInfoMoveStd *ns1__SafetyInfoMoveStd;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SafetyInfoMoveStd_ */
        long soap_type() const { return SOAP_TYPE___ns1__SafetyInfoMoveStd_; }
        /** Constructor with member initializations */
        __ns1__SafetyInfoMoveStd_() : ns1__SafetyInfoMoveStd() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SafetyInfoMoveStd_ * SOAP_FMAC2 soap_instantiate___ns1__SafetyInfoMoveStd_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:3435 */
#ifndef SOAP_TYPE___ns1__UploadTensileInfoToMes_
#define SOAP_TYPE___ns1__UploadTensileInfoToMes_ (167)
/* Wrapper: */
struct SOAP_CMAC __ns1__UploadTensileInfoToMes_ {
      public:
        /** Optional element 'ns1:UploadTensileInfoToMes' of XSD type 'ns1:UploadTensileInfoToMes' */
        _ns1__UploadTensileInfoToMes *ns1__UploadTensileInfoToMes;
      public:
        /** Return unique type id SOAP_TYPE___ns1__UploadTensileInfoToMes_ */
        long soap_type() const { return SOAP_TYPE___ns1__UploadTensileInfoToMes_; }
        /** Constructor with member initializations */
        __ns1__UploadTensileInfoToMes_() : ns1__UploadTensileInfoToMes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__UploadTensileInfoToMes_ * SOAP_FMAC2 soap_instantiate___ns1__UploadTensileInfoToMes_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:3506 */
#ifndef SOAP_TYPE___ns1__GetContainerDataInfoMES_
#define SOAP_TYPE___ns1__GetContainerDataInfoMES_ (169)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetContainerDataInfoMES_ {
      public:
        /** Optional element 'ns1:GetContainerDataInfoMES' of XSD type 'ns1:GetContainerDataInfoMES' */
        _ns1__GetContainerDataInfoMES *ns1__GetContainerDataInfoMES;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetContainerDataInfoMES_ */
        long soap_type() const { return SOAP_TYPE___ns1__GetContainerDataInfoMES_; }
        /** Constructor with member initializations */
        __ns1__GetContainerDataInfoMES_() : ns1__GetContainerDataInfoMES() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetContainerDataInfoMES_ * SOAP_FMAC2 soap_instantiate___ns1__GetContainerDataInfoMES_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:3577 */
#ifndef SOAP_TYPE___ns1__GetTensileTestRule_
#define SOAP_TYPE___ns1__GetTensileTestRule_ (171)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetTensileTestRule_ {
      public:
        /** Optional element 'ns1:GetTensileTestRule' of XSD type 'ns1:GetTensileTestRule' */
        _ns1__GetTensileTestRule *ns1__GetTensileTestRule;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetTensileTestRule_ */
        long soap_type() const { return SOAP_TYPE___ns1__GetTensileTestRule_; }
        /** Constructor with member initializations */
        __ns1__GetTensileTestRule_() : ns1__GetTensileTestRule() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetTensileTestRule_ * SOAP_FMAC2 soap_instantiate___ns1__GetTensileTestRule_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:3648 */
#ifndef SOAP_TYPE___ns1__Iscalibrationcontainer_
#define SOAP_TYPE___ns1__Iscalibrationcontainer_ (173)
/* Wrapper: */
struct SOAP_CMAC __ns1__Iscalibrationcontainer_ {
      public:
        /** Optional element 'ns1:Iscalibrationcontainer' of XSD type 'ns1:Iscalibrationcontainer' */
        _ns1__Iscalibrationcontainer *ns1__Iscalibrationcontainer;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Iscalibrationcontainer_ */
        long soap_type() const { return SOAP_TYPE___ns1__Iscalibrationcontainer_; }
        /** Constructor with member initializations */
        __ns1__Iscalibrationcontainer_() : ns1__Iscalibrationcontainer() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Iscalibrationcontainer_ * SOAP_FMAC2 soap_instantiate___ns1__Iscalibrationcontainer_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:3719 */
#ifndef SOAP_TYPE___ns1__GetFtpAddress_
#define SOAP_TYPE___ns1__GetFtpAddress_ (175)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetFtpAddress_ {
      public:
        /** Optional element 'ns1:GetFtpAddress' of XSD type 'ns1:GetFtpAddress' */
        _ns1__GetFtpAddress *ns1__GetFtpAddress;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetFtpAddress_ */
        long soap_type() const { return SOAP_TYPE___ns1__GetFtpAddress_; }
        /** Constructor with member initializations */
        __ns1__GetFtpAddress_() : ns1__GetFtpAddress() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetFtpAddress_ * SOAP_FMAC2 soap_instantiate___ns1__GetFtpAddress_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:3790 */
#ifndef SOAP_TYPE___ns1__GetDefectInfoToSAP_
#define SOAP_TYPE___ns1__GetDefectInfoToSAP_ (177)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetDefectInfoToSAP_ {
      public:
        /** Optional element 'ns1:GetDefectInfoToSAP' of XSD type 'ns1:GetDefectInfoToSAP' */
        _ns1__GetDefectInfoToSAP *ns1__GetDefectInfoToSAP;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetDefectInfoToSAP_ */
        long soap_type() const { return SOAP_TYPE___ns1__GetDefectInfoToSAP_; }
        /** Constructor with member initializations */
        __ns1__GetDefectInfoToSAP_() : ns1__GetDefectInfoToSAP() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetDefectInfoToSAP_ * SOAP_FMAC2 soap_instantiate___ns1__GetDefectInfoToSAP_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:3861 */
#ifndef SOAP_TYPE___ns1__SetDefectResultToMES_
#define SOAP_TYPE___ns1__SetDefectResultToMES_ (179)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetDefectResultToMES_ {
      public:
        /** Optional element 'ns1:SetDefectResultToMES' of XSD type 'ns1:SetDefectResultToMES' */
        _ns1__SetDefectResultToMES *ns1__SetDefectResultToMES;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetDefectResultToMES_ */
        long soap_type() const { return SOAP_TYPE___ns1__SetDefectResultToMES_; }
        /** Constructor with member initializations */
        __ns1__SetDefectResultToMES_() : ns1__SetDefectResultToMES() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetDefectResultToMES_ * SOAP_FMAC2 soap_instantiate___ns1__SetDefectResultToMES_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:3932 */
#ifndef SOAP_TYPE___ns1__SetMaterialBatchResultToMES_
#define SOAP_TYPE___ns1__SetMaterialBatchResultToMES_ (181)
/* Wrapper: */
struct SOAP_CMAC __ns1__SetMaterialBatchResultToMES_ {
      public:
        /** Optional element 'ns1:SetMaterialBatchResultToMES' of XSD type 'ns1:SetMaterialBatchResultToMES' */
        _ns1__SetMaterialBatchResultToMES *ns1__SetMaterialBatchResultToMES;
      public:
        /** Return unique type id SOAP_TYPE___ns1__SetMaterialBatchResultToMES_ */
        long soap_type() const { return SOAP_TYPE___ns1__SetMaterialBatchResultToMES_; }
        /** Constructor with member initializations */
        __ns1__SetMaterialBatchResultToMES_() : ns1__SetMaterialBatchResultToMES() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__SetMaterialBatchResultToMES_ * SOAP_FMAC2 soap_instantiate___ns1__SetMaterialBatchResultToMES_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:4003 */
#ifndef SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_
#define SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ (183)
/* Wrapper: */
struct SOAP_CMAC __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ {
      public:
        /** Optional element 'ns1:Upload_FIDWUL_DATAFLAGs' of XSD type 'ns1:Upload_FIDWUL_DATAFLAGs' */
        _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ */
        long soap_type() const { return SOAP_TYPE___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_; }
        /** Constructor with member initializations */
        __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_() : ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_ * SOAP_FMAC2 soap_instantiate___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:4073 */
#ifndef SOAP_TYPE___ns1__CanLogin_
#define SOAP_TYPE___ns1__CanLogin_ (185)
/* Wrapper: */
struct SOAP_CMAC __ns1__CanLogin_ {
      public:
        /** Optional element 'ns1:CanLogin' of XSD type 'ns1:CanLogin' */
        _ns1__CanLogin *ns1__CanLogin;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CanLogin_ */
        long soap_type() const { return SOAP_TYPE___ns1__CanLogin_; }
        /** Constructor with member initializations */
        __ns1__CanLogin_() : ns1__CanLogin() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__CanLogin_ * SOAP_FMAC2 soap_instantiate___ns1__CanLogin_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:4143 */
#ifndef SOAP_TYPE___ns1__Login_
#define SOAP_TYPE___ns1__Login_ (187)
/* Wrapper: */
struct SOAP_CMAC __ns1__Login_ {
      public:
        /** Optional element 'ns1:Login' of XSD type 'ns1:Login' */
        _ns1__Login *ns1__Login;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Login_ */
        long soap_type() const { return SOAP_TYPE___ns1__Login_; }
        /** Constructor with member initializations */
        __ns1__Login_() : ns1__Login() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Login_ * SOAP_FMAC2 soap_instantiate___ns1__Login_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MESWebService.h:4780 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (188)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* MESWebService.h:4780 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (189)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* MESWebService.h:4780 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (191)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* MESWebService.h:4780 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (194)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* MESWebService.h:4780 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (195)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* MESWebService.h:140 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (9)
typedef std::string xsd__decimal;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (69)
#endif

/* _ns1__SubmitResult_ResultTable has binding name '_ns1__SubmitResult_ResultTable' for type '' */
#ifndef SOAP_TYPE__ns1__SubmitResult_ResultTable
#define SOAP_TYPE__ns1__SubmitResult_ResultTable (57)
#endif

/* _ns1__LoginResponse has binding name '_ns1__LoginResponse' for type '' */
#ifndef SOAP_TYPE__ns1__LoginResponse
#define SOAP_TYPE__ns1__LoginResponse (55)
#endif

/* _ns1__Login has binding name '_ns1__Login' for type '' */
#ifndef SOAP_TYPE__ns1__Login
#define SOAP_TYPE__ns1__Login (54)
#endif

/* _ns1__CanLoginResponse has binding name '_ns1__CanLoginResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CanLoginResponse
#define SOAP_TYPE__ns1__CanLoginResponse (53)
#endif

/* _ns1__CanLogin has binding name '_ns1__CanLogin' for type '' */
#ifndef SOAP_TYPE__ns1__CanLogin
#define SOAP_TYPE__ns1__CanLogin (52)
#endif

/* _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse has binding name '_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse
#define SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse (51)
#endif

/* _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs has binding name '_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs' for type '' */
#ifndef SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs
#define SOAP_TYPE__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs (50)
#endif

/* _ns1__SetMaterialBatchResultToMESResponse has binding name '_ns1__SetMaterialBatchResultToMESResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse
#define SOAP_TYPE__ns1__SetMaterialBatchResultToMESResponse (49)
#endif

/* _ns1__SetMaterialBatchResultToMES has binding name '_ns1__SetMaterialBatchResultToMES' for type '' */
#ifndef SOAP_TYPE__ns1__SetMaterialBatchResultToMES
#define SOAP_TYPE__ns1__SetMaterialBatchResultToMES (48)
#endif

/* _ns1__SetDefectResultToMESResponse has binding name '_ns1__SetDefectResultToMESResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SetDefectResultToMESResponse
#define SOAP_TYPE__ns1__SetDefectResultToMESResponse (47)
#endif

/* _ns1__SetDefectResultToMES has binding name '_ns1__SetDefectResultToMES' for type '' */
#ifndef SOAP_TYPE__ns1__SetDefectResultToMES
#define SOAP_TYPE__ns1__SetDefectResultToMES (46)
#endif

/* _ns1__GetDefectInfoToSAPResponse has binding name '_ns1__GetDefectInfoToSAPResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetDefectInfoToSAPResponse
#define SOAP_TYPE__ns1__GetDefectInfoToSAPResponse (45)
#endif

/* _ns1__GetDefectInfoToSAP has binding name '_ns1__GetDefectInfoToSAP' for type '' */
#ifndef SOAP_TYPE__ns1__GetDefectInfoToSAP
#define SOAP_TYPE__ns1__GetDefectInfoToSAP (44)
#endif

/* _ns1__GetFtpAddressResponse has binding name '_ns1__GetFtpAddressResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetFtpAddressResponse
#define SOAP_TYPE__ns1__GetFtpAddressResponse (43)
#endif

/* _ns1__GetFtpAddress has binding name '_ns1__GetFtpAddress' for type '' */
#ifndef SOAP_TYPE__ns1__GetFtpAddress
#define SOAP_TYPE__ns1__GetFtpAddress (42)
#endif

/* _ns1__IscalibrationcontainerResponse has binding name '_ns1__IscalibrationcontainerResponse' for type '' */
#ifndef SOAP_TYPE__ns1__IscalibrationcontainerResponse
#define SOAP_TYPE__ns1__IscalibrationcontainerResponse (41)
#endif

/* _ns1__Iscalibrationcontainer has binding name '_ns1__Iscalibrationcontainer' for type '' */
#ifndef SOAP_TYPE__ns1__Iscalibrationcontainer
#define SOAP_TYPE__ns1__Iscalibrationcontainer (40)
#endif

/* _ns1__GetTensileTestRuleResponse has binding name '_ns1__GetTensileTestRuleResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetTensileTestRuleResponse
#define SOAP_TYPE__ns1__GetTensileTestRuleResponse (39)
#endif

/* _ns1__GetTensileTestRule has binding name '_ns1__GetTensileTestRule' for type '' */
#ifndef SOAP_TYPE__ns1__GetTensileTestRule
#define SOAP_TYPE__ns1__GetTensileTestRule (38)
#endif

/* _ns1__GetContainerDataInfoMESResponse has binding name '_ns1__GetContainerDataInfoMESResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetContainerDataInfoMESResponse
#define SOAP_TYPE__ns1__GetContainerDataInfoMESResponse (37)
#endif

/* _ns1__GetContainerDataInfoMES has binding name '_ns1__GetContainerDataInfoMES' for type '' */
#ifndef SOAP_TYPE__ns1__GetContainerDataInfoMES
#define SOAP_TYPE__ns1__GetContainerDataInfoMES (36)
#endif

/* _ns1__UploadTensileInfoToMesResponse has binding name '_ns1__UploadTensileInfoToMesResponse' for type '' */
#ifndef SOAP_TYPE__ns1__UploadTensileInfoToMesResponse
#define SOAP_TYPE__ns1__UploadTensileInfoToMesResponse (35)
#endif

/* _ns1__UploadTensileInfoToMes has binding name '_ns1__UploadTensileInfoToMes' for type '' */
#ifndef SOAP_TYPE__ns1__UploadTensileInfoToMes
#define SOAP_TYPE__ns1__UploadTensileInfoToMes (34)
#endif

/* _ns1__SafetyInfoMoveStdResponse has binding name '_ns1__SafetyInfoMoveStdResponse' for type '' */
#ifndef SOAP_TYPE__ns1__SafetyInfoMoveStdResponse
#define SOAP_TYPE__ns1__SafetyInfoMoveStdResponse (33)
#endif

/* _ns1__SafetyInfoMoveStd has binding name '_ns1__SafetyInfoMoveStd' for type '' */
#ifndef SOAP_TYPE__ns1__SafetyInfoMoveStd
#define SOAP_TYPE__ns1__SafetyInfoMoveStd (32)
#endif

/* _ns1__ELInfoMoveStdResponse has binding name '_ns1__ELInfoMoveStdResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ELInfoMoveStdResponse
#define SOAP_TYPE__ns1__ELInfoMoveStdResponse (31)
#endif

/* _ns1__ELInfoMoveStd has binding name '_ns1__ELInfoMoveStd' for type '' */
#ifndef SOAP_TYPE__ns1__ELInfoMoveStd
#define SOAP_TYPE__ns1__ELInfoMoveStd (30)
#endif

/* _ns1__ELPictureAddressResponse has binding name '_ns1__ELPictureAddressResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ELPictureAddressResponse
#define SOAP_TYPE__ns1__ELPictureAddressResponse (29)
#endif

/* _ns1__ELPictureAddress has binding name '_ns1__ELPictureAddress' for type '' */
#ifndef SOAP_TYPE__ns1__ELPictureAddress
#define SOAP_TYPE__ns1__ELPictureAddress (28)
#endif

/* _ns1__jKoIVMoveStd_USCORESpireResponse has binding name '_ns1__jKoIVMoveStd_USCORESpireResponse' for type '' */
#ifndef SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse
#define SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpireResponse (27)
#endif

/* _ns1__jKoIVMoveStd_USCORESpire has binding name '_ns1__jKoIVMoveStd_USCORESpire' for type '' */
#ifndef SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire
#define SOAP_TYPE__ns1__jKoIVMoveStd_USCORESpire (26)
#endif

/* _ns1__jKoIVMoveStd_USCOREPasanResponse has binding name '_ns1__jKoIVMoveStd_USCOREPasanResponse' for type '' */
#ifndef SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse
#define SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasanResponse (25)
#endif

/* _ns1__jKoIVMoveStd_USCOREPasan has binding name '_ns1__jKoIVMoveStd_USCOREPasan' for type '' */
#ifndef SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan
#define SOAP_TYPE__ns1__jKoIVMoveStd_USCOREPasan (24)
#endif

/* _ns1__IV_USCOREDataCollectionResponse has binding name '_ns1__IV_USCOREDataCollectionResponse' for type '' */
#ifndef SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse
#define SOAP_TYPE__ns1__IV_USCOREDataCollectionResponse (23)
#endif

/* _ns1__IV_USCOREDataCollection has binding name '_ns1__IV_USCOREDataCollection' for type '' */
#ifndef SOAP_TYPE__ns1__IV_USCOREDataCollection
#define SOAP_TYPE__ns1__IV_USCOREDataCollection (22)
#endif

/* _ns1__GetCurrentSpecBySnResponse has binding name '_ns1__GetCurrentSpecBySnResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetCurrentSpecBySnResponse
#define SOAP_TYPE__ns1__GetCurrentSpecBySnResponse (21)
#endif

/* _ns1__GetCurrentSpecBySn has binding name '_ns1__GetCurrentSpecBySn' for type '' */
#ifndef SOAP_TYPE__ns1__GetCurrentSpecBySn
#define SOAP_TYPE__ns1__GetCurrentSpecBySn (20)
#endif

/* _ns1__GetWorkCenterIDResponse has binding name '_ns1__GetWorkCenterIDResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetWorkCenterIDResponse
#define SOAP_TYPE__ns1__GetWorkCenterIDResponse (19)
#endif

/* _ns1__GetWorkCenterID has binding name '_ns1__GetWorkCenterID' for type '' */
#ifndef SOAP_TYPE__ns1__GetWorkCenterID
#define SOAP_TYPE__ns1__GetWorkCenterID (18)
#endif

/* ns1__FIDailyWorkReturnEntity has binding name 'ns1__FIDailyWorkReturnEntity' for type 'ns1:FIDailyWorkReturnEntity' */
#ifndef SOAP_TYPE_ns1__FIDailyWorkReturnEntity
#define SOAP_TYPE_ns1__FIDailyWorkReturnEntity (17)
#endif

/* ns1__ArrayOfFIDailyWorkReturnEntity has binding name 'ns1__ArrayOfFIDailyWorkReturnEntity' for type 'ns1:ArrayOfFIDailyWorkReturnEntity' */
#ifndef SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity
#define SOAP_TYPE_ns1__ArrayOfFIDailyWorkReturnEntity (16)
#endif

/* ns1__MaterialBatchResultInfo has binding name 'ns1__MaterialBatchResultInfo' for type 'ns1:MaterialBatchResultInfo' */
#ifndef SOAP_TYPE_ns1__MaterialBatchResultInfo
#define SOAP_TYPE_ns1__MaterialBatchResultInfo (15)
#endif

/* ns1__ArrayOfMaterialBatchResultInfo has binding name 'ns1__ArrayOfMaterialBatchResultInfo' for type 'ns1:ArrayOfMaterialBatchResultInfo' */
#ifndef SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo
#define SOAP_TYPE_ns1__ArrayOfMaterialBatchResultInfo (14)
#endif

/* ns1__DefectResultInfo has binding name 'ns1__DefectResultInfo' for type 'ns1:DefectResultInfo' */
#ifndef SOAP_TYPE_ns1__DefectResultInfo
#define SOAP_TYPE_ns1__DefectResultInfo (13)
#endif

/* ns1__ArrayOfDefectResultInfo has binding name 'ns1__ArrayOfDefectResultInfo' for type 'ns1:ArrayOfDefectResultInfo' */
#ifndef SOAP_TYPE_ns1__ArrayOfDefectResultInfo
#define SOAP_TYPE_ns1__ArrayOfDefectResultInfo (12)
#endif

/* ns1__ArrayOfSubmitResult has binding name 'ns1__ArrayOfSubmitResult' for type 'ns1:ArrayOfSubmitResult' */
#ifndef SOAP_TYPE_ns1__ArrayOfSubmitResult
#define SOAP_TYPE_ns1__ArrayOfSubmitResult (11)
#endif

/* ns1__SubmitResult has binding name 'ns1__SubmitResult' for type 'ns1:SubmitResult' */
#ifndef SOAP_TYPE_ns1__SubmitResult
#define SOAP_TYPE_ns1__SubmitResult (10)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (9)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (195)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (194)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (191)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (189)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (188)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (197)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (196)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (190)
#endif

/* _ns1__Login * has binding name 'PointerTo_ns1__Login' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Login
#define SOAP_TYPE_PointerTo_ns1__Login (146)
#endif

/* _ns1__CanLogin * has binding name 'PointerTo_ns1__CanLogin' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CanLogin
#define SOAP_TYPE_PointerTo_ns1__CanLogin (142)
#endif

/* _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs * has binding name 'PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs
#define SOAP_TYPE_PointerTo_ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs (138)
#endif

/* _ns1__SetMaterialBatchResultToMES * has binding name 'PointerTo_ns1__SetMaterialBatchResultToMES' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetMaterialBatchResultToMES
#define SOAP_TYPE_PointerTo_ns1__SetMaterialBatchResultToMES (134)
#endif

/* _ns1__SetDefectResultToMES * has binding name 'PointerTo_ns1__SetDefectResultToMES' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SetDefectResultToMES
#define SOAP_TYPE_PointerTo_ns1__SetDefectResultToMES (130)
#endif

/* _ns1__GetDefectInfoToSAP * has binding name 'PointerTo_ns1__GetDefectInfoToSAP' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetDefectInfoToSAP
#define SOAP_TYPE_PointerTo_ns1__GetDefectInfoToSAP (126)
#endif

/* _ns1__GetFtpAddress * has binding name 'PointerTo_ns1__GetFtpAddress' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetFtpAddress
#define SOAP_TYPE_PointerTo_ns1__GetFtpAddress (122)
#endif

/* _ns1__Iscalibrationcontainer * has binding name 'PointerTo_ns1__Iscalibrationcontainer' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Iscalibrationcontainer
#define SOAP_TYPE_PointerTo_ns1__Iscalibrationcontainer (118)
#endif

/* _ns1__GetTensileTestRule * has binding name 'PointerTo_ns1__GetTensileTestRule' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetTensileTestRule
#define SOAP_TYPE_PointerTo_ns1__GetTensileTestRule (114)
#endif

/* _ns1__GetContainerDataInfoMES * has binding name 'PointerTo_ns1__GetContainerDataInfoMES' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetContainerDataInfoMES
#define SOAP_TYPE_PointerTo_ns1__GetContainerDataInfoMES (110)
#endif

/* _ns1__UploadTensileInfoToMes * has binding name 'PointerTo_ns1__UploadTensileInfoToMes' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__UploadTensileInfoToMes
#define SOAP_TYPE_PointerTo_ns1__UploadTensileInfoToMes (106)
#endif

/* _ns1__SafetyInfoMoveStd * has binding name 'PointerTo_ns1__SafetyInfoMoveStd' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SafetyInfoMoveStd
#define SOAP_TYPE_PointerTo_ns1__SafetyInfoMoveStd (102)
#endif

/* _ns1__ELInfoMoveStd * has binding name 'PointerTo_ns1__ELInfoMoveStd' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ELInfoMoveStd
#define SOAP_TYPE_PointerTo_ns1__ELInfoMoveStd (98)
#endif

/* _ns1__ELPictureAddress * has binding name 'PointerTo_ns1__ELPictureAddress' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ELPictureAddress
#define SOAP_TYPE_PointerTo_ns1__ELPictureAddress (94)
#endif

/* _ns1__jKoIVMoveStd_USCORESpire * has binding name 'PointerTo_ns1__jKoIVMoveStd_USCORESpire' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__jKoIVMoveStd_USCORESpire
#define SOAP_TYPE_PointerTo_ns1__jKoIVMoveStd_USCORESpire (90)
#endif

/* _ns1__jKoIVMoveStd_USCOREPasan * has binding name 'PointerTo_ns1__jKoIVMoveStd_USCOREPasan' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__jKoIVMoveStd_USCOREPasan
#define SOAP_TYPE_PointerTo_ns1__jKoIVMoveStd_USCOREPasan (86)
#endif

/* _ns1__IV_USCOREDataCollection * has binding name 'PointerTo_ns1__IV_USCOREDataCollection' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__IV_USCOREDataCollection
#define SOAP_TYPE_PointerTo_ns1__IV_USCOREDataCollection (82)
#endif

/* _ns1__GetCurrentSpecBySn * has binding name 'PointerTo_ns1__GetCurrentSpecBySn' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetCurrentSpecBySn
#define SOAP_TYPE_PointerTo_ns1__GetCurrentSpecBySn (78)
#endif

/* _ns1__GetWorkCenterID * has binding name 'PointerTo_ns1__GetWorkCenterID' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetWorkCenterID
#define SOAP_TYPE_PointerTo_ns1__GetWorkCenterID (74)
#endif

/* ns1__ArrayOfFIDailyWorkReturnEntity * has binding name 'PointerTons1__ArrayOfFIDailyWorkReturnEntity' for type 'ns1:ArrayOfFIDailyWorkReturnEntity' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfFIDailyWorkReturnEntity
#define SOAP_TYPE_PointerTons1__ArrayOfFIDailyWorkReturnEntity (73)
#endif

/* ns1__ArrayOfMaterialBatchResultInfo * has binding name 'PointerTons1__ArrayOfMaterialBatchResultInfo' for type 'ns1:ArrayOfMaterialBatchResultInfo' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfMaterialBatchResultInfo
#define SOAP_TYPE_PointerTons1__ArrayOfMaterialBatchResultInfo (72)
#endif

/* ns1__ArrayOfDefectResultInfo * has binding name 'PointerTons1__ArrayOfDefectResultInfo' for type 'ns1:ArrayOfDefectResultInfo' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfDefectResultInfo
#define SOAP_TYPE_PointerTons1__ArrayOfDefectResultInfo (71)
#endif

/* ns1__ArrayOfSubmitResult * has binding name 'PointerTons1__ArrayOfSubmitResult' for type 'ns1:ArrayOfSubmitResult' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfSubmitResult
#define SOAP_TYPE_PointerTons1__ArrayOfSubmitResult (70)
#endif

/* ns1__FIDailyWorkReturnEntity * has binding name 'PointerTons1__FIDailyWorkReturnEntity' for type 'ns1:FIDailyWorkReturnEntity' */
#ifndef SOAP_TYPE_PointerTons1__FIDailyWorkReturnEntity
#define SOAP_TYPE_PointerTons1__FIDailyWorkReturnEntity (67)
#endif

/* ns1__MaterialBatchResultInfo * has binding name 'PointerTons1__MaterialBatchResultInfo' for type 'ns1:MaterialBatchResultInfo' */
#ifndef SOAP_TYPE_PointerTons1__MaterialBatchResultInfo
#define SOAP_TYPE_PointerTons1__MaterialBatchResultInfo (65)
#endif

/* ns1__DefectResultInfo * has binding name 'PointerTons1__DefectResultInfo' for type 'ns1:DefectResultInfo' */
#ifndef SOAP_TYPE_PointerTons1__DefectResultInfo
#define SOAP_TYPE_PointerTons1__DefectResultInfo (63)
#endif

/* ns1__SubmitResult * has binding name 'PointerTons1__SubmitResult' for type 'ns1:SubmitResult' */
#ifndef SOAP_TYPE_PointerTons1__SubmitResult
#define SOAP_TYPE_PointerTons1__SubmitResult (61)
#endif

/* _ns1__SubmitResult_ResultTable * has binding name 'PointerTo_ns1__SubmitResult_ResultTable' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__SubmitResult_ResultTable
#define SOAP_TYPE_PointerTo_ns1__SubmitResult_ResultTable (59)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (56)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns1__FIDailyWorkReturnEntity *>  has binding name 'std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity' for type 'ns1:FIDailyWorkReturnEntity' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__FIDailyWorkReturnEntity (68)
#endif

/* std::vector<ns1__MaterialBatchResultInfo *>  has binding name 'std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo' for type 'ns1:MaterialBatchResultInfo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__MaterialBatchResultInfo (66)
#endif

/* std::vector<ns1__DefectResultInfo *>  has binding name 'std__vectorTemplateOfPointerTons1__DefectResultInfo' for type 'ns1:DefectResultInfo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__DefectResultInfo
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__DefectResultInfo (64)
#endif

/* std::vector<ns1__SubmitResult *>  has binding name 'std__vectorTemplateOfPointerTons1__SubmitResult' for type 'ns1:SubmitResult' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubmitResult
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubmitResult (62)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOf_XML' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_XML
#define SOAP_TYPE_std__vectorTemplateOf_XML (58)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stub Functions                                            *
 *                                                                            *
\******************************************************************************/

    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetWorkCenterID(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetWorkCenterID *ns1__GetWorkCenterID, _ns1__GetWorkCenterIDResponse &ns1__GetWorkCenterIDResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetCurrentSpecBySn(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetCurrentSpecBySn *ns1__GetCurrentSpecBySn, _ns1__GetCurrentSpecBySnResponse &ns1__GetCurrentSpecBySnResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__IV_USCOREDataCollection(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__IV_USCOREDataCollection *ns1__IV_USCOREDataCollection, _ns1__IV_USCOREDataCollectionResponse &ns1__IV_USCOREDataCollectionResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__jKoIVMoveStd_USCOREPasan(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__jKoIVMoveStd_USCOREPasan *ns1__jKoIVMoveStd_USCOREPasan, _ns1__jKoIVMoveStd_USCOREPasanResponse &ns1__jKoIVMoveStd_USCOREPasanResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__jKoIVMoveStd_USCORESpire(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__jKoIVMoveStd_USCORESpire *ns1__jKoIVMoveStd_USCORESpire, _ns1__jKoIVMoveStd_USCORESpireResponse &ns1__jKoIVMoveStd_USCORESpireResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ELPictureAddress(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ELPictureAddress *ns1__ELPictureAddress, _ns1__ELPictureAddressResponse &ns1__ELPictureAddressResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ELInfoMoveStd(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ELInfoMoveStd *ns1__ELInfoMoveStd, _ns1__ELInfoMoveStdResponse &ns1__ELInfoMoveStdResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SafetyInfoMoveStd(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SafetyInfoMoveStd *ns1__SafetyInfoMoveStd, _ns1__SafetyInfoMoveStdResponse &ns1__SafetyInfoMoveStdResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__UploadTensileInfoToMes(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__UploadTensileInfoToMes *ns1__UploadTensileInfoToMes, _ns1__UploadTensileInfoToMesResponse &ns1__UploadTensileInfoToMesResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetContainerDataInfoMES(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetContainerDataInfoMES *ns1__GetContainerDataInfoMES, _ns1__GetContainerDataInfoMESResponse &ns1__GetContainerDataInfoMESResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetTensileTestRule(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetTensileTestRule *ns1__GetTensileTestRule, _ns1__GetTensileTestRuleResponse &ns1__GetTensileTestRuleResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Iscalibrationcontainer(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Iscalibrationcontainer *ns1__Iscalibrationcontainer, _ns1__IscalibrationcontainerResponse &ns1__IscalibrationcontainerResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetFtpAddress(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetFtpAddress *ns1__GetFtpAddress, _ns1__GetFtpAddressResponse &ns1__GetFtpAddressResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetDefectInfoToSAP(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetDefectInfoToSAP *ns1__GetDefectInfoToSAP, _ns1__GetDefectInfoToSAPResponse &ns1__GetDefectInfoToSAPResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SetDefectResultToMES(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetDefectResultToMES *ns1__SetDefectResultToMES, _ns1__SetDefectResultToMESResponse &ns1__SetDefectResultToMESResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SetMaterialBatchResultToMES(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetMaterialBatchResultToMES *ns1__SetMaterialBatchResultToMES, _ns1__SetMaterialBatchResultToMESResponse &ns1__SetMaterialBatchResultToMESResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse &ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CanLogin(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CanLogin *ns1__CanLogin, _ns1__CanLoginResponse &ns1__CanLoginResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Login(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Login *ns1__Login, _ns1__LoginResponse &ns1__LoginResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetWorkCenterID_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetWorkCenterID *ns1__GetWorkCenterID, _ns1__GetWorkCenterIDResponse &ns1__GetWorkCenterIDResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetCurrentSpecBySn_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetCurrentSpecBySn *ns1__GetCurrentSpecBySn, _ns1__GetCurrentSpecBySnResponse &ns1__GetCurrentSpecBySnResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__IV_USCOREDataCollection_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__IV_USCOREDataCollection *ns1__IV_USCOREDataCollection, _ns1__IV_USCOREDataCollectionResponse &ns1__IV_USCOREDataCollectionResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__jKoIVMoveStd_USCOREPasan_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__jKoIVMoveStd_USCOREPasan *ns1__jKoIVMoveStd_USCOREPasan, _ns1__jKoIVMoveStd_USCOREPasanResponse &ns1__jKoIVMoveStd_USCOREPasanResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__jKoIVMoveStd_USCORESpire_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__jKoIVMoveStd_USCORESpire *ns1__jKoIVMoveStd_USCORESpire, _ns1__jKoIVMoveStd_USCORESpireResponse &ns1__jKoIVMoveStd_USCORESpireResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ELPictureAddress_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ELPictureAddress *ns1__ELPictureAddress, _ns1__ELPictureAddressResponse &ns1__ELPictureAddressResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__ELInfoMoveStd_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__ELInfoMoveStd *ns1__ELInfoMoveStd, _ns1__ELInfoMoveStdResponse &ns1__ELInfoMoveStdResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SafetyInfoMoveStd_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SafetyInfoMoveStd *ns1__SafetyInfoMoveStd, _ns1__SafetyInfoMoveStdResponse &ns1__SafetyInfoMoveStdResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__UploadTensileInfoToMes_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__UploadTensileInfoToMes *ns1__UploadTensileInfoToMes, _ns1__UploadTensileInfoToMesResponse &ns1__UploadTensileInfoToMesResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetContainerDataInfoMES_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetContainerDataInfoMES *ns1__GetContainerDataInfoMES, _ns1__GetContainerDataInfoMESResponse &ns1__GetContainerDataInfoMESResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetTensileTestRule_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetTensileTestRule *ns1__GetTensileTestRule, _ns1__GetTensileTestRuleResponse &ns1__GetTensileTestRuleResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Iscalibrationcontainer_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Iscalibrationcontainer *ns1__Iscalibrationcontainer, _ns1__IscalibrationcontainerResponse &ns1__IscalibrationcontainerResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetFtpAddress_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetFtpAddress *ns1__GetFtpAddress, _ns1__GetFtpAddressResponse &ns1__GetFtpAddressResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetDefectInfoToSAP_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetDefectInfoToSAP *ns1__GetDefectInfoToSAP, _ns1__GetDefectInfoToSAPResponse &ns1__GetDefectInfoToSAPResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SetDefectResultToMES_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetDefectResultToMES *ns1__SetDefectResultToMES, _ns1__SetDefectResultToMESResponse &ns1__SetDefectResultToMESResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SetMaterialBatchResultToMES_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SetMaterialBatchResultToMES *ns1__SetMaterialBatchResultToMES, _ns1__SetMaterialBatchResultToMESResponse &ns1__SetMaterialBatchResultToMESResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse &ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__CanLogin_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__CanLogin *ns1__CanLogin, _ns1__CanLoginResponse &ns1__CanLoginResponse);
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Login_(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Login *ns1__Login, _ns1__LoginResponse &ns1__LoginResponse);

/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/

    /** Web service operation '__ns1__GetWorkCenterID' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetWorkCenterID(struct soap*, _ns1__GetWorkCenterID *ns1__GetWorkCenterID, _ns1__GetWorkCenterIDResponse &ns1__GetWorkCenterIDResponse);
    /** Web service operation '__ns1__GetCurrentSpecBySn' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetCurrentSpecBySn(struct soap*, _ns1__GetCurrentSpecBySn *ns1__GetCurrentSpecBySn, _ns1__GetCurrentSpecBySnResponse &ns1__GetCurrentSpecBySnResponse);
    /** Web service operation '__ns1__IV_USCOREDataCollection' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__IV_USCOREDataCollection(struct soap*, _ns1__IV_USCOREDataCollection *ns1__IV_USCOREDataCollection, _ns1__IV_USCOREDataCollectionResponse &ns1__IV_USCOREDataCollectionResponse);
    /** Web service operation '__ns1__jKoIVMoveStd_USCOREPasan' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__jKoIVMoveStd_USCOREPasan(struct soap*, _ns1__jKoIVMoveStd_USCOREPasan *ns1__jKoIVMoveStd_USCOREPasan, _ns1__jKoIVMoveStd_USCOREPasanResponse &ns1__jKoIVMoveStd_USCOREPasanResponse);
    /** Web service operation '__ns1__jKoIVMoveStd_USCORESpire' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__jKoIVMoveStd_USCORESpire(struct soap*, _ns1__jKoIVMoveStd_USCORESpire *ns1__jKoIVMoveStd_USCORESpire, _ns1__jKoIVMoveStd_USCORESpireResponse &ns1__jKoIVMoveStd_USCORESpireResponse);
    /** Web service operation '__ns1__ELPictureAddress' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ELPictureAddress(struct soap*, _ns1__ELPictureAddress *ns1__ELPictureAddress, _ns1__ELPictureAddressResponse &ns1__ELPictureAddressResponse);
    /** Web service operation '__ns1__ELInfoMoveStd' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ELInfoMoveStd(struct soap*, _ns1__ELInfoMoveStd *ns1__ELInfoMoveStd, _ns1__ELInfoMoveStdResponse &ns1__ELInfoMoveStdResponse);
    /** Web service operation '__ns1__SafetyInfoMoveStd' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__SafetyInfoMoveStd(struct soap*, _ns1__SafetyInfoMoveStd *ns1__SafetyInfoMoveStd, _ns1__SafetyInfoMoveStdResponse &ns1__SafetyInfoMoveStdResponse);
    /** Web service operation '__ns1__UploadTensileInfoToMes' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__UploadTensileInfoToMes(struct soap*, _ns1__UploadTensileInfoToMes *ns1__UploadTensileInfoToMes, _ns1__UploadTensileInfoToMesResponse &ns1__UploadTensileInfoToMesResponse);
    /** Web service operation '__ns1__GetContainerDataInfoMES' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetContainerDataInfoMES(struct soap*, _ns1__GetContainerDataInfoMES *ns1__GetContainerDataInfoMES, _ns1__GetContainerDataInfoMESResponse &ns1__GetContainerDataInfoMESResponse);
    /** Web service operation '__ns1__GetTensileTestRule' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetTensileTestRule(struct soap*, _ns1__GetTensileTestRule *ns1__GetTensileTestRule, _ns1__GetTensileTestRuleResponse &ns1__GetTensileTestRuleResponse);
    /** Web service operation '__ns1__Iscalibrationcontainer' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__Iscalibrationcontainer(struct soap*, _ns1__Iscalibrationcontainer *ns1__Iscalibrationcontainer, _ns1__IscalibrationcontainerResponse &ns1__IscalibrationcontainerResponse);
    /** Web service operation '__ns1__GetFtpAddress' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetFtpAddress(struct soap*, _ns1__GetFtpAddress *ns1__GetFtpAddress, _ns1__GetFtpAddressResponse &ns1__GetFtpAddressResponse);
    /** Web service operation '__ns1__GetDefectInfoToSAP' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetDefectInfoToSAP(struct soap*, _ns1__GetDefectInfoToSAP *ns1__GetDefectInfoToSAP, _ns1__GetDefectInfoToSAPResponse &ns1__GetDefectInfoToSAPResponse);
    /** Web service operation '__ns1__SetDefectResultToMES' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__SetDefectResultToMES(struct soap*, _ns1__SetDefectResultToMES *ns1__SetDefectResultToMES, _ns1__SetDefectResultToMESResponse &ns1__SetDefectResultToMESResponse);
    /** Web service operation '__ns1__SetMaterialBatchResultToMES' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__SetMaterialBatchResultToMES(struct soap*, _ns1__SetMaterialBatchResultToMES *ns1__SetMaterialBatchResultToMES, _ns1__SetMaterialBatchResultToMESResponse &ns1__SetMaterialBatchResultToMESResponse);
    /** Web service operation '__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap*, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse &ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse);
    /** Web service operation '__ns1__CanLogin' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__CanLogin(struct soap*, _ns1__CanLogin *ns1__CanLogin, _ns1__CanLoginResponse &ns1__CanLoginResponse);
    /** Web service operation '__ns1__Login' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__Login(struct soap*, _ns1__Login *ns1__Login, _ns1__LoginResponse &ns1__LoginResponse);
    /** Web service operation '__ns1__GetWorkCenterID_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetWorkCenterID_(struct soap*, _ns1__GetWorkCenterID *ns1__GetWorkCenterID, _ns1__GetWorkCenterIDResponse &ns1__GetWorkCenterIDResponse);
    /** Web service operation '__ns1__GetCurrentSpecBySn_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetCurrentSpecBySn_(struct soap*, _ns1__GetCurrentSpecBySn *ns1__GetCurrentSpecBySn, _ns1__GetCurrentSpecBySnResponse &ns1__GetCurrentSpecBySnResponse);
    /** Web service operation '__ns1__IV_USCOREDataCollection_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__IV_USCOREDataCollection_(struct soap*, _ns1__IV_USCOREDataCollection *ns1__IV_USCOREDataCollection, _ns1__IV_USCOREDataCollectionResponse &ns1__IV_USCOREDataCollectionResponse);
    /** Web service operation '__ns1__jKoIVMoveStd_USCOREPasan_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__jKoIVMoveStd_USCOREPasan_(struct soap*, _ns1__jKoIVMoveStd_USCOREPasan *ns1__jKoIVMoveStd_USCOREPasan, _ns1__jKoIVMoveStd_USCOREPasanResponse &ns1__jKoIVMoveStd_USCOREPasanResponse);
    /** Web service operation '__ns1__jKoIVMoveStd_USCORESpire_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__jKoIVMoveStd_USCORESpire_(struct soap*, _ns1__jKoIVMoveStd_USCORESpire *ns1__jKoIVMoveStd_USCORESpire, _ns1__jKoIVMoveStd_USCORESpireResponse &ns1__jKoIVMoveStd_USCORESpireResponse);
    /** Web service operation '__ns1__ELPictureAddress_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ELPictureAddress_(struct soap*, _ns1__ELPictureAddress *ns1__ELPictureAddress, _ns1__ELPictureAddressResponse &ns1__ELPictureAddressResponse);
    /** Web service operation '__ns1__ELInfoMoveStd_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__ELInfoMoveStd_(struct soap*, _ns1__ELInfoMoveStd *ns1__ELInfoMoveStd, _ns1__ELInfoMoveStdResponse &ns1__ELInfoMoveStdResponse);
    /** Web service operation '__ns1__SafetyInfoMoveStd_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__SafetyInfoMoveStd_(struct soap*, _ns1__SafetyInfoMoveStd *ns1__SafetyInfoMoveStd, _ns1__SafetyInfoMoveStdResponse &ns1__SafetyInfoMoveStdResponse);
    /** Web service operation '__ns1__UploadTensileInfoToMes_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__UploadTensileInfoToMes_(struct soap*, _ns1__UploadTensileInfoToMes *ns1__UploadTensileInfoToMes, _ns1__UploadTensileInfoToMesResponse &ns1__UploadTensileInfoToMesResponse);
    /** Web service operation '__ns1__GetContainerDataInfoMES_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetContainerDataInfoMES_(struct soap*, _ns1__GetContainerDataInfoMES *ns1__GetContainerDataInfoMES, _ns1__GetContainerDataInfoMESResponse &ns1__GetContainerDataInfoMESResponse);
    /** Web service operation '__ns1__GetTensileTestRule_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetTensileTestRule_(struct soap*, _ns1__GetTensileTestRule *ns1__GetTensileTestRule, _ns1__GetTensileTestRuleResponse &ns1__GetTensileTestRuleResponse);
    /** Web service operation '__ns1__Iscalibrationcontainer_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__Iscalibrationcontainer_(struct soap*, _ns1__Iscalibrationcontainer *ns1__Iscalibrationcontainer, _ns1__IscalibrationcontainerResponse &ns1__IscalibrationcontainerResponse);
    /** Web service operation '__ns1__GetFtpAddress_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetFtpAddress_(struct soap*, _ns1__GetFtpAddress *ns1__GetFtpAddress, _ns1__GetFtpAddressResponse &ns1__GetFtpAddressResponse);
    /** Web service operation '__ns1__GetDefectInfoToSAP_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetDefectInfoToSAP_(struct soap*, _ns1__GetDefectInfoToSAP *ns1__GetDefectInfoToSAP, _ns1__GetDefectInfoToSAPResponse &ns1__GetDefectInfoToSAPResponse);
    /** Web service operation '__ns1__SetDefectResultToMES_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__SetDefectResultToMES_(struct soap*, _ns1__SetDefectResultToMES *ns1__SetDefectResultToMES, _ns1__SetDefectResultToMESResponse &ns1__SetDefectResultToMESResponse);
    /** Web service operation '__ns1__SetMaterialBatchResultToMES_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__SetMaterialBatchResultToMES_(struct soap*, _ns1__SetMaterialBatchResultToMES *ns1__SetMaterialBatchResultToMES, _ns1__SetMaterialBatchResultToMESResponse &ns1__SetMaterialBatchResultToMESResponse);
    /** Web service operation '__ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(struct soap*, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs *ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs, _ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse &ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGsResponse);
    /** Web service operation '__ns1__CanLogin_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__CanLogin_(struct soap*, _ns1__CanLogin *ns1__CanLogin, _ns1__CanLoginResponse &ns1__CanLoginResponse);
    /** Web service operation '__ns1__Login_' (returns SOAP_OK or error code) */
    SOAP_FMAC5 int SOAP_FMAC6 __ns1__Login_(struct soap*, _ns1__Login *ns1__Login, _ns1__LoginResponse &ns1__LoginResponse);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetWorkCenterID(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetCurrentSpecBySn(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__IV_USCOREDataCollection(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__jKoIVMoveStd_USCOREPasan(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__jKoIVMoveStd_USCORESpire(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ELPictureAddress(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ELInfoMoveStd(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__SafetyInfoMoveStd(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__UploadTensileInfoToMes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetContainerDataInfoMES(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetTensileTestRule(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__Iscalibrationcontainer(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetFtpAddress(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetDefectInfoToSAP(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__SetDefectResultToMES(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__SetMaterialBatchResultToMES(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__CanLogin(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__Login(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetWorkCenterID_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetCurrentSpecBySn_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__IV_USCOREDataCollection_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__jKoIVMoveStd_USCOREPasan_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__jKoIVMoveStd_USCORESpire_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ELPictureAddress_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__ELInfoMoveStd_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__SafetyInfoMoveStd_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__UploadTensileInfoToMes_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetContainerDataInfoMES_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetTensileTestRule_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__Iscalibrationcontainer_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetFtpAddress_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetDefectInfoToSAP_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__SetDefectResultToMES_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__SetMaterialBatchResultToMES_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__Upload_USCOREFIDWUL_USCOREDATAFLAGs_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__CanLogin_(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__Login_(struct soap*);

#endif

/* End of soapStub.h */
